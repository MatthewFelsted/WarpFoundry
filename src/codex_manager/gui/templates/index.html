<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{ project_display_name }}</title>
<style>
/* -- Reset & Base ----------------------------------------------- */
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  color-scheme: dark;
  --bg:        #070b11;
  --bg-elev:   #0f1622;
  --surface:   #131d2b;
  --surface2:  #1b2738;
  --surface3:  #23334a;
  --border:    #2d3d53;
  --border-soft: rgba(160, 190, 228, 0.24);
  --text:      #edf4ff;
  --text2:     #b4c3d8;
  --text3:     #90a2bc;
  --accent:    #6ec7ff;
  --accent2:   #a1ddff;
  --success:   #47c07b;
  --warning:   #dfaa58;
  --danger:    #ff6f6f;
  --purple:    #8ea7ff;
  --radius:    11px;
  --radius-lg: 16px;
  --shadow-md: 0 12px 34px rgba(3, 8, 20, 0.38);
  --shadow-lg: 0 18px 42px rgba(3, 8, 20, 0.5);
  --font:      'Aptos', 'Segoe UI Variable', 'Trebuchet MS', 'Segoe UI', sans-serif;
  --mono:      'Cascadia Code', 'Fira Code', 'Consolas', monospace;
}
html,body{height:100%;overflow:hidden}
body{
  font-family:var(--font);
  background:
    radial-gradient(circle at 2% 8%, rgba(110,199,255,.14), transparent 38%),
    radial-gradient(circle at 98% -4%, rgba(142,167,255,.16), transparent 36%),
    var(--bg);
  color:var(--text);
  font-size:14px;
  line-height:1.5;
  display:flex;
  flex-direction:column;
  -webkit-font-smoothing:antialiased;
  text-rendering:optimizeLegibility;
}
body.modal-open{overflow:hidden}
input::placeholder,textarea::placeholder{color:var(--text3)}

/* -- Scrollbar -------------------------------------------------- */
::-webkit-scrollbar{width:6px;height:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:var(--text2)}

/* -- Header ----------------------------------------------------- */
header{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:10px 18px;
  padding:10px 18px 11px;
  min-height:62px;
  background:linear-gradient(180deg, rgba(19,29,43,.96), rgba(15,22,34,.9));
  border-bottom:1px solid var(--border-soft);
  backdrop-filter:blur(10px);
  flex-shrink:0;
  position:sticky;
  top:0;
  z-index:100;
  overflow:visible
}
.header-brand{display:flex;align-items:center;gap:14px;min-width:0;flex:1 1 420px;flex-wrap:wrap}
.header-workspace-links{display:flex;gap:4px;align-items:center;flex-wrap:wrap}
.header-workspace-links .btn{padding:5px 10px;font-size:12px}
.logo{font-size:19px;font-weight:700;letter-spacing:.1px;white-space:nowrap}
.logo span{color:var(--accent2);filter:drop-shadow(0 0 8px rgba(110,199,255,.42))}
.header-actions{display:flex;gap:8px;align-items:flex-start;flex:1 1 560px;min-width:0;flex-wrap:wrap;justify-content:flex-end}
.header-actions select,.header-actions button{font-size:13px}
#difficulty-mode-toggle{flex-shrink:0;position:relative;z-index:2}
.header-actions select{min-width:120px;max-width:180px}
.header-doc-links{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.header-doc-links .btn{padding:5px 9px;font-size:12px}
.git-sync-drawer{position:relative;display:flex;align-items:center;flex-shrink:0}
.git-sync-drawer-toggle{padding:5px 10px;font-size:12px;white-space:nowrap}
.git-sync-controls{
  position:absolute;
  right:0;
  top:calc(100% + 8px);
  display:flex;
  align-items:center;
  gap:6px;
  flex-wrap:wrap;
  width:min(980px, calc(100vw - 36px));
  max-height:62vh;
  overflow:auto;
  padding:8px;
  border:1px solid var(--border-soft);
  border-radius:var(--radius-lg);
  background:linear-gradient(180deg, rgba(11,18,28,.98), rgba(8,13,22,.96));
  box-shadow:var(--shadow-md);
  z-index:180;
}
.git-sync-drawer.open .git-sync-drawer-toggle{
  border-color:var(--accent);
  color:var(--accent2);
}
.git-sync-controls[hidden]{display:none}
.git-sync-controls .btn{padding:5px 10px;font-size:12px}
.git-sync-controls select,.git-sync-controls input[type="text"]{
  font-size:12px;
  min-height:30px;
  border-radius:8px;
}
.git-sync-branch-select{min-width:170px;max-width:240px}
.git-sync-branch-input{min-width:135px;width:160px}
.git-sync-option{display:inline-flex;align-items:center;gap:4px;font-size:11px;color:var(--text2);padding:0 2px;white-space:nowrap}
.git-sync-option input[type="checkbox"]{margin-right:0}
.git-sync-widget{display:flex;flex-direction:column;gap:5px;min-width:290px;max-width:430px;padding:7px 8px;border:1px solid var(--border);border-radius:var(--radius);background:rgba(7,11,17,.72)}
.git-sync-widget[data-tone="ok"]{border-color:rgba(71,192,123,.55);background:rgba(71,192,123,.1)}
.git-sync-widget[data-tone="warn"]{border-color:rgba(223,170,88,.55);background:rgba(223,170,88,.12)}
.git-sync-widget[data-tone="error"]{border-color:rgba(255,111,111,.55);background:rgba(255,111,111,.1)}
.git-sync-widget-head{display:flex;align-items:center;justify-content:space-between;gap:8px}
.git-sync-widget-title{font-size:10px;color:var(--text3);letter-spacing:.45px;text-transform:uppercase;white-space:nowrap}
.git-sync-widget-actions{display:flex;align-items:center;gap:6px}
.git-sync-widget-head .btn{padding:3px 8px;font-size:11px;min-height:0}
.git-sync-widget-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:3px 10px}
.git-sync-widget-item{display:flex;gap:5px;align-items:center;min-width:0;font-size:11px}
.git-sync-widget-key{color:var(--text3);font-size:10px;letter-spacing:.2px;text-transform:uppercase;white-space:nowrap}
.git-sync-widget-value{color:var(--text);font-family:var(--mono);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.git-sync-indicator{font-size:11px;color:var(--text2);min-height:1.1em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.git-sync-indicator[data-tone="ok"]{color:var(--success)}
.git-sync-indicator[data-tone="warn"]{color:var(--warning)}
.git-sync-indicator[data-tone="error"]{color:var(--danger)}

/* Docs modal */
#docs-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:2500;display:flex;align-items:center;justify-content:center;padding:24px}
#docs-overlay.hidden{display:none}
.docs-modal{width:980px;max-width:100%;max-height:80vh;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);display:flex;flex-direction:column;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.docs-modal-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:12px}
.docs-modal-header h3{font-size:15px;color:var(--text);margin:0}
.docs-subtitle{font-size:12px;color:var(--text2);margin-top:4px}
.docs-tab-row{padding:10px 16px;border-bottom:1px solid var(--border);display:flex;gap:8px;flex-wrap:wrap}
.docs-tab-row .btn.active{border-color:var(--accent);background:rgba(88,166,255,.14);color:var(--accent2)}
.docs-content{padding:14px 16px;flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;background:var(--bg);color:var(--text);font-family:var(--mono);font-size:12px;line-height:1.55}

/* -- Layout ----------------------------------------------------- */
main{display:grid;grid-template-columns:minmax(360px,420px) minmax(0,1fr);flex:1;overflow:hidden;min-height:0}
.panel{overflow-y:auto;padding:20px 22px}
#chain-panel{border-right:1px solid var(--border-soft);display:flex;flex-direction:column;gap:16px;min-height:0}
#exec-panel{overflow-x:hidden;overflow-y:auto;padding:20px 22px;min-height:0}
#exec-panel > *{margin-bottom:16px}
#exec-panel > *:last-child{margin-bottom:0}
#pipeline-exec{overflow-x:hidden;overflow-y:auto;min-height:0}

/* -- Shared UI -------------------------------------------------- */
h2{font-size:16px;font-weight:700;letter-spacing:.2px;color:var(--text);margin-bottom:8px}
h3{font-size:13px;font-weight:650;color:var(--text2);margin-bottom:8px}
label{font-size:12px;color:var(--text2);display:block;margin-bottom:5px}
input[type="text"],input[type="number"],select,textarea{
  width:100%;padding:9px 11px;border:1px solid var(--border);border-radius:var(--radius);
  background:linear-gradient(180deg, rgba(15,22,34,.92), rgba(15,22,34,.82));color:var(--text);
  font-family:var(--font);font-size:13px;min-height:36px;outline:none;
  transition:border .15s, box-shadow .15s, background .15s}
input:hover,select:hover,textarea:hover{border-color:var(--border-soft)}
input:focus,select:focus,textarea:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(110,199,255,.24), 0 4px 18px rgba(12,24,39,.28);
  background:var(--surface)
}
/* Improve native select menu readability across Chromium variants (incl. Brave). */
select option{background:var(--surface);color:var(--text)}
textarea{resize:vertical;font-family:var(--mono);font-size:12px;line-height:1.5}
input[type="checkbox"]{accent-color:var(--accent);margin-right:6px;vertical-align:middle}

.btn{
  padding:8px 14px;border:1px solid var(--border);border-radius:10px;min-height:35px;
  background:linear-gradient(180deg, var(--surface2), var(--surface));
  color:var(--text);cursor:pointer;font-size:13px;font-family:var(--font);
  transition:transform .15s, border-color .15s, background .15s, box-shadow .15s, filter .15s
}
.btn:hover{background:var(--surface3);border-color:var(--border-soft);transform:translateY(-1px);box-shadow:0 8px 22px rgba(5,12,22,.36)}
.btn:active{transform:translateY(0)}
.btn:disabled{opacity:.52;cursor:not-allowed;transform:none;box-shadow:none}
.btn-primary{background:var(--accent);color:#000;border-color:var(--accent);font-weight:600}
.btn-primary:hover{background:var(--accent2)}
.btn-danger{border-color:var(--danger);color:var(--danger)}
.btn-danger:hover{background:rgba(248,81,73,.15)}
.btn-success{border-color:var(--success);color:var(--success)}
.btn-success:hover{background:rgba(63,185,80,.15)}
.btn-warning{border-color:var(--warning);color:var(--warning)}
.btn-warning:hover{background:rgba(210,153,34,.15)}

.config-section{
  background:linear-gradient(180deg, rgba(19,29,43,.96), rgba(16,23,35,.93));
  border:1px solid var(--border-soft);border-radius:var(--radius-lg);padding:15px 16px;
  box-shadow:var(--shadow-md);
  backdrop-filter:blur(6px)
}
.form-row{margin-bottom:10px}
.form-row:last-child{margin-bottom:0}
.form-row-inline{display:flex;gap:12px;align-items:center}
.form-row-inline > *{flex:1}
.option-subpanel{
  border:1px solid var(--border);
  border-radius:var(--radius);
  background:rgba(19,29,43,.55);
  padding:10px;
  margin-top:8px;
}
.option-subpanel.hidden{display:none}
.scope-note{
  display:inline-block;
  font-size:11px;
  color:var(--accent2);
  border:1px solid rgba(110,199,255,.45);
  background:rgba(110,199,255,.08);
  border-radius:999px;
  padding:2px 8px;
  margin-bottom:8px;
}
.foundation-tools{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}

button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible,
summary:focus-visible{
  outline:2px solid transparent;
  box-shadow:0 0 0 3px rgba(110,199,255,.35), 0 0 0 1px rgba(161,221,255,.45);
}
.tab-nav button:focus-visible{border-bottom-color:var(--accent);color:var(--text)}

/* -- Mode Toggle ------------------------------------------------ */
.mode-toggle{display:flex;border:1px solid var(--border);border-radius:var(--radius);overflow:hidden}
.mode-toggle button{flex:1;padding:8px;border:none;background:var(--bg);color:var(--text2);cursor:pointer;font-size:13px;font-family:var(--font);transition:all .15s}
.mode-toggle button.active{background:var(--accent);color:#000;font-weight:600}
.mode-toggle button:hover:not(.active){background:var(--surface2)}

/* -- Repo Input ------------------------------------------------- */
.repo-row{display:flex;gap:8px;align-items:center}
.repo-row input{flex:1}
.repo-status{font-size:18px;width:24px;text-align:center;flex-shrink:0}
.workspace-repo-card{margin-top:10px;padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)}
.workspace-repo-head{display:flex;justify-content:space-between;gap:8px;align-items:center;margin-bottom:8px}
.workspace-repo-head strong{font-size:12px;color:var(--text)}
.workspace-repo-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
.workspace-repo-toolbar input{flex:1;min-width:180px}
.workspace-repo-status{font-size:11px;color:var(--text2);min-height:1.2em}
.workspace-repo-status[data-tone="ok"]{color:var(--success)}
.workspace-repo-status[data-tone="warn"]{color:var(--warning)}
.workspace-repo-status[data-tone="error"]{color:var(--danger)}
.workspace-repo-list{border:1px solid var(--border);border-radius:var(--radius);overflow:auto;background:var(--surface)}
.workspace-repo-table{width:100%;border-collapse:collapse;font-size:11px;min-width:720px}
.workspace-repo-table th,.workspace-repo-table td{padding:7px 8px;border-bottom:1px solid var(--border);text-align:left;vertical-align:top}
.workspace-repo-table thead th{font-size:10px;color:var(--text2);letter-spacing:.2px;text-transform:uppercase;background:var(--surface2);position:sticky;top:0;z-index:1}
.workspace-repo-table tbody tr:last-child td{border-bottom:none}
.workspace-repo-main{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.workspace-repo-main code{font-size:10px}
.workspace-repo-badge{font-size:10px;padding:2px 6px;border-radius:999px;border:1px solid var(--border);color:var(--text2);background:rgba(19,29,43,.7)}
.workspace-repo-badge.active{color:var(--success);border-color:rgba(71,192,123,.45);background:rgba(71,192,123,.12)}
.workspace-repo-branch{font-family:var(--mono)}
.workspace-repo-meta{display:block;color:var(--text2);margin-top:3px}
.workspace-repo-actions{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
.workspace-repo-actions .btn{padding:4px 8px;font-size:11px}
.workspace-repo-actions select{min-width:150px;max-width:180px}
.workspace-repo-actions .btn-danger{padding:4px 7px}
.diag-card{
  margin-top:10px;padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)
}
.diag-head{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px}
.diag-head strong{font-size:12px;color:var(--text)}
.diag-summary{font-size:11px;color:var(--text2);line-height:1.5;margin-bottom:8px;overflow-wrap:anywhere;word-break:break-word}
.diag-list{display:flex;flex-direction:column;gap:6px}
.diag-item{
  border:1px solid var(--border);border-radius:6px;padding:7px 8px;background:var(--surface)
}
.diag-item.diag-pass{border-color:rgba(63,185,80,.45);background:rgba(63,185,80,.10)}
.diag-item.diag-warn{border-color:rgba(210,153,34,.45);background:rgba(210,153,34,.10)}
.diag-item.diag-fail{border-color:rgba(248,81,73,.5);background:rgba(248,81,73,.10)}
.diag-main{display:flex;align-items:flex-start;gap:6px;font-size:11px}
.diag-icon{width:14px;text-align:center;flex:0 0 14px}
.diag-title{font-weight:600;color:var(--text);overflow-wrap:anywhere;word-break:break-word}
.diag-detail{margin-top:3px;font-size:11px;color:var(--text2);line-height:1.4;overflow-wrap:anywhere;word-break:break-word}
.diag-hint{margin-top:3px;font-size:11px;color:var(--warning);line-height:1.4;overflow-wrap:anywhere;word-break:break-word}
.diag-actions{margin-top:8px;display:flex;flex-direction:column;gap:6px}
.diag-actions-title{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:.5px}
.diag-action{
  border:1px solid var(--border);border-radius:6px;padding:7px 8px;background:var(--surface)
}
.diag-action.diag-action-required{border-color:rgba(248,81,73,.45);background:rgba(248,81,73,.09)}
.diag-action.diag-action-recommended{border-color:rgba(88,166,255,.45);background:rgba(88,166,255,.09)}
.diag-action-head{display:flex;gap:6px;align-items:flex-start;font-size:11px;color:var(--text)}
.diag-action-rank{font-weight:700;color:var(--text2);min-width:16px}
.diag-action-title{font-weight:600;color:var(--text)}
.diag-action-detail{margin-top:4px;font-size:11px;color:var(--text2);line-height:1.4;overflow-wrap:anywhere;word-break:break-word}
.diag-action-command{
  margin-top:4px;font-size:11px;color:var(--accent2);font-family:var(--mono);line-height:1.35;
  overflow-wrap:anywhere;word-break:break-word
}
.diag-action-controls{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap}
.diag-action-controls .btn{padding:4px 8px;font-size:11px}
.diag-action-run-state{margin-top:4px;font-size:11px;color:var(--text2);line-height:1.35}
.diag-action-run-state.ok{color:var(--success)}
.diag-action-run-state.fail{color:var(--danger)}

/* -- Step List -------------------------------------------------- */
.step-list{display:flex;flex-direction:column;gap:4px;min-height:40px}
.step-item{
  display:flex;align-items:center;gap:8px;padding:8px 10px;
  background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);
  cursor:pointer;transition:all .15s;user-select:none}
.step-item:hover{background:var(--surface2)}
.step-item.selected{border-color:var(--accent);background:rgba(88,166,255,.08)}
.step-item.duplicate-step{border-color:var(--danger);background:rgba(248,81,73,.10)}
.step-item.disabled-step{opacity:.45}
.step-item:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(110,199,255,.3)}
.step-num{font-size:12px;font-weight:700;color:var(--text2);width:18px;text-align:center}
.step-icon{font-size:16px;width:22px;text-align:center}
.step-name{flex:1;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.step-dup-mark{color:var(--danger);font-size:12px;font-weight:700;min-width:28px;text-align:center}
.step-actions{display:flex;gap:2px}
.step-actions button{padding:2px 5px;border:none;background:transparent;color:var(--text2);cursor:pointer;border-radius:3px;font-size:12px;line-height:1}
.step-actions button:hover{background:var(--border);color:var(--text)}

.btn-add{width:100%;border-style:dashed;color:var(--accent);margin-top:4px}
.btn-add:hover{background:rgba(88,166,255,.08)}
.step-collision-alert{
  display:none;margin-top:8px;padding:10px;border:1px solid rgba(248,81,73,.55);
  background:rgba(248,81,73,.12);border-radius:var(--radius);font-size:12px;color:#ffd6d3
}
.step-collision-alert code{
  font-family:var(--mono);font-size:11px;color:#ffd6d3;background:rgba(0,0,0,.25);padding:1px 4px;border-radius:4px
}

/* -- Step Details ----------------------------------------------- */
.step-details{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:14px}
.step-details .detail-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.step-details .detail-title{font-size:14px;font-weight:600}
.step-name-warning{
  margin-bottom:10px;padding:8px 10px;border:1px solid rgba(248,81,73,.55);
  background:rgba(248,81,73,.12);border-radius:var(--radius);font-size:12px;color:#ffd6d3;line-height:1.45
}
.radio-group{display:flex;gap:14px;padding:4px 0}
.radio-group label{display:flex;align-items:center;gap:4px;font-size:13px;color:var(--text);cursor:pointer}
.prompt-preview{position:relative}
.prompt-preview textarea{min-height:80px}
.prompt-preview .readonly-badge{position:absolute;top:6px;right:8px;font-size:10px;color:var(--text2);background:var(--surface2);padding:2px 6px;border-radius:3px}

/* -- Exec Controls ---------------------------------------------- */
.exec-controls{display:flex;gap:8px}
.exec-toggle{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:var(--text2);
  user-select:none;
  padding:0 2px;
}
.exec-toggle input[type="checkbox"]{margin-right:0}

/* -- Progress --------------------------------------------------- */
.progress-section{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:14px}
.progress-info{display:flex;justify-content:space-between;margin-bottom:8px;font-size:13px}
.progress-bar{height:8px;background:var(--bg);border-radius:4px;overflow:hidden}
.progress-fill{height:100%;border-radius:4px;background:linear-gradient(90deg,var(--accent),var(--purple));transition:width .4s ease;width:0}
.progress-fill.running{animation:progressPulse 1.8s ease-in-out infinite}
@keyframes progressPulse{
  0%{filter:saturate(95%) brightness(94%)}
  50%{filter:saturate(130%) brightness(108%)}
  100%{filter:saturate(95%) brightness(94%)}
}
.activity-heartbeat{margin-top:8px;font-size:11px;color:var(--text2);min-height:1.2em}
.progress-last-log{
  margin-top:6px;font-size:11px;color:var(--text2);
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis
}
.stop-guidance{
  margin-top:10px;padding:10px;border-radius:var(--radius);border:1px solid var(--border);
  background:var(--bg);display:flex;flex-direction:column;gap:6px
}
.stop-guidance.hidden{display:none}
.stop-guidance-title{font-size:12px;font-weight:700;color:var(--text)}
.stop-guidance-summary{font-size:12px;color:var(--text2);line-height:1.45}
.stop-guidance-steps{
  margin:0;padding-left:18px;font-size:12px;color:var(--text2);display:flex;flex-direction:column;gap:4px
}
.stop-guidance-warn{border-color:rgba(210,153,34,.45);background:rgba(210,153,34,.1)}
.stop-guidance-error{border-color:rgba(248,81,73,.45);background:rgba(248,81,73,.1)}
.stop-guidance-info{border-color:rgba(88,166,255,.35);background:rgba(88,166,255,.08)}

/* -- Log Viewer ------------------------------------------------- */
.log-section{margin-bottom:4px}
.log-viewer{
  min-height:180px;height:32vh;max-height:75vh;overflow:auto;resize:vertical;
  background:linear-gradient(180deg, rgba(10,16,26,.94), rgba(7,11,17,.88));
  border:1px solid var(--border);border-radius:var(--radius);
  padding:11px 12px;font-family:var(--mono);font-size:12px;line-height:1.7}
.log-toolbar{display:flex;justify-content:space-between;align-items:center;margin:6px 0 8px 0}
.log-toolbar label{margin:0;font-size:11px;color:var(--text2);display:flex;align-items:center;gap:6px}
.pipe-logs-wrap{margin-bottom:4px}
.pipe-logs-wrap .log-viewer{margin-bottom:12px}
.pipe-logs-wrap .log-content{margin-bottom:4px}
.pipe-logs-head-row{display:flex;align-items:flex-start;gap:20px;flex-wrap:wrap;margin-bottom:8px}
.pipe-logs-head-row .pipe-logs-live{min-width:200px}
.pipe-logs-head-row .pipe-logs-files{flex:1;min-width:0}
.pipe-logs-head-row .pipe-logs-files .log-tabs{margin-bottom:0}
.log-tabs{display:flex;gap:2px;margin-bottom:8px;flex-wrap:wrap}
.log-empty{color:var(--text2);font-style:normal;line-height:1.45}
.log-entry{display:flex;gap:8px;align-items:flex-start;padding:2px 0;border-bottom:1px dashed rgba(139,148,158,.2)}
.log-entry:last-child{border-bottom:none}
.log-entry .log-time{color:var(--text2);white-space:nowrap;flex:0 0 72px}
.log-entry .log-msg{flex:1;min-width:0;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word}
.log-info{color:var(--text)}
.log-warn{color:var(--warning)}
.log-error{color:var(--danger)}

.state-card{
  border:1px dashed rgba(160,190,228,.42);
  border-radius:var(--radius);
  background:linear-gradient(180deg, rgba(15,22,34,.9), rgba(10,16,26,.84));
  color:var(--text2);
  font-size:12px;
  line-height:1.5;
  padding:12px 13px;
}
.state-card strong{color:var(--text)}
.state-card.loading{
  position:relative;
  padding-left:38px;
}
.state-card.loading::before{
  content:'';
  position:absolute;
  left:12px;
  top:50%;
  width:14px;
  height:14px;
  margin-top:-7px;
  border-radius:50%;
  border:2px solid rgba(161,180,205,.46);
  border-top-color:var(--accent2);
  animation:spin .8s linear infinite;
}
.state-card.error{
  border-color:rgba(255,111,111,.58);
  background:linear-gradient(180deg, rgba(255,111,111,.14), rgba(78,27,27,.34));
  color:#ffe0e0;
}
.state-card.warning{
  border-color:rgba(223,170,88,.58);
  background:linear-gradient(180deg, rgba(223,170,88,.15), rgba(74,55,22,.36));
  color:#ffedcc;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* -- Results Table ---------------------------------------------- */
.results-section{margin-top:4px}
.results-wrap{
  overflow:auto;min-height:180px;height:28vh;max-height:70vh;resize:vertical;
  border:1px solid var(--border);border-radius:var(--radius);
  background:linear-gradient(180deg, rgba(10,16,26,.78), rgba(7,11,17,.9))
}
.results-table{width:100%;border-collapse:collapse;font-size:13px}
.results-table th{position:sticky;top:0;background:var(--surface);padding:8px 10px;text-align:left;font-weight:600;color:var(--text2);border-bottom:1px solid var(--border);font-size:12px;text-transform:uppercase;letter-spacing:.3px;z-index:1}
.results-table td{padding:7px 10px;border-bottom:1px solid var(--border)}
.results-table tr:last-child td{border-bottom:none}
.results-table tr:hover td{background:var(--surface2)}
.results-table td .state-card{margin:4px 0}
.results-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.results-head-actions{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.results-head .field-help{margin-top:2px}
.run-compare-summary{font-size:12px;color:var(--text2);margin-top:6px}
.run-compare-run-label{display:flex;flex-direction:column;gap:4px}
.run-compare-badges{display:flex;flex-wrap:wrap;gap:4px}
.run-compare-badge{
  display:inline-block;
  padding:2px 6px;
  border-radius:10px;
  font-size:10px;
  border:1px solid var(--border-soft);
  color:var(--text2);
  background:rgba(160,190,228,.08);
  text-transform:uppercase;
  letter-spacing:.3px;
}
.run-compare-badge.best-overall{
  border-color:rgba(71,192,123,.45);
  color:var(--success);
  background:rgba(71,192,123,.12);
}
.file-changes-cell{min-width:230px;max-width:420px}
.file-changes-empty{color:var(--text2);font-size:12px}
.file-changes-details{display:block}
.file-changes-summary{cursor:pointer;color:var(--accent2);font-size:12px;list-style:none;user-select:none}
.file-changes-summary::-webkit-details-marker{display:none}
.file-changes-summary::before{content:"\25b8";display:inline-block;width:12px;color:var(--text2)}
.file-changes-details[open] .file-changes-summary::before{content:"\25be"}
.file-changes-list{
  margin-top:6px;padding:4px 0;max-height:170px;overflow:auto;
  border:1px solid var(--border);border-radius:6px;background:var(--bg)
}
.file-changes-row{
  display:grid;grid-template-columns:minmax(0,1fr) auto auto;gap:8px;align-items:center;
  padding:4px 8px;font-family:var(--mono);font-size:11px
}
.file-changes-row + .file-changes-row{border-top:1px dashed rgba(139,148,158,.25)}
.file-changes-path{min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--text)}
.file-changes-plus{color:var(--success);text-align:right}
.file-changes-minus{color:var(--danger);text-align:right}
.file-changes-binary{color:var(--text2);text-align:right}
.badge{display:inline-block;padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600}
.badge-pass{background:rgba(63,185,80,.15);color:var(--success)}
.badge-fail{background:rgba(248,81,73,.15);color:var(--danger)}
.badge-error{background:rgba(210,153,34,.15);color:var(--warning)}
.badge-skip{background:rgba(139,148,158,.15);color:var(--text2)}

/* -- Toast / Notification --------------------------------------- */
#toast-stack{
  position:fixed;right:20px;bottom:20px;z-index:3000;
  display:flex;flex-direction:column;align-items:flex-end;gap:8px;
  pointer-events:none;max-width:min(460px, calc(100vw - 24px))
}
.toast{
  position:relative;
  display:flex;
  align-items:flex-start;
  gap:10px;
  padding:11px 11px 11px 13px;
  border-radius:var(--radius);
  font-size:13px;
  color:#fff;
  animation:slideUp .3s ease;
  pointer-events:auto;
  max-width:100%;
  border:1px solid rgba(255,255,255,.2);
  box-shadow:0 12px 34px rgba(0,0,0,.45);
  word-break:break-word
}
.toast.toast-exit{animation:toastFade .2s ease forwards}
.toast-success{background:linear-gradient(180deg,#228958,#1a6842)}
.toast-error{background:linear-gradient(180deg,#b83f3f,#8f2d2d)}
.toast-info{background:linear-gradient(180deg,#2f6f98,#245573)}
.toast-body{flex:1;line-height:1.45}
.toast-close{
  border:1px solid rgba(255,255,255,.35);
  border-radius:8px;
  background:rgba(0,0,0,.2);
  color:#fff;
  font-size:14px;
  line-height:1;
  padding:3px 7px;
  cursor:pointer;
}
.toast-close:hover{background:rgba(0,0,0,.35)}
@keyframes slideUp{from{transform:translateY(20px);opacity:0}to{transform:translateY(0);opacity:1}}
@keyframes toastFade{from{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(8px)}}

.visually-hidden{
  position:absolute !important;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  overflow:hidden;
  clip:rect(0,0,0,0);
  white-space:nowrap;
  border:0;
}

/* -- Difficulty mode visibility ---------------------------------- */
.easy-only{display:none}
.medium-only{display:none}
.expert-only{display:none}
body.mode-easy .easy-only{display:block}
body.mode-easy .easy-hide{display:none !important}
body.mode-medium .medium-only{display:block}
body.mode-medium .medium-hide{display:none !important}
body.mode-expert .expert-only{display:block}
body.mode-expert .expert-hide{display:none !important}
body.mode-expert .easy-only{display:none}
body.mode-expert .medium-only{display:none}
body.mode-medium .easy-only{display:none}

/* -- Recipe cards (Easy mode) ------------------------------------ */
.recipe-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:10px 0}
.recipe-card{padding:14px;background:var(--surface);border:2px solid var(--border);border-radius:var(--radius);cursor:pointer;transition:all .15s;text-align:left}
.recipe-card:hover{border-color:var(--accent);background:var(--surface2)}
.recipe-card.selected{border-color:var(--accent);background:rgba(88,166,255,.12)}
.recipe-card:focus-visible{
  outline:none;
  border-color:var(--accent2);
  box-shadow:0 0 0 3px rgba(110,199,255,.25);
}
.recipe-card .recipe-title{font-weight:600;font-size:13px;margin-bottom:4px;color:var(--text)}
.recipe-card .recipe-desc{font-size:11px;color:var(--text2);line-height:1.4}

/* -- Onboarding overlay ----------------------------------------- */
#onboarding-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:2000;display:flex;align-items:center;justify-content:center;padding:24px}
#onboarding-overlay.hidden{display:none}
.onboarding-card{max-width:520px;width:100%;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:28px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.onboarding-card h2{margin-bottom:12px;font-size:20px;color:var(--text)}
.onboarding-card p{color:var(--text2);font-size:14px;line-height:1.6;margin-bottom:12px}
.onboarding-card .mode-row{display:flex;align-items:flex-start;gap:10px;margin:14px 0;padding:10px;background:var(--bg);border-radius:var(--radius)}
.onboarding-card .mode-row strong{color:var(--accent);font-size:13px;min-width:80px}
.onboarding-card .mode-row span{font-size:12px;color:var(--text2);line-height:1.5}
.onboarding-actions{display:flex;gap:8px;margin-top:16px;flex-wrap:wrap}
.onboarding-actions .btn{flex:1 1 190px;padding:11px;font-size:13px}

#first-run-wizard-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:2100;display:flex;align-items:center;justify-content:center;padding:24px}
#first-run-wizard-overlay.hidden{display:none}
.first-run-wizard-card{max-width:880px;width:100%;max-height:86vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:20px;box-shadow:0 20px 60px rgba(0,0,0,.5);display:flex;flex-direction:column;gap:12px}
.first-run-wizard-card h2{margin-bottom:4px;font-size:20px;color:var(--text)}
.first-run-wizard-subtitle{font-size:13px;color:var(--text2);line-height:1.5}
.first-run-wizard-steps{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px}
.first-run-wizard-step{border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);padding:8px 9px;font-size:12px;color:var(--text2);line-height:1.45}
.first-run-wizard-step strong{display:block;color:var(--text);margin-bottom:2px;font-size:12px}
.first-run-wizard-repo-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.first-run-wizard-repo-row input{flex:1 1 320px}
.first-run-wizard-status{font-size:12px;color:var(--text2);min-height:1.2em}
.first-run-wizard-status[data-tone="ok"]{color:var(--success)}
.first-run-wizard-status[data-tone="warn"]{color:var(--warning)}
.first-run-wizard-status[data-tone="error"]{color:var(--danger)}
.first-run-wizard-diag-summary{font-size:13px;color:var(--text2)}
.first-run-wizard-grid{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:10px}
.first-run-wizard-panel{border:1px solid var(--border);border-radius:var(--radius);background:rgba(15,22,34,.72);padding:10px;min-height:170px;overflow:auto}
.first-run-wizard-panel h3{margin-bottom:8px;font-size:12px;text-transform:uppercase;letter-spacing:.25px;color:var(--text3)}
.first-run-wizard-empty{font-size:12px;color:var(--text3)}
.first-run-wizard-check{border:1px solid var(--border);border-radius:8px;background:rgba(7,11,17,.72);padding:7px 8px;font-size:12px;line-height:1.45;margin-bottom:7px}
.first-run-wizard-check.pass{border-color:rgba(71,192,123,.45)}
.first-run-wizard-check.warn{border-color:rgba(223,170,88,.45)}
.first-run-wizard-check.fail{border-color:rgba(255,111,111,.45)}
.first-run-wizard-check:last-child{margin-bottom:0}
.first-run-wizard-check-title{font-weight:600;color:var(--text);display:flex;gap:6px;align-items:center}
.first-run-wizard-check-detail{color:var(--text2);margin-top:3px}
.first-run-wizard-check-hint{color:var(--warning);margin-top:2px}
.first-run-wizard-action{border:1px solid var(--border);border-radius:8px;background:rgba(7,11,17,.72);padding:8px 9px;font-size:12px;line-height:1.45;margin-bottom:7px}
.first-run-wizard-action:last-child{margin-bottom:0}
.first-run-wizard-action-title{font-weight:600;color:var(--text)}
.first-run-wizard-action-command{margin-top:4px;color:var(--text2);font-family:var(--mono);word-break:break-word}
.first-run-wizard-action-controls{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap}
.first-run-wizard-action-controls .btn{padding:5px 10px;font-size:12px}
.first-run-wizard-footer{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap;padding-top:6px;border-top:1px solid var(--border)}
.first-run-wizard-footer .btn{padding:9px 12px}

/* -- New Project modal ------------------------------------------- */
#new-project-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:2000;display:flex;align-items:center;justify-content:center;padding:24px}
#new-project-overlay.hidden{display:none}
.new-project-card{max-width:520px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:28px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.new-project-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.new-project-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:16px}
.new-project-card .form-row{margin-bottom:12px}
.new-project-card label{font-size:12px;color:var(--text2);display:block;margin-bottom:4px}
.new-project-card .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:20px}
.new-project-card .toggle-row{display:flex;gap:16px;margin:8px 0}
.new-project-card .toggle-row label{display:flex;align-items:center;gap:4px;font-size:13px;color:var(--text);cursor:pointer;margin-bottom:0}
.new-project-card details{margin-top:8px;border:1px solid var(--border);border-radius:var(--radius);padding:10px}
.new-project-card details summary{cursor:pointer;font-size:12px;color:var(--text2);font-weight:600}
.new-project-card details .form-row{margin-top:10px}
.new-project-card .creation-result{margin-top:12px;padding:10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);font-size:12px;color:var(--success);display:none}

/* Clone Repo modal */
#clone-repo-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:2050;display:flex;align-items:center;justify-content:center;padding:24px}
#clone-repo-overlay.hidden{display:none}
.clone-repo-card{max-width:540px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:24px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.clone-repo-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.clone-repo-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:14px}
.clone-repo-card .form-row{margin-bottom:12px}
.clone-repo-card .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}
.clone-repo-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.clone-repo-card .row-with-button{display:flex;gap:8px;align-items:center}
.clone-repo-card .row-with-button input,.clone-repo-card .row-with-button select{flex:1}
.clone-repo-card .row-with-button .btn{white-space:nowrap}
.clone-repo-card .meta{margin-top:8px;padding:8px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);font-size:12px;color:var(--text2);line-height:1.5}

#git-remote-overlay{position:fixed;inset:0;background:rgba(0,0,0,.84);z-index:2220;display:flex;align-items:center;justify-content:center;padding:24px}
#git-remote-overlay.hidden{display:none}
.git-remote-card{max-width:880px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.git-remote-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.git-remote-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:12px}
.git-remote-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.git-remote-card .status[data-tone="ok"]{color:var(--success)}
.git-remote-card .status[data-tone="warn"]{color:var(--warning)}
.git-remote-card .status[data-tone="error"]{color:var(--danger)}
.git-remote-card .actions{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;margin-top:14px}
.git-remote-meta{display:grid;grid-template-columns:minmax(0,1fr) minmax(320px,360px);gap:12px;margin-bottom:12px}
.git-remote-card-block{border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);padding:10px}
.git-remote-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
.git-remote-list{border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;background:var(--bg)}
.git-remote-table{width:100%;border-collapse:collapse;font-size:12px}
.git-remote-table th,.git-remote-table td{padding:8px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:top}
.git-remote-table thead th{position:sticky;top:0;background:var(--surface2);z-index:1;font-size:11px;color:var(--text2);letter-spacing:.2px;text-transform:uppercase}
.git-remote-table tbody tr:last-child td{border-bottom:none}
.git-remote-table td.name{font-family:var(--mono)}
.git-remote-url{display:block;font-family:var(--mono);word-break:break-all;line-height:1.45}
.git-remote-url + .git-remote-url{margin-top:4px}
.git-remote-actions{display:flex;gap:6px;flex-wrap:wrap}
.git-remote-badge{font-size:10px;padding:2px 7px;border-radius:999px;border:1px solid var(--border);color:var(--text2);background:rgba(19,29,43,.7);display:inline-block;margin-right:5px}
.git-remote-badge.default{color:var(--success);border-color:rgba(71,192,123,.45);background:rgba(71,192,123,.12)}
.git-remote-badge.tracking{color:var(--accent2);border-color:rgba(110,199,255,.45);background:rgba(110,199,255,.12)}
.git-remote-add{margin-top:12px;padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)}
.git-remote-add-grid{display:grid;grid-template-columns:minmax(130px,170px) minmax(0,1fr) auto;gap:8px;align-items:end}
.git-remote-add-grid .btn{white-space:nowrap}
.git-remote-add-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
.git-remote-add-row label{display:inline-flex;align-items:center;gap:4px;font-size:12px;color:var(--text2)}

#git-signing-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);z-index:2230;display:flex;align-items:center;justify-content:center;padding:24px}
#git-signing-overlay.hidden{display:none}
.git-signing-card{max-width:860px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.git-signing-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.git-signing-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:12px}
.git-signing-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.git-signing-card .status[data-tone="ok"]{color:var(--success)}
.git-signing-card .status[data-tone="warn"]{color:var(--warning)}
.git-signing-card .status[data-tone="error"]{color:var(--danger)}
.git-signing-card .actions{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;margin-top:14px}
.git-signing-meta{display:grid;grid-template-columns:minmax(0,1fr) minmax(320px,360px);gap:12px;margin-bottom:12px}
.git-signing-card-block{border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);padding:10px}
.git-signing-form-grid{display:grid;grid-template-columns:minmax(180px,220px) minmax(0,1fr);gap:8px 12px;align-items:end}
.git-signing-form-grid .form-row{margin-bottom:0}
.git-signing-options{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
.git-signing-options label{display:inline-flex;align-items:center;gap:5px;font-size:12px;color:var(--text2)}
.git-signing-checks{margin-top:12px;border:1px solid var(--border);border-radius:var(--radius);padding:10px;background:var(--bg);display:grid;gap:8px}
.git-signing-check{border:1px solid var(--border);border-radius:var(--radius);padding:8px;background:rgba(18,25,35,.55)}
.git-signing-check-title{display:flex;align-items:center;gap:7px;font-size:12px;font-weight:600;color:var(--text)}
.git-signing-check-detail{font-size:12px;color:var(--text2);line-height:1.45;margin-top:4px}
.git-signing-badge{font-size:10px;border-radius:999px;padding:2px 7px;border:1px solid var(--border)}
.git-signing-badge.ok{color:var(--success);border-color:rgba(71,192,123,.45);background:rgba(71,192,123,.12)}
.git-signing-badge.fail{color:var(--danger);border-color:rgba(232,106,106,.45);background:rgba(232,106,106,.12)}

/* GitHub auth modal */
#github-auth-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);z-index:2200;display:flex;align-items:center;justify-content:center;padding:24px}
#github-auth-overlay.hidden{display:none}
.github-auth-card{max-width:620px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.github-auth-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.github-auth-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:14px}
.github-auth-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.github-auth-card .actions{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;margin-top:14px}
.github-auth-card details{margin-top:8px;border:1px solid var(--border);border-radius:var(--radius);padding:10px}
.github-auth-card details summary{cursor:pointer;font-size:12px;color:var(--text2);font-weight:600}
.github-auth-card .meta{margin-top:8px;padding:8px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);font-size:12px;color:var(--text2);line-height:1.5}
.github-auth-troubleshooting{margin-top:10px;padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)}
.github-auth-troubleshooting.hidden{display:none}
.github-auth-troubleshooting h3{font-size:13px;margin-bottom:6px}
.github-auth-troubleshooting .summary{font-size:12px;color:var(--text2);line-height:1.45;margin-bottom:8px}
.github-auth-troubleshooting ul{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:8px}
.github-auth-troubleshooting li{border:1px solid var(--border);border-radius:var(--radius);padding:8px;background:rgba(18,25,35,.55)}
.github-auth-troubleshooting .check-title{display:flex;align-items:center;gap:7px;font-size:12px;font-weight:600;color:var(--text)}
.github-auth-troubleshooting .check-detail{font-size:12px;color:var(--text2);line-height:1.45;margin-top:4px}
.github-auth-troubleshooting .commands{margin-top:5px;font-size:11px;color:var(--text2);line-height:1.4}
.github-auth-troubleshooting .commands code{display:block;margin-top:4px}
.github-auth-troubleshooting .status-badge{font-size:10px;border-radius:999px;padding:2px 7px;border:1px solid var(--border)}
.github-auth-troubleshooting .status-ok{color:var(--success);border-color:rgba(71,192,123,.45);background:rgba(71,192,123,.12)}
.github-auth-troubleshooting .status-action_required{color:var(--danger);border-color:rgba(232,106,106,.45);background:rgba(232,106,106,.12)}
.github-auth-troubleshooting .status-review{color:var(--warning);border-color:rgba(223,170,88,.45);background:rgba(223,170,88,.12)}
.github-auth-troubleshooting .next-steps{margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
.github-auth-troubleshooting .next-steps strong{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:.2px}
.github-auth-troubleshooting .next-steps ol{margin:6px 0 0 18px;padding:0;color:var(--text2);font-size:12px;line-height:1.4}

#api-keys-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);z-index:2200;display:flex;align-items:center;justify-content:center;padding:24px}
#api-keys-overlay.hidden{display:none}
.api-keys-card{max-width:760px;width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.api-keys-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.api-keys-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:14px}
.api-keys-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.api-keys-card .meta{margin-top:8px;padding:8px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);font-size:12px;color:var(--text2);line-height:1.5;white-space:pre-wrap;word-break:break-word}
.api-keys-card .fields{margin-top:10px;display:grid;gap:10px}
.api-keys-card .field{border:1px solid var(--border);border-radius:var(--radius);padding:10px;background:rgba(18,25,35,.55)}
.api-keys-card .field label{margin-bottom:6px}
.api-keys-card .actions{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;margin-top:14px}

#about-overlay{position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:2300;display:flex;align-items:center;justify-content:center;padding:24px}
#about-overlay.hidden{display:none}
.about-card{width:980px;max-width:100%;max-height:88vh;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);display:flex;flex-direction:column;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.about-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:flex-start;justify-content:space-between;gap:12px}
.about-header h3{font-size:16px;color:var(--text);margin:0}
.about-subtitle{font-size:12px;color:var(--text2);margin-top:4px}
.about-body{padding:12px 16px;display:flex;flex-direction:column;gap:10px;overflow:auto}
.about-meta{padding:8px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);font-size:12px;color:var(--text2);line-height:1.5;white-space:pre-wrap;word-break:break-word}
.about-doc-links{display:flex;gap:6px;flex-wrap:wrap}
.about-doc-links .btn{padding:4px 9px;font-size:11px}
.about-readme{padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);font-family:var(--mono);font-size:12px;line-height:1.55;white-space:pre-wrap;word-break:break-word;overflow:auto}

#git-commit-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);z-index:2250;display:flex;align-items:center;justify-content:center;padding:24px}
#git-commit-overlay.hidden{display:none}
.git-commit-card{width:900px;max-width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.git-commit-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.git-commit-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:12px}
.git-commit-card .status{font-size:12px;color:var(--text2);margin-top:8px;min-height:1.2em}
.git-commit-card .status[data-tone="ok"]{color:var(--success)}
.git-commit-card .status[data-tone="warn"]{color:var(--warning)}
.git-commit-card .status[data-tone="error"]{color:var(--danger)}
.git-commit-card .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}
.git-commit-meta{display:grid;grid-template-columns:minmax(0,1fr) minmax(320px,360px);gap:12px;margin-bottom:12px}
.git-commit-card-block{border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);padding:10px}
.git-commit-card-block h3{margin-bottom:6px}
.git-commit-last-commit{font-size:12px;color:var(--text2);line-height:1.5;white-space:pre-wrap;word-break:break-word}
.git-commit-file-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
.git-commit-file-toolbar .summary{font-size:12px;color:var(--text2)}
.git-commit-file-list{border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;background:var(--bg)}
.git-commit-file-table{width:100%;border-collapse:collapse;font-size:12px}
.git-commit-file-table th,.git-commit-file-table td{padding:8px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:top}
.git-commit-file-table thead th{position:sticky;top:0;background:var(--surface2);z-index:1;font-size:11px;color:var(--text2);letter-spacing:.2px;text-transform:uppercase}
.git-commit-file-table tbody tr:last-child td{border-bottom:none}
.git-commit-file-table td.path{font-family:var(--mono);word-break:break-all}
.git-commit-file-actions{display:flex;gap:6px;flex-wrap:wrap}
.git-commit-state-badges{display:flex;gap:5px;flex-wrap:wrap}
.git-commit-state-badge{font-size:10px;padding:2px 7px;border-radius:999px;border:1px solid var(--border);color:var(--text2);background:rgba(19,29,43,.7)}
.git-commit-state-badge.staged{color:var(--success);border-color:rgba(71,192,123,.45);background:rgba(71,192,123,.12)}
.git-commit-state-badge.unstaged{color:var(--warning);border-color:rgba(223,170,88,.45);background:rgba(223,170,88,.12)}
.git-commit-state-badge.untracked{color:var(--accent2);border-color:rgba(110,199,255,.45);background:rgba(110,199,255,.12)}
.git-commit-message{margin-top:12px}
.git-commit-message textarea{min-height:100px}

#todo-wishlist-overlay,#feature-dreams-overlay,#general-request-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);z-index:2200;display:flex;align-items:center;justify-content:center;padding:24px}
#todo-wishlist-overlay.hidden,#feature-dreams-overlay.hidden,#general-request-overlay.hidden{display:none}
.todo-wishlist-card,.feature-dreams-card,.general-request-card{width:760px;max-width:100%;max-height:88vh;overflow-y:auto;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.todo-wishlist-card h2,.feature-dreams-card h2,.general-request-card h2{margin-bottom:4px;font-size:18px;color:var(--text)}
.todo-wishlist-card .subtitle,.feature-dreams-card .subtitle,.general-request-card .subtitle{color:var(--text2);font-size:13px;margin-bottom:14px}
.todo-wishlist-card .actions,.feature-dreams-card .actions,.general-request-card .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}
.todo-wishlist-card .status,.feature-dreams-card .status,.general-request-card .status{font-size:12px;color:var(--text2);margin-top:6px;min-height:1.2em}
.todo-wishlist-card .inline-actions,.feature-dreams-card .inline-actions,.general-request-card .inline-actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.context-file-list{margin-top:8px;font-size:11px;color:var(--text2)}
.general-request-history{margin-top:10px;display:grid;gap:10px}
.general-request-history-item{border:1px solid var(--border);border-radius:var(--radius);padding:10px;background:var(--bg)}
.general-request-history-item h4{font-size:12px;margin:0 0 6px 0;color:var(--text)}
.general-request-history-item .meta{font-size:11px;color:var(--text2);margin-bottom:6px}
.general-request-history-item pre{white-space:pre-wrap;word-break:break-word;background:var(--surface2);border:1px solid var(--border);padding:8px;border-radius:8px;max-height:200px;overflow:auto}

/* -- Help tooltip ------------------------------------------------ */
.help-icon{display:inline-block;width:14px;height:14px;line-height:14px;text-align:center;border-radius:50%;background:var(--border);color:var(--text2);font-size:10px;font-weight:700;cursor:help;margin-left:4px;vertical-align:middle}
.field-help{font-size:11px;color:var(--text2);line-height:1.5;margin-top:4px}
.perm-summary{font-size:11px;color:var(--text2);line-height:1.5;margin-top:6px;padding:8px 10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius)}
.perm-warning{font-size:11px;color:var(--warning);line-height:1.5;margin-top:6px;padding:8px 10px;background:rgba(210,153,34,.12);border:1px solid rgba(210,153,34,.4);border-radius:var(--radius)}
.perm-warning.hidden{display:none}
.perm-manual{margin-top:10px;border:1px solid var(--border);border-radius:var(--radius);padding:10px;background:var(--bg)}
.perm-manual summary{cursor:pointer;font-size:12px;color:var(--text2);font-weight:600}
.perm-manual .form-row{margin-top:8px}
.adv-block{margin-top:10px;padding:10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius)}
.adv-block h4{font-size:12px;color:var(--text2);text-transform:uppercase;letter-spacing:.3px;margin-bottom:8px}
.adv-block summary{cursor:pointer;font-size:12px;color:var(--text2);font-weight:600}

.cua-card{
  background:linear-gradient(135deg, rgba(15,22,34,.95), rgba(23,35,49,.92));
  border:1px solid var(--border-soft);
  border-radius:var(--radius);
  padding:10px;
}
.cua-toggle-label{margin-bottom:6px}
.cua-toggle-label input[type="checkbox"]{accent-color:var(--accent)}
.cua-toggle-label strong{color:var(--accent2)}
.cua-description{font-size:11px;color:var(--text2);margin:4px 0 0 22px}
.cua-options{display:none;margin-top:10px;padding-left:22px}
.cua-field{margin-bottom:6px}
.cua-input-sm{font-size:12px}
.cua-task-input{
  font-size:12px;resize:vertical;width:100%;background:var(--bg);
  border:1px solid var(--border);border-radius:var(--radius);padding:8px;color:var(--text)
}
.cua-run-row{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap}
.btn-cua{font-size:11px;padding:4px 10px}
.cua-status{font-size:11px;color:var(--text2);padding-top:5px}

/* -- Permissions Help Modal ------------------------------------- */
#permissions-help-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:2600;display:flex;align-items:center;justify-content:center;padding:24px}
#permissions-help-overlay.hidden{display:none}
.permissions-help-modal{width:680px;max-width:100%;max-height:75vh;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);display:flex;flex-direction:column;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.permissions-help-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:8px}
.permissions-help-body{padding:14px 16px;overflow-y:auto;display:flex;flex-direction:column;gap:10px}
.permissions-help-body h4{font-size:13px;color:var(--text2);text-transform:uppercase;letter-spacing:.3px}
.permissions-help-body p{font-size:12px;color:var(--text2);line-height:1.5}
.permissions-help-card{padding:10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)}

/* Read-Only Run Warning Modal */
#readonly-warning-overlay{position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:2800;display:flex;align-items:center;justify-content:center;padding:24px}
#readonly-warning-overlay.hidden{display:none}
.readonly-warning-modal{width:560px;max-width:100%;background:var(--surface);border:1px solid rgba(248,81,73,.5);border-radius:var(--radius);box-shadow:0 24px 72px rgba(0,0,0,.55);display:flex;flex-direction:column}
.readonly-warning-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px}
.readonly-warning-header h3{margin:0;font-size:15px;color:var(--danger)}
.readonly-warning-body{padding:14px 16px;display:flex;flex-direction:column;gap:10px}
.readonly-warning-body p{margin:0;font-size:13px;line-height:1.5;color:var(--text2)}
.readonly-warning-callout{padding:10px;border:1px solid rgba(248,81,73,.45);border-radius:var(--radius);background:rgba(248,81,73,.10);font-size:12px;color:#ffd7d5}
.readonly-warning-actions{padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}

#run-plan-overlay{position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:2900;display:flex;align-items:center;justify-content:center;padding:24px}
#run-plan-overlay.hidden{display:none}
.run-plan-modal{width:760px;max-width:100%;max-height:80vh;overflow:hidden;background:linear-gradient(165deg, rgba(22,27,34,.98), rgba(13,17,23,.98));border:1px solid var(--border);border-radius:14px;box-shadow:0 24px 72px rgba(0,0,0,.55);display:flex;flex-direction:column}
.run-plan-header{padding:16px 18px;border-bottom:1px solid var(--border);display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
.run-plan-header h3{margin:0;font-size:16px;color:var(--text)}
.run-plan-subtitle{font-size:12px;color:var(--text2);margin-top:4px;line-height:1.5}
.run-plan-model-chip{padding:6px 10px;border:1px solid rgba(88,166,255,.45);border-radius:999px;background:rgba(88,166,255,.12);color:var(--accent2);font-size:11px;white-space:nowrap}
.run-plan-body{padding:16px 18px;overflow-y:auto;display:flex;flex-direction:column;gap:14px}
.run-plan-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.run-plan-field{padding:12px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg)}
.run-plan-field label{font-size:12px;color:var(--text2);margin-bottom:6px}
.run-plan-summary{padding:12px;border:1px solid var(--border);border-radius:var(--radius);background:rgba(28,35,51,.55);display:flex;flex-direction:column;gap:8px}
.run-plan-summary-line{font-size:12px;color:var(--text2);line-height:1.5}
.run-plan-summary-line strong{color:var(--text)}
.run-plan-callout{padding:10px;border-radius:var(--radius);border:1px solid rgba(88,166,255,.35);background:rgba(88,166,255,.1);color:#d6ebff;font-size:12px;line-height:1.45}
.run-plan-callout.warn{border-color:rgba(210,153,34,.45);background:rgba(210,153,34,.12);color:#f3e5bf}
.run-plan-callout.danger{border-color:rgba(248,81,73,.45);background:rgba(248,81,73,.12);color:#ffd7d5}
.run-plan-danger{display:flex;align-items:flex-start;gap:8px;padding:10px;border:1px solid rgba(248,81,73,.45);border-radius:var(--radius);background:rgba(248,81,73,.1);font-size:12px;color:#ffd7d5}
.run-plan-danger.hidden{display:none}
.run-plan-actions{padding:12px 18px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap}

/* Scientist dashboard modal */
#science-dashboard-overlay{position:fixed;inset:0;background:rgba(0,0,0,.8);z-index:2950;display:flex;align-items:center;justify-content:center;padding:24px}
#science-dashboard-overlay.hidden{display:none}
.science-dashboard-modal{
  width:1120px;max-width:100%;max-height:84vh;overflow:hidden;
  background:linear-gradient(165deg, rgba(19,29,43,.98), rgba(7,11,17,.98));
  border:1px solid var(--border-soft);border-radius:14px;box-shadow:0 24px 72px rgba(0,0,0,.58);
  display:flex;flex-direction:column
}
.science-dashboard-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
.science-dashboard-header h3{margin:0;font-size:16px;color:var(--text)}
.science-dashboard-subtitle{font-size:12px;color:var(--text2);margin-top:4px;line-height:1.45}
.science-dashboard-actions{display:flex;gap:8px;flex-wrap:wrap}
.science-dashboard-body{padding:14px 16px;overflow:auto;display:flex;flex-direction:column;gap:14px}
.science-cards{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px}
.science-card{
  border:1px solid var(--border);border-radius:10px;padding:10px;background:rgba(19,29,43,.75);
  display:flex;flex-direction:column;gap:4px
}
.science-card-label{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:.3px}
.science-card-value{font-size:19px;font-weight:700;color:var(--text)}
.science-card-value.pass{color:var(--success)}
.science-card-value.fail{color:var(--danger)}
.science-card-value.warn{color:var(--warning)}
.science-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.science-panel{border:1px solid var(--border);border-radius:10px;background:var(--bg);padding:10px}
.science-panel h4{font-size:12px;color:var(--text2);margin-bottom:8px;text-transform:uppercase;letter-spacing:.3px}
.science-list{display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--text2)}
.science-list-item{display:flex;align-items:center;justify-content:space-between;gap:8px}
.science-list-item .name{color:var(--text);min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.science-list-item .count{font-family:var(--mono);color:var(--text2);font-size:11px}
.science-bars{display:flex;flex-direction:column;gap:8px}
.science-bar-row{display:grid;grid-template-columns:88px 1fr 44px;gap:8px;align-items:center}
.science-bar-label{font-size:11px;color:var(--text2);text-transform:capitalize}
.science-bar-track{height:10px;background:var(--surface2);border-radius:999px;overflow:hidden}
.science-bar-fill{height:100%;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent2))}
.science-bar-fill.pass{background:linear-gradient(90deg,#2ea66a,#61d995)}
.science-bar-fill.fail{background:linear-gradient(90deg,#d14a4a,#ff7c7c)}
.science-bar-fill.warn{background:linear-gradient(90deg,#be8a3b,#f4bd64)}
.science-bar-value{font-family:var(--mono);font-size:11px;color:var(--text2);text-align:right}
.science-table-wrap{max-height:240px;overflow:auto;border:1px solid var(--border);border-radius:8px}
.science-table{width:100%;border-collapse:collapse;font-size:12px}
.science-table th{position:sticky;top:0;background:var(--surface);padding:6px 8px;color:var(--text2);text-align:left;border-bottom:1px solid var(--border);font-size:11px;text-transform:uppercase;letter-spacing:.3px}
.science-table td{padding:6px 8px;border-bottom:1px solid var(--border)}
.science-table tr:last-child td{border-bottom:none}
.science-analysis{max-height:180px;overflow:auto;white-space:pre-wrap;word-break:break-word;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:10px;font-family:var(--mono);font-size:11px;color:var(--text2);line-height:1.5}
.science-empty{font-size:12px;color:var(--text2);padding:10px;border:1px dashed var(--border-soft);border-radius:8px;background:rgba(15,22,34,.65)}
.science-open-btn{margin-top:8px;display:flex;justify-content:flex-end}

/* -- Tab Navigation -------------------------------------------- */
.tab-nav{display:flex;gap:2px}
.tab-nav button{padding:7px 16px;border:none;background:transparent;color:var(--text2);cursor:pointer;font-size:13px;font-family:var(--font);font-weight:500;border-bottom:2px solid transparent;transition:all .15s}
.tab-nav button:hover{color:var(--text)}
.tab-nav button.active{color:var(--accent);border-bottom-color:var(--accent);font-weight:600}
.tab-nav button[aria-selected="true"]{color:var(--accent);border-bottom-color:var(--accent);font-weight:600}
.tab-content{display:none;min-height:0}
.tab-content.active{display:grid;min-height:0}

/* -- Pipeline Panel -------------------------------------------- */
#pipeline-view{grid-template-columns:minmax(360px,420px) minmax(0,1fr);flex:1;overflow:hidden;min-height:0}
.pipeline-panel{overflow-y:auto;padding:20px 22px}
#pipeline-config{border-right:1px solid var(--border-soft);display:flex;flex-direction:column;gap:16px;min-height:0}
#pipeline-exec > *{margin-bottom:16px}
#pipeline-exec > *:last-child{margin-bottom:0}
.resume-card{display:flex;flex-direction:column;gap:8px}
.resume-card.hidden{display:none}
.resume-card-title{font-size:13px;font-weight:700;color:var(--text)}
.resume-card-sub{font-size:12px;color:var(--text2);line-height:1.45}
.resume-card-meta{font-size:11px;color:var(--text3);line-height:1.4}
.resume-card-actions{display:flex;gap:8px;flex-wrap:wrap}
.phase-list{display:flex;flex-direction:column;gap:4px}
.phase-item{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);transition:all .15s;overflow:hidden}
.phase-item:hover{background:var(--surface2)}
.phase-item.disabled-phase{opacity:.45}
.phase-header{display:flex;align-items:center;gap:8px;padding:8px 10px;cursor:pointer;user-select:none}
.phase-header:hover{background:rgba(255,255,255,.03)}
.phase-header:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(110,199,255,.3)}
.phase-expand-arrow{font-size:10px;color:var(--text2);transition:transform .2s;width:14px;text-align:center}
.phase-item.expanded .phase-expand-arrow{transform:rotate(90deg)}
.phase-icon{font-size:15px;width:22px;text-align:center}
.phase-name{flex:1;font-size:13px}
.phase-iter{width:50px;text-align:center;font-size:12px;padding:4px;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text)}
.phase-details{display:none;padding:0 12px 12px 12px;border-top:1px solid var(--border);margin-top:0}
.phase-item.expanded .phase-details{display:block}
.phase-details .phase-desc{font-size:11px;color:var(--text2);margin:10px 0 8px 0;line-height:1.5}
.phase-details .phase-prompt-wrap{margin-top:8px}
.phase-details .phase-prompt-wrap label{font-size:12px;font-weight:600;color:var(--text);margin-bottom:4px;display:block}
.phase-details textarea.phase-prompt{width:100%;min-height:100px;max-height:300px;resize:vertical;font-size:11px;font-family:'Fira Code','Cascadia Code','JetBrains Mono',monospace;line-height:1.5;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:8px;color:var(--text);box-sizing:border-box}
.phase-details .phase-meta-row{display:flex;gap:12px;margin-top:10px;flex-wrap:wrap}
.phase-details .phase-meta-row .form-row{flex:1;min-width:120px}
.log-tabs button{padding:4px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text2);cursor:pointer;font-size:11px;font-family:var(--font);transition:all .15s}
.log-tabs button:hover{background:var(--surface2)}
.log-tabs button.active{background:var(--accent);color:#000;border-color:var(--accent);font-weight:600}
.log-content{background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:12px;font-family:var(--mono);font-size:12px;line-height:1.6;min-height:180px;height:28vh;max-height:70vh;resize:vertical;overflow-y:auto;overflow-x:auto;white-space:pre-wrap;word-break:break-word;overflow-wrap:anywhere;color:var(--text2);transition:border-color .15s, background .15s}
.log-content.is-loading{border-color:var(--border-soft);background:rgba(15,22,34,.78);color:var(--text3)}
.log-viewer{overflow-x:hidden}
.results-wrap{overflow-x:auto}

/* -- Browse Modal ----------------------------------------------- */
.browse-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:2000;display:flex;align-items:center;justify-content:center;padding:24px}
.browse-modal-overlay.hidden{display:none}
.browse-modal{width:520px;max-width:100%;max-height:70vh;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);display:flex;flex-direction:column;box-shadow:0 20px 60px rgba(0,0,0,.5)}
.browse-modal-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px}
.browse-modal-header h3{font-size:14px;font-weight:600;color:var(--text);flex:1;margin:0}
.browse-path-bar{padding:8px 16px;border-bottom:1px solid var(--border);font-size:12px;font-family:var(--mono);color:var(--text2);word-break:break-all;background:var(--bg)}
.browse-list{flex:1;overflow-y:auto;padding:4px 0}
.browse-item{display:flex;align-items:center;gap:10px;padding:8px 16px;cursor:pointer;font-size:13px;color:var(--text);transition:background .1s;border:none;background:none;width:100%;text-align:left;font-family:var(--font)}
.browse-item:hover{background:var(--surface2)}
.browse-item-icon{font-size:16px;width:22px;text-align:center;flex-shrink:0}
.browse-item-name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.browse-item-git{font-size:10px;padding:2px 6px;border-radius:8px;background:rgba(63,185,80,.15);color:var(--success);font-weight:600;flex-shrink:0}
.browse-empty{padding:24px 16px;text-align:center;color:var(--text2);font-size:13px;font-style:normal}
.browse-drives{display:flex;gap:6px;flex-wrap:wrap;padding:8px 16px;border-bottom:1px solid var(--border)}
.browse-drives button{padding:4px 10px;border:1px solid var(--border);border-radius:var(--radius);background:var(--bg);color:var(--text);cursor:pointer;font-size:12px;font-family:var(--mono);transition:all .1s}
.browse-drives button:hover{background:var(--surface2);border-color:var(--accent)}
.browse-modal-footer{padding:12px 16px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}

/* Modal polish */
#onboarding-overlay,
#first-run-wizard-overlay,
#new-project-overlay,
#clone-repo-overlay,
#git-remote-overlay,
#git-signing-overlay,
#git-commit-overlay,
#api-keys-overlay,
#github-auth-overlay,
#todo-wishlist-overlay,
#feature-dreams-overlay,
#general-request-overlay,
#about-overlay,
#browse-overlay,
#docs-overlay,
#permissions-help-overlay,
#run-plan-overlay,
#readonly-warning-overlay,
#science-dashboard-overlay{
  backdrop-filter:blur(3px);
}
.onboarding-card,
.first-run-wizard-card,
.new-project-card,
.clone-repo-card,
.git-remote-card,
.git-signing-card,
.git-commit-card,
.api-keys-card,
.github-auth-card,
.todo-wishlist-card,
.feature-dreams-card,
.general-request-card,
.about-card,
.browse-modal,
.docs-modal,
.permissions-help-modal,
.run-plan-modal,
.readonly-warning-modal,
.science-dashboard-modal{
  animation:modalIn .22s ease;
}
@keyframes modalIn{
  from{opacity:0;transform:translateY(8px) scale(.985)}
  to{opacity:1;transform:translateY(0) scale(1)}
}

/* -- Responsive ------------------------------------------------- */
@media(max-width:1280px){
  header{padding:10px 14px}
  .header-brand{width:100%}
  .header-actions{width:100%;justify-content:flex-start}
  .git-sync-controls{width:min(940px, calc(100vw - 28px))}
  .header-doc-links{order:2}
}
@media(max-width:980px){
  html,body{overflow:auto;height:auto;min-height:100%}
  body{min-height:100dvh}
  header{position:relative}
  main,#pipeline-view{grid-template-columns:1fr;grid-template-rows:auto auto;overflow:visible}
  #chain-panel,#pipeline-config{border-right:none;border-bottom:1px solid var(--border-soft);max-height:none}
  #exec-panel,#pipeline-exec{overflow:visible}
  .panel,.pipeline-panel{padding:14px}
  .recipe-grid{grid-template-columns:1fr}
  .run-plan-grid{grid-template-columns:1fr}
  .exec-controls{flex-wrap:wrap}
  .header-actions{align-items:stretch;gap:7px}
  .header-actions > .btn,
  .header-actions > select{flex:1 1 170px;max-width:none}
  .header-actions > .btn.btn-primary{flex:1 1 220px}
  .header-doc-links{width:100%;flex-wrap:wrap}
  .header-workspace-links{width:100%}
  .header-workspace-links .btn{flex:1 1 180px}
  .tab-nav{width:100%;justify-content:flex-start}
  .mode-toggle{min-width:220px;max-width:460px}
  .git-sync-drawer{width:100%}
  .git-sync-controls{
    position:static;
    width:100%;
    max-height:none;
    margin-top:6px;
  }
  .science-cards{grid-template-columns:repeat(2,minmax(0,1fr))}
  .science-grid{grid-template-columns:1fr}
  .git-commit-meta{grid-template-columns:1fr}
  .git-remote-meta{grid-template-columns:1fr}
  .git-signing-meta{grid-template-columns:1fr}
  .git-signing-form-grid{grid-template-columns:1fr}
  .git-remote-add-grid{grid-template-columns:1fr}
  .workspace-repo-toolbar{align-items:stretch}
  .first-run-wizard-steps{grid-template-columns:repeat(2,minmax(0,1fr))}
  .first-run-wizard-grid{grid-template-columns:1fr}
}
@media(max-width:640px){
  .header-actions > .btn,
  .header-actions > select,
  .header-doc-links .btn{flex:1 1 100%}
  .mode-toggle{width:100%;max-width:none}
  .mode-toggle button{padding:9px 8px;font-size:12px}
  .repo-row{flex-wrap:wrap;align-items:stretch}
  .repo-row .btn{flex:1 1 130px}
  .repo-status{order:3;width:auto}
  .header-actions select{min-width:100px}
  .git-sync-widget{width:100%;max-width:100%;min-width:0}
  .git-sync-widget-grid{grid-template-columns:1fr}
  .workspace-repo-actions{flex-direction:column;align-items:stretch}
  .workspace-repo-actions select{min-width:0;max-width:none;width:100%}
  #toast-stack{right:12px;bottom:12px}
  .docs-modal,.browse-modal,.permissions-help-modal,.run-plan-modal,.readonly-warning-modal,.science-dashboard-modal,.first-run-wizard-card,.api-keys-card,.about-card,.git-signing-card{max-height:88vh}
  .science-cards{grid-template-columns:1fr}
  .science-bar-row{grid-template-columns:72px 1fr 38px}
  .first-run-wizard-steps{grid-template-columns:1fr}
}
@media (prefers-reduced-motion: reduce){
  *,*::before,*::after{
    animation-duration:0.01ms !important;
    animation-iteration-count:1 !important;
    transition-duration:0.01ms !important;
    scroll-behavior:auto !important;
  }
}
</style>
</head>

<body>
<div id="sr-announcer" class="visually-hidden" aria-live="assertive" aria-atomic="true"></div>
<!--  -->
<!-- HEADER                                                        -->
<!--  -->
<header>
  <div class="header-brand">
    <div class="logo"><span>&#9889;</span> {{ project_display_name }}</div>
    <div class="header-doc-links">
      <button class="btn" onclick="openDoc('quickstart')" title="Open quick start guide">Quickstart</button>
      <button class="btn" onclick="openDoc('output_artifacts')" title="Open outputs and artifacts guide">Outputs</button>
      <button class="btn" onclick="openDoc('troubleshooting')" title="Open troubleshooting guide">Troubleshooting</button>
      <button class="btn" onclick="openDoc('cli_reference')" title="Open CLI reference">CLI Reference</button>
      <button class="btn" onclick="showApiKeysModal()" title="Configure API keys for supported providers">API Keys</button>
      <button class="btn" onclick="showAboutModal()" title="View project details and README">About</button>
    </div>
    <div class="tab-nav" id="main-tabs" role="tablist" aria-label="Primary views">
      <button id="tab-chain" class="active" data-tab="chain" role="tab" tabindex="0" aria-selected="true" aria-controls="chain-view" onclick="switchTab('chain')">Chain Builder</button>
      <button id="tab-pipeline" data-tab="pipeline" role="tab" tabindex="-1" aria-selected="false" aria-controls="pipeline-view" onclick="switchTab('pipeline')">Pipeline</button>
    </div>
    <div class="header-workspace-links">
      <button type="button" class="btn" onclick="showTodoWishlistModal()">To-Do / Wishlist</button>
      <button type="button" class="btn" onclick="showFeatureDreamsModal()">Feature Dreams</button>
      <button type="button" class="btn" onclick="showGeneralRequestModal()">General Request</button>
      <button type="button" class="btn btn-success" onclick="startTodoWishlistAutopilot()">Implement To-Do</button>
    </div>
  </div>
  <div class="header-actions">
    <div class="mode-toggle" id="difficulty-mode-toggle">
      <button type="button" data-mode="easy" onclick="applyMode('easy')" title="Autopilot: pick a recipe and go">Autopilot</button>
      <button type="button" data-mode="medium" onclick="applyMode('medium')" title="Customize: build and tweak steps">Customize</button>
      <button type="button" data-mode="expert" onclick="applyMode('expert')" title="Expert: full control">Expert</button>
    </div>
    <div class="git-sync-drawer" id="git-sync-drawer">
      <button
        class="btn git-sync-drawer-toggle"
        id="git-sync-drawer-toggle"
        type="button"
        onclick="toggleGitSyncDrawer()"
        aria-expanded="false"
        aria-controls="git-sync-controls"
        title="Show or hide Git sync controls"
      >Git Sync</button>
      <div class="git-sync-controls" id="git-sync-controls" hidden>
      <button class="btn" id="git-sync-fetch-btn" type="button" onclick="gitSyncFetch()">Fetch</button>
      <button class="btn" id="git-sync-pull-btn" type="button" onclick="gitSyncPull()">Pull</button>
      <button class="btn btn-success" id="git-sync-push-btn" type="button" onclick="gitSyncPush()">Push</button>
      <button class="btn" id="git-sync-commit-panel-btn" type="button" onclick="showGitCommitModal()">Commit</button>
      <button class="btn" id="git-sync-remotes-btn" type="button" onclick="showGitRemoteModal()">Remotes</button>
      <button class="btn" id="git-sync-signing-btn" type="button" onclick="showGitSigningModal()">Signing</button>
      <button
        class="btn"
        id="git-sync-open-pr-btn"
        type="button"
        onclick="gitSyncOpenPullRequest()"
        title="Push a branch to generate a GitHub pull request URL."
        disabled
      >Open PR</button>
      <button
        class="btn"
        id="git-sync-copy-pr-btn"
        type="button"
        onclick="gitSyncCopyPullRequestUrl()"
        title="Push a branch to generate a GitHub pull request URL."
        disabled
      >Copy PR URL</button>
      <label class="git-sync-option" for="git-sync-set-upstream" title="When enabled, Push runs with --set-upstream for the current branch.">
        <input id="git-sync-set-upstream" type="checkbox">
        set upstream
      </label>
      <button class="btn btn-warning" id="git-sync-stash-pull-btn" type="button" onclick="gitSyncStashAndPull()">Stash + Pull</button>
      <select
        id="git-sync-branch-select"
        class="git-sync-branch-select"
        title="Switch branches (local + remote)"
        onchange="_syncGitSyncButtonState()"
      >
        <option value="">Switch branch...</option>
      </select>
      <button class="btn" id="git-sync-branch-refresh-btn" type="button" onclick="refreshGitSyncBranchesNow()">Branches</button>
      <button class="btn" id="git-sync-branch-switch-btn" type="button" onclick="gitSyncSwitchBranch()">Switch</button>
      <input
        type="text"
        id="git-sync-branch-create-name"
        class="git-sync-branch-input"
        placeholder="new/branch"
        title="Create and checkout a new branch"
        oninput="_syncGitSyncButtonState()"
      >
      <button class="btn" id="git-sync-branch-create-btn" type="button" onclick="gitSyncCreateBranch()">Create Branch</button>
      <label class="git-sync-option" for="git-sync-allow-dirty-switch" title="Allow branch switch/create even when local changes are present.">
        <input id="git-sync-allow-dirty-switch" type="checkbox">
        allow dirty switch
      </label>
      <div class="git-sync-widget" id="git-sync-widget" data-tone="muted" title="Select a repository path to view sync status">
        <div class="git-sync-widget-head">
          <span class="git-sync-widget-title">Sync Status</span>
          <div class="git-sync-widget-actions">
            <button class="btn" id="git-sync-open-repo-btn" type="button" onclick="gitSyncOpenRepoPage()" title="GitHub repository page is available when the selected remote points to github.com." disabled>Open Repo</button>
            <button class="btn" id="git-sync-refresh-btn" type="button" onclick="refreshGitSyncStatusNow()">Refresh</button>
          </div>
        </div>
        <div class="git-sync-widget-grid">
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Branch</span><span class="git-sync-widget-value" id="git-sync-widget-branch">n/a</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Remote</span><span class="git-sync-widget-value" id="git-sync-widget-remote">none</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Ahead/Behind</span><span class="git-sync-widget-value" id="git-sync-widget-ahead-behind">n/a</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Last Fetch</span><span class="git-sync-widget-value" id="git-sync-widget-last-fetch">never</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">GitHub</span><span class="git-sync-widget-value" id="git-sync-widget-github-name">n/a</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Visibility</span><span class="git-sync-widget-value" id="git-sync-widget-github-visibility">n/a</span></span>
          <span class="git-sync-widget-item"><span class="git-sync-widget-key">Default Branch</span><span class="git-sync-widget-value" id="git-sync-widget-github-default-branch">n/a</span></span>
        </div>
        <span class="git-sync-indicator" id="git-sync-indicator" data-tone="muted" title="Select a repository path to view sync status">No repo selected</span>
      </div>
      </div>
    </div>
    <button class="btn" type="button" onclick="showGithubAuthModal()">GitHub Auth</button>
    <button class="btn" type="button" onclick="showCloneRepoModal()">Clone Repo</button>
    <button class="btn btn-primary" onclick="showNewProjectModal()" style="white-space:nowrap">+ New Project</button>
    <select id="config-select" title="Saved configs">
      <option value="">Load config...</option>
    </select>
    <button class="btn" onclick="saveConfig()">Save</button>
    <button class="btn" onclick="loadConfigList()">Refresh</button>
    <button class="btn btn-danger" onclick="clearEverything()" title="Reset all settings and runtime UI to defaults">Clear Everything</button>
  </div>
</header>
<div id="backend-status-banner" class="state-card error" style="display:none;margin:8px 18px 0 18px">
  Backend connection lost. Waiting to reconnect.
</div>
<div id="watchdog-alert-banner" class="state-card warning" style="display:none;margin:8px 18px 0 18px">
  <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap">
    <strong>Model Watchdog Alerts</strong>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button class="btn btn-success" type="button" id="watchdog-apply-migrations-btn" style="display:none" onclick="applyWatchdogMigrationsFromBanner()">Apply migration suggestions</button>
      <button class="btn btn-warning" type="button" onclick="runWatchdogNowFromBanner()">Run now</button>
      <button class="btn" type="button" onclick="openDoc('model_watchdog')">Guide</button>
      <button class="btn" type="button" onclick="muteWatchdogAlerts(1)">Mute 1h</button>
    </div>
  </div>
  <div id="watchdog-alert-content" style="margin-top:8px;white-space:pre-wrap"></div>
</div>

<!--  -->
<!-- MAIN LAYOUT                                                   -->
<!--  -->
<main class="tab-content active" id="chain-view" role="tabpanel" aria-labelledby="tab-chain">

<!-- -- LEFT PANEL: Chain Builder -------------------------------- -->
<aside class="panel" id="chain-panel">

  <h2>Task Chain</h2>

  <!-- Repository -->
  <div class="config-section">
    <div class="form-row">
      <label>Repository Path</label>
      <div class="repo-row">
        <input type="text" id="repo-path" placeholder="C:\path\to\your\repo" oninput="validateRepo()" title="Full path to your git repository">
        <button class="btn" onclick="openBrowse('repo-path')" title="Browse for folder">Browse</button>
        <span class="repo-status" id="repo-status" aria-live="polite"></span>
      </div>
      <div class="workspace-repo-card">
        <div class="workspace-repo-head">
          <strong>Multi-Repo Workspace</strong>
          <button class="btn" type="button" id="workspace-repo-refresh-btn" onclick="refreshWorkspaceReposNow()">Refresh</button>
        </div>
        <div class="workspace-repo-toolbar">
          <input type="text" id="workspace-repo-path" placeholder="Add local git repo path" oninput="_syncWorkspaceControls()">
          <button class="btn" type="button" onclick="openBrowse('workspace-repo-path')" title="Browse for folder">Browse</button>
          <button class="btn btn-success" type="button" id="workspace-repo-add-btn" onclick="addWorkspaceRepoFromInput()">Add Repo</button>
        </div>
        <div class="workspace-repo-list">
          <table class="workspace-repo-table">
            <thead>
              <tr>
                <th>Repository</th>
                <th>Branch / Sync</th>
                <th>Remote Settings</th>
                <th>Recent Runs</th>
                <th>Quick Actions</th>
              </tr>
            </thead>
            <tbody id="workspace-repo-body">
              <tr><td colspan="5" style="color:var(--text2)">No workspace repos added yet.</td></tr>
            </tbody>
          </table>
        </div>
        <div class="workspace-repo-status" id="workspace-repo-status" data-tone="muted">Use Add Repo to start tracking multiple repositories.</div>
      </div>
    </div>
    <div class="diag-card">
      <div class="diag-head">
        <strong>Setup Diagnostics</strong>
        <button class="btn" onclick="refreshDiagnostics('chain')">Run</button>
      </div>
      <div class="diag-summary" id="diag-summary-chain">Run diagnostics to check repo, binaries, and auth setup.</div>
      <div class="diag-list" id="diag-list-chain">
        <div class="diag-item"><div class="diag-detail">No diagnostics run yet.</div></div>
      </div>
      <div class="diag-actions" id="diag-actions-chain"></div>
    </div>
    <div class="form-row easy-hide">
      <label>Mode <span class="help-icon easy-hide" title="Dry Run: preview changes only. Apply: commit and push.">?</span></label>
      <div class="mode-toggle" id="mode-toggle" title="Dry Run: preview only. Apply: commit and push.">
        <button class="active" data-mode="dry-run" onclick="setMode('dry-run')">&#128269; Dry Run</button>
        <button data-mode="apply" onclick="setMode('apply')">&#128295; Apply</button>
      </div>
    </div>
    <div class="form-row">
      <label><input type="checkbox" id="chain-git-preflight-enabled" onchange="toggleChainGitPreflight()"> Pre-flight before run (git checks)</label>
      <div class="field-help">Checks clean/stash state, branch tracking, and remote reachability before starting.</div>
    </div>
    <div id="chain-git-preflight-options" class="option-subpanel hidden">
      <div class="form-row">
        <label><input type="checkbox" id="chain-git-preflight-auto-stash" onchange="syncChainGitPreflightOptions()"> Auto-stash dirty changes before run</label>
      </div>
      <div class="form-row">
        <label><input type="checkbox" id="chain-git-preflight-auto-pull" onchange="syncChainGitPreflightOptions()"> Auto-pull latest commits (`git pull --ff-only`)</label>
      </div>
    </div>
  </div>

  <!-- Recipe Picker (Easy mode only) -->
  <div class="config-section easy-only" id="recipe-section">
    <h3>Choose a Recipe</h3>
    <p style="font-size:12px;color:var(--text2);margin-bottom:10px">One-click preset chains. Pick one, set your repo above, then Start.</p>
    <div class="recipe-grid" id="recipe-grid">
      <div class="recipe-card" data-recipe="autopilot_default" onclick="selectRecipe('autopilot_default')" title="Easy Improvements -> New Features -> GUI/UX Polish -> Code Quality -> Bug Hunt -> Performance -> Open Ended">
        <div class="recipe-title">Autopilot Default</div>
        <div class="recipe-desc">7-step full sweep with scripted prompts and commits</div>
      </div>
      <div class="recipe-card" data-recipe="strategic" onclick="selectRecipe('strategic')" title="Strategic Product Maximization x2 -> Implementation x2 -> Testing x1 -> Bug Hunting x1">
        <div class="recipe-title">Strategic Product Max</div>
        <div class="recipe-desc">Highest leverage product wins with validation</div>
      </div>
      <div class="recipe-card" data-recipe="improve" onclick="selectRecipe('improve')" title="Feature Discovery x2 -> Implementation x2 -> Testing x1 -> Bug Hunting x1 -> Refactoring x1">
        <div class="recipe-title">Improve Everything</div>
        <div class="recipe-desc">Discovery, implementation, testing, bug hunting, refactoring</div>
      </div>
      <div class="recipe-card" data-recipe="fix" onclick="selectRecipe('fix')" title="Bug Hunting x3 -> Testing x2 -> Refactoring x1">
        <div class="recipe-title">Fix and Stabilize</div>
        <div class="recipe-desc">Bug hunting, testing, refactoring</div>
      </div>
      <div class="recipe-card" data-recipe="polish" onclick="selectRecipe('polish')" title="Refactoring x2 -> Performance x1 -> Documentation x2 -> Security Audit x1">
        <div class="recipe-title">Polish and Document</div>
        <div class="recipe-desc">Refactor, performance, docs, security audit</div>
      </div>
      <div class="recipe-card" data-recipe="test" onclick="selectRecipe('test')" title="Testing x3 -> Bug Hunting x2 -> Testing x2">
        <div class="recipe-title">Test Coverage</div>
        <div class="recipe-desc">Testing and bug hunting focus</div>
      </div>
      <div class="recipe-card" data-recipe="todo_wishlist_autopilot" onclick="selectRecipe('todo_wishlist_autopilot')" title="Create To-Do/Wishlist -> Implement open items until done">
        <div class="recipe-title">To-Do/Wishlist Autopilot</div>
        <div class="recipe-desc">Create backlog then implement items until completed</div>
      </div>
      <div class="recipe-card" data-recipe="feature_dream_autopilot" onclick="selectRecipe('feature_dream_autopilot')" title="Dream Up Feature List -> Implement features until done">
        <div class="recipe-title">Feature Dream Autopilot</div>
        <div class="recipe-desc">Dream up features and implement all open items</div>
      </div>
    </div>
  </div>

  <!-- Steps -->
  <div class="easy-hide">
    <h3>Steps <span id="step-count" style="color:var(--accent)">(0)</span><span class="help-icon easy-hide" title="Add, remove, reorder steps. Each step runs in sequence; use loop count to repeat.">?</span></h3>
    <div class="step-list" id="step-list"></div>
    <div class="step-collision-alert" id="step-collision-alert"></div>
    <button class="btn btn-add" onclick="addStep()">+ Add Step</button>
  </div>

  <!-- Step Details (shown when a step is selected) -->
  <div id="step-details-wrap" style="display:none" class="easy-hide">
    <div class="step-details" id="step-details"></div>
  </div>

  <!-- Stop Conditions -->
  <div class="config-section easy-hide">
    <h3>Stop Conditions <span class="help-icon easy-hide" title="When to stop the loop: max loops, max time, or unlimited until improvement is low.">?</span></h3>
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px;margin-bottom:12px">
      <label style="margin-bottom:6px"><input type="checkbox" id="unlimited" onchange="toggleUnlimited()"> <strong style="color:var(--accent)">Unlimited Mode</strong> - loop until diminishing returns</label>
      <div id="threshold-group" style="margin-top:8px;display:none" class="medium-hide">
        <label>Improvement Threshold (stop when below)</label>
        <div style="display:flex;align-items:center;gap:10px;margin-top:4px">
          <input type="range" id="threshold-slider" min="0.1" max="10" step="0.1" value="1.0" style="flex:1;accent-color:var(--accent)" oninput="document.getElementById('threshold-val').textContent=this.value+'%'">
          <span id="threshold-val" style="font-weight:600;color:var(--accent);min-width:44px;text-align:right">1.0%</span>
        </div>
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text2);margin-top:2px">
          <span>0.1% (aggressive)</span>
          <span>10% (conservative)</span>
        </div>
      </div>
    </div>
    <div class="form-row-inline">
      <div class="form-row">
        <label>Max Loops <span id="max-loops-note" style="color:var(--text2)"></span></label>
        <input type="number" id="max-loops" value="3" min="1" max="10000">
      </div>
      <div class="form-row">
        <label>Max Time (min) <span id="max-time-note" style="color:var(--text2)"></span></label>
        <input type="number" id="max-time" value="120" min="0">
      </div>
    </div>
    <div class="form-row medium-hide">
      <label>Token Budget <span id="max-tokens-note" style="color:var(--text2)"></span></label>
      <input type="number" id="max-tokens" value="2000000" min="0" step="100000">
    </div>
    <div class="form-row medium-hide">
      <label><input type="checkbox" id="strict-token-budget"> Enforce token budget immediately</label>
      <div class="field-help">Off (default): budget checked after each full loop. On: stop right after a step exceeds budget.</div>
    </div>
    <div class="form-row medium-hide" id="convergence-row">
      <label><input type="checkbox" id="stop-convergence" checked> Stop on convergence (4 low-impact steps) <span id="convergence-note" style="color:var(--text2)"></span></label>
    </div>
  </div>

  <!-- Parallel Execution -->
  <div class="config-section easy-hide medium-hide">
    <h3>Execution Mode <span style="font-size:10px;color:var(--text2);font-weight:400;margin-left:4px">Expert</span></h3>
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px">
      <label style="margin-bottom:6px"><input type="checkbox" id="parallel-exec" onchange="config.parallel_execution=this.checked"> <strong style="color:var(--accent)">Parallel Execution</strong> - run steps concurrently</label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        When enabled, all steps in a loop run at the same time. Assign different agents per step
        (e.g. Codex on implementation, Claude Code on testing) to maximise throughput.
      </p>
    </div>
  </div>

  <!-- Brain (AI Thinking Layer) -->
  <div class="config-section easy-hide">
    <h3>AI Brain</h3>
    <!-- Local Only Toggle -->
    <div class="form-row" style="background:linear-gradient(135deg, var(--bg), #1a2a1a);border:1px solid #2d5a2d;border-radius:var(--radius);padding:10px;margin-bottom:12px">
      <label style="margin-bottom:6px">
        <input type="checkbox" id="local-only" onchange="toggleLocalOnly()" style="accent-color:#4caf50">
        <strong style="color:#4caf50">Local Only</strong> - use only Ollama (no cloud APIs)
      </label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        All brain / optimizer / scientist calls go through your local Ollama server. No data leaves your machine. Free.
      </p>
      <div id="ollama-status" style="margin:6px 0 0 22px;font-size:11px;display:none">
        <span id="ollama-status-icon"></span>
        <span id="ollama-status-text" style="color:var(--text2)"></span>
      </div>
    </div>
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px;margin-bottom:12px">
      <label style="margin-bottom:6px"><input type="checkbox" id="brain-enabled" onchange="toggleBrain()"> <strong style="color:var(--purple)">Enable Brain (Experimental)</strong> - AI thinks before Codex acts</label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        Uses a separate AI model to plan prompts, evaluate results, handle errors, and escalate only when necessary.
      </p>
    </div>
    <div id="brain-options" style="display:none" class="medium-hide">
      <div class="form-row">
        <label>Brain Model <span style="font-size:10px;color:var(--text2);font-weight:400;margin-left:4px">Expert</span></label>
        <select id="brain-model" title="AI model used for planning and evaluating step results.">
          <optgroup label="OpenAI" class="cloud-model-group">
            <option value="gpt-5.2">GPT-5.2</option>
            <option value="gpt-4.1">GPT-4.1</option>
            <option value="gpt-4o">GPT-4o</option>
          </optgroup>
          <optgroup label="Anthropic" class="cloud-model-group">
            <option value="claude-opus-4-6">Claude Opus 4.6</option>
            <option value="claude-sonnet-4">Claude Sonnet 4</option>
          </optgroup>
          <optgroup label="Google" class="cloud-model-group">
            <option value="gemini-3-pro-preview">Gemini 3 Pro</option>
            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
          </optgroup>
          <optgroup label="xAI" class="cloud-model-group">
            <option value="grok-4-1-fast-reasoning">Grok 4.1 Fast</option>
          </optgroup>
          <optgroup label="Local (Free)" id="chain-ollama-models">
            <option value="ollama:gemma3:27b">Ollama - Gemma 3 27B</option>
          </optgroup>
        </select>
      </div>
      <div style="display:flex;gap:8px;margin-top:4px">
        <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--purple);padding:3px 8px;border-radius:12px">Plans prompts</span>
        <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--success);padding:3px 8px;border-radius:12px">Evaluates results</span>
        <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--warning);padding:3px 8px;border-radius:12px">Handles errors</span>
        <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--danger);padding:3px 8px;border-radius:12px">Escalates if stuck</span>
      </div>
    </div>
  </div>

  <!-- Advanced -->
  <details class="config-section easy-hide medium-hide">
    <summary style="cursor:pointer;font-size:13px;font-weight:600;color:var(--text2)" title="Validation command, permissions, and runtime overrides.">Advanced Settings <span style="font-size:10px;color:var(--text2);font-weight:400;margin-left:4px">Expert</span></summary>
    <div style="margin-top:10px">
      <p class="field-help">Most users only need the first two settings below. Everything else is optional tuning.</p>

      <div class="adv-block">
        <h4>Common Settings</h4>
        <div class="form-row">
          <label>Validation Command (optional) <span class="help-icon" title="Command to verify changes after each step. Leave empty to skip validation.">?</span></label>
          <input type="text" id="test-cmd" value="" placeholder="e.g. python -m pytest -q">
          <div class="field-help">Runs after each step to catch regressions early.</div>
        </div>
        <div class="form-row">
          <label>Permission Profile <span class="help-icon" title="Pick a preset. Most users should use Recommended.">?</span></label>
          <select id="codex-permission-profile" onchange="setPermissionProfile('chain', this.value)">
            <option value="safe">Recommended: Safe Repo Access</option>
            <option value="readonly">Read-Only Inspect</option>
            <option value="full_access">Trusted Repo Full Access</option>
            <option value="custom">Custom (manual settings)</option>
          </select>
          <div class="field-help">Start with Recommended. Use Custom only if you need to tune low-level controls.</div>
          <div id="codex-permission-summary" class="perm-summary"></div>
          <div id="codex-permission-warning" class="perm-warning hidden">
            Full access bypasses sandbox and approval checks. Use only with trusted local repositories.
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" onclick="openPermissionsHelpModal()">What do these settings mean?</button>
          </div>
        </div>
      </div>

      <div class="adv-block">
        <h4>Autonomy and Assets</h4>
        <div class="form-row">
          <label><input type="checkbox" id="chain-allow-path-creation"> Allow creating new files and directories</label>
        </div>
        <div class="form-row">
          <label>Dependency Install Permissions</label>
          <select id="chain-dependency-install-policy">
            <option value="project_only">Project environment only (recommended)</option>
            <option value="disallow">Disallow installs</option>
            <option value="allow_system">Allow project + system-wide installs</option>
          </select>
          <div class="field-help">Controls whether agents can install dependencies during a run.</div>
        </div>
        <div class="form-row">
          <label><input type="checkbox" id="chain-image-generation-enabled" onchange="toggleChainImageOptions()"> Enable image generation for graphics/icons/assets</label>
        </div>
        <div id="chain-image-options" style="display:none">
          <div class="form-row">
            <label>Image Provider</label>
            <select id="chain-image-provider" onchange="onChainImageProviderChanged()">
              <option value="openai">OpenAI</option>
              <option value="google">Google</option>
            </select>
          </div>
          <div class="form-row">
            <label>Image Model</label>
            <input type="text" id="chain-image-model" value="gpt-image-1" placeholder="gpt-image-1 or nano-banana">
          </div>
        </div>

        <div class="form-row" style="margin-top:8px">
          <label><input type="checkbox" id="chain-vector-memory-enabled" onchange="toggleChainVectorMemory()"> Enable per-repo vector memory (ChromaDB)</label>
          <div class="field-help">Stores high-signal step outcomes for long-term retrieval across chain and pipeline runs.</div>
        </div>
        <div id="chain-vector-memory-options" class="option-subpanel hidden">
          <div class="form-row">
            <label>Vector Backend</label>
            <select id="chain-vector-memory-backend">
              <option value="chroma">ChromaDB</option>
            </select>
          </div>
          <div class="form-row">
            <label>Collection Name <span style="color:var(--text2)">(optional)</span></label>
            <input type="text" id="chain-vector-memory-collection" placeholder="defaults to repo folder name">
          </div>
          <div class="form-row">
            <label>Memory Recall Top-K</label>
            <input type="number" id="chain-vector-memory-top-k" value="8" min="1" max="30">
          </div>
        </div>
      </div>

      <details class="adv-block">
        <summary>More Controls (optional)</summary>
        <div class="form-row" style="margin-top:8px">
          <label>
            <input type="checkbox" id="timeout-step-enabled" onchange="onChainTimeoutToggle()">
            Enforce Step Inactivity Timeout
            <span class="help-icon" title="When enabled, a step is stopped only after this many seconds with no stdout/stderr activity. Disable for unlimited runtime.">?</span>
          </label>
          <div class="field-help" id="timeout-step-note">Unlimited (no inactivity timeout).</div>
        </div>
        <div class="form-row">
          <label>Timeout Seconds</label>
          <input type="number" id="timeout-step" value="600" min="30" step="1" disabled>
        </div>

        <details class="perm-manual" id="codex-perm-manual">
          <summary>Manual Permission Controls</summary>
          <div class="form-row">
            <label>Filesystem Access Mode <span class="help-icon" title="workspace-write: read/write in repo only. read-only: inspect only. danger-full-access: broad local access.">?</span></label>
            <select id="codex-sandbox-mode" onchange="onPermissionControlChanged('chain')">
              <option value="workspace-write">workspace-write (recommended)</option>
              <option value="read-only">read-only</option>
              <option value="danger-full-access">danger-full-access</option>
            </select>
          </div>
          <div class="form-row">
            <label>Approval Prompt Mode <span class="help-icon" title="never: non-interactive runs. on-failure/on-request/untrusted: interactive approval prompts.">?</span></label>
            <select id="codex-approval-policy" onchange="onPermissionControlChanged('chain')">
              <option value="never">never (recommended for unattended runs)</option>
              <option value="on-failure">on-failure</option>
              <option value="on-request">on-request</option>
              <option value="untrusted">untrusted</option>
            </select>
          </div>
          <div class="form-row">
            <label>
              <input type="checkbox" id="codex-bypass-approvals" onchange="onPermissionControlChanged('chain')">
              Disable sandbox + approval prompts (trusted repo only)
            </label>
          </div>
        </details>

        <details class="perm-manual">
          <summary>CLI Command Overrides (rare)</summary>
          <div class="form-row">
            <label>Codex CLI Command <span class="help-icon" title="Path or command used to start Codex CLI.">?</span></label>
            <input type="text" id="codex-bin" value="codex">
          </div>
          <div class="form-row">
            <label>Codex Reasoning Effort <span class="help-icon" title="Controls how much reasoning Codex uses per task. Higher levels are usually slower and more expensive but can improve hard-problem quality.">?</span></label>
            <select id="codex-reasoning-effort" onchange="onPermissionControlChanged('chain')">
              <option value="xhigh">Extra High (recommended default)</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
              <option value="inherit">Inherit Codex CLI default</option>
            </select>
          </div>
          <div class="form-row">
            <label>Claude CLI Command <span class="help-icon" title="Path or command used to start Claude Code CLI.">?</span></label>
            <input type="text" id="claude-bin" value="claude">
          </div>
        </details>
      </details>
    </div>
  </details>

</aside>

<!-- -- RIGHT PANEL: Execution ----------------------------------- -->
<section class="panel" id="exec-panel">

  <div style="display:flex;justify-content:space-between;align-items:center">
    <h2>Execution</h2>
    <div class="exec-controls">
      <button class="btn btn-primary" id="btn-feature-dream-next" onclick="implementNextDreamedFeature()">Implement Next Dream</button>
      <button class="btn btn-success" id="btn-start" onclick="startChain()">&#9654; Start</button>
      <button class="btn btn-warning" id="btn-pause" onclick="pauseChain()" disabled>&#9208; Pause</button>
      <button class="btn btn-danger"  id="btn-stop"  onclick="stopChain()"  disabled>&#9209; Stop</button>
    </div>
  </div>
  <label class="exec-toggle" title="When enabled, the chain finishes the active step, then stops before starting the next one.">
    <input
      type="checkbox"
      id="stop-after-step"
      onchange="toggleStopAfterStep(this.checked)"
      disabled
    >
    Stop after current step finishes
  </label>

  <!-- Progress -->
  <div class="progress-section" id="progress-section">
    <div class="progress-info">
      <span id="progress-text">Ready</span>
      <span id="progress-tokens" style="color:var(--text2)">0 tokens</span>
    </div>
    <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    <div class="activity-heartbeat" id="activity-heartbeat">Activity: idle</div>
    <div class="progress-last-log" id="progress-last-log">Last log: none yet</div>
    <div class="stop-guidance hidden" id="chain-stop-guidance" aria-live="polite"></div>
  </div>

  <!-- Live Log -->
  <div class="log-section">
    <h3>Live Log</h3>
    <div class="log-toolbar">
      <label><input type="checkbox" id="show-debug-logs" onchange="toggleDebugLogs()"> Show debug messages</label>
    </div>
    <div class="log-viewer" id="log-viewer" aria-live="polite">
      <div class="log-empty state-card">Waiting to start...</div>
    </div>
  </div>

  <div class="chain-outputs-section">
    <h3>Step Outputs</h3>
    <div class="form-row-inline" style="margin-bottom:8px">
      <select id="chain-output-select" onchange="viewChainOutput()">
        <option value="">No output files yet</option>
      </select>
      <button class="btn" onclick="refreshChainOutputs(true)">Refresh</button>
    </div>
    <div id="chain-output-dir" style="font-size:11px;color:var(--text2);margin-bottom:6px;white-space:normal;overflow-wrap:anywhere;word-break:break-word;max-width:100%"></div>
    <div class="log-content" id="chain-output-content" aria-live="polite">Run a chain to generate step output files.</div>
  </div>

  <div class="chain-outputs-section">
    <h3>Repository Idea Generator</h3>
    <div class="form-row-inline" style="margin-bottom:8px">
      <input
        type="text"
        id="owner-ideas-model"
        value="gpt-5.2"
        placeholder="Model id (e.g. gpt-5.2, claude-opus-4-6, ollama:llama3.3)"
        title="Separate model used only for idea generation. This does not change chain/pipeline models."
        style="min-width:340px"
      >
      <button class="btn" onclick="generateOwnerIdeasFromRepo()">Generate ideas from repo</button>
      <button class="btn" onclick="loadOwnerIdeas()">Refresh</button>
    </div>
    <div class="form-row" style="margin-bottom:6px">
      <label style="font-size:11px;color:var(--text2)">Optional focus</label>
      <input type="text" id="owner-ideas-context" placeholder="Example: prioritize onboarding, admin controls roadmap, and monetization hooks.">
    </div>
    <div id="owner-board-warning" style="font-size:11px;color:var(--warning);margin-bottom:6px;white-space:pre-wrap"></div>
    <div class="log-content" id="owner-board-content" aria-live="polite">No ideas yet. Generate ideas from the repository.</div>
  </div>

  <!-- Results -->
  <div class="results-section">
    <h3>Results</h3>
    <div class="results-wrap">
      <table class="results-table">
        <thead>
          <tr>
            <th>Loop</th>
            <th>Step</th>
            <th>Agent</th>
            <th>Tests</th>
            <th>Files</th>
            <th>Changed Files</th>
            <th>Net &Delta;</th>
            <th>Time</th>
            <th>Commit</th>
          </tr>
        </thead>
        <tbody id="results-body">
          <tr><td colspan="9"><div class="state-card">No execution results yet. Run a chain to populate this table.</div></td></tr>
        </tbody>
      </table>
    </div>
  </div>

</section>
</main>

<!--  -->
<!-- PIPELINE VIEW                                                  -->
<!--  -->
<div class="tab-content" id="pipeline-view" role="tabpanel" aria-labelledby="tab-pipeline" hidden>

<!-- -- LEFT: Pipeline Config ------------------------------------ -->
<aside class="pipeline-panel" id="pipeline-config">

  <h2>Autonomous Pipeline</h2>

  <!-- Repository -->
  <div class="config-section">
    <div class="form-row">
      <label>Repository Path</label>
      <div class="repo-row">
        <input type="text" id="pipe-repo-path" placeholder="C:\path\to\your\repo" oninput="validatePipeRepo()">
        <button class="btn" onclick="openBrowse('pipe-repo-path')" title="Browse for folder">Browse</button>
        <span class="repo-status" id="pipe-repo-status" aria-live="polite"></span>
      </div>
    </div>
    <div class="diag-card">
      <div class="diag-head">
        <strong>Setup Diagnostics</strong>
        <button class="btn" onclick="refreshDiagnostics('pipeline')">Run</button>
      </div>
      <div class="diag-summary" id="diag-summary-pipeline">Run diagnostics to check repo, binaries, and auth setup.</div>
      <div class="diag-list" id="diag-list-pipeline">
        <div class="diag-item"><div class="diag-detail">No diagnostics run yet.</div></div>
      </div>
      <div class="diag-actions" id="diag-actions-pipeline"></div>
    </div>
    <div class="form-row">
      <label>Mode</label>
      <div class="mode-toggle" id="pipe-mode-toggle">
        <button class="active" data-mode="dry-run" onclick="setPipeMode('dry-run')">&#128269; Dry Run</button>
        <button data-mode="apply" onclick="setPipeMode('apply')">&#128295; Apply</button>
      </div>
    </div>
    <div class="form-row">
      <label><input type="checkbox" id="pipe-git-preflight-enabled" onchange="togglePipeGitPreflight()"> Pre-flight before run (git checks)</label>
      <div class="field-help">Checks clean/stash state, branch tracking, and remote reachability before starting.</div>
    </div>
    <div id="pipe-git-preflight-options" class="option-subpanel hidden">
      <div class="form-row">
        <label><input type="checkbox" id="pipe-git-preflight-auto-stash" onchange="syncPipeGitPreflightOptions()"> Auto-stash dirty changes before run</label>
      </div>
      <div class="form-row">
        <label><input type="checkbox" id="pipe-git-preflight-auto-pull" onchange="syncPipeGitPreflightOptions()"> Auto-pull latest commits (`git pull --ff-only`)</label>
      </div>
    </div>
    <div class="form-row">
      <label><input type="checkbox" id="pipe-pr-aware-enabled" onchange="togglePipePrAware()"> PR-aware execution mode</label>
      <div class="field-help">Run on a feature branch, auto-push commits, and keep a GitHub PR description synced with pipeline summary.</div>
    </div>
    <div id="pipe-pr-aware-options" class="option-subpanel hidden">
      <div class="form-row">
        <label>Feature Branch <span style="color:var(--text2)">(optional)</span></label>
        <input
          type="text"
          id="pipe-pr-feature-branch"
          placeholder="warpfoundry/pr/my-feature"
          oninput="syncPipePrAwareOptions()"
        >
      </div>
      <div class="form-row-inline">
        <div class="form-row">
          <label>Remote <span style="color:var(--text2)">(optional)</span></label>
          <input
            type="text"
            id="pipe-pr-remote"
            placeholder="origin"
            oninput="syncPipePrAwareOptions()"
          >
        </div>
        <div class="form-row">
          <label>Base Branch <span style="color:var(--text2)">(optional)</span></label>
          <input
            type="text"
            id="pipe-pr-base-branch"
            placeholder="main"
            oninput="syncPipePrAwareOptions()"
          >
        </div>
      </div>
      <div class="form-row">
        <label><input type="checkbox" id="pipe-pr-auto-push" onchange="syncPipePrAwareOptions()"> Auto-push commits to branch</label>
      </div>
      <div class="form-row">
        <label><input type="checkbox" id="pipe-pr-sync-description" onchange="syncPipePrAwareOptions()"> Sync PR description with run summary</label>
      </div>
    </div>
  </div>

  <!-- Phases -->
  <div class="config-section">
    <h3>Pipeline Phases</h3>
    <p style="font-size:11px;color:var(--text2);margin-bottom:10px">
      Each phase runs in order. Adjust iteration counts to control depth.
    </p>
    <div class="phase-list" id="phase-list"></div>
  </div>

  <!-- Science Mode -->
  <div class="config-section">
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px">
      <label style="margin-bottom:6px">
        <input type="checkbox" id="pipe-science" onchange="togglePipeScience()">
        <strong style="color:var(--purple)">Scientist Mode</strong> - theorize, experiment, skeptic, analyze
      </label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        Applies the scientific method before implementation: forms testable hypotheses,
        runs controlled experiments, requires skeptical replication, and generates
        an action plan used by subsequent coding phases.
      </p>
    </div>
  </div>

  <!-- CUA Visual Testing -->
  <div class="config-section">
    <div class="form-row cua-card">
      <label class="cua-toggle-label">
        <input type="checkbox" id="pipe-cua" onchange="togglePipeCUA()">
        <strong>&#128065; Computer-Use Agent</strong> - AI visually tests the UI
      </label>
      <p class="cua-description">
        An AI agent launches a browser, navigates your app, clicks buttons, fills forms,
        and reports visual bugs. Uses screenshot-based vision models (OpenAI CUA or Anthropic Claude).
      </p>
      <div id="pipe-cua-options" class="cua-options">
        <div class="form-row cua-field">
          <label style="font-size:12px">CUA Provider</label>
          <select id="pipe-cua-provider" class="cua-input-sm">
            <option value="openai">OpenAI CUA (computer-use-preview)</option>
            <option value="anthropic">Anthropic Claude (computer use tool)</option>
          </select>
        </div>
        <div class="form-row cua-field">
          <label style="font-size:12px">Target URL</label>
          <input type="text" id="pipe-cua-url" placeholder="http://localhost:5088" class="cua-input-sm">
        </div>
        <div class="form-row">
          <label style="font-size:12px">Task / Goal</label>
          <textarea id="pipe-cua-task" rows="2" placeholder="Navigate the app, test interactive elements, report visual issues..." class="cua-task-input"></textarea>
        </div>
        <div class="cua-run-row">
          <button class="btn btn-primary btn-cua" onclick="runStandaloneCUA()">&#9654; Run CUA Now</button>
          <span id="pipe-cua-status" class="cua-status"></span>
        </div>
      </div>
    </div>
  </div>

  <!-- Stop Conditions (consistent with Chain Builder) -->
  <div class="config-section">
    <h3>Stop Conditions</h3>
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px;margin-bottom:12px">
      <label style="margin-bottom:6px"><input type="checkbox" id="pipe-unlimited" onchange="togglePipeUnlimited()"> <strong style="color:var(--accent)">Unlimited Mode</strong> - loop until diminishing returns</label>
      <div id="pipe-threshold-group" style="margin-top:8px;display:none">
        <label>Improvement Threshold (stop when below)</label>
        <div style="display:flex;align-items:center;gap:10px;margin-top:4px">
          <input type="range" id="pipe-threshold-slider" min="0.1" max="10" step="0.1" value="1.0" style="flex:1;accent-color:var(--accent)" oninput="document.getElementById('pipe-threshold-val').textContent=this.value+'%'">
          <span id="pipe-threshold-val" style="font-weight:600;color:var(--accent);min-width:44px;text-align:right">1.0%</span>
        </div>
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text2);margin-top:2px">
          <span>0.1% (aggressive)</span>
          <span>10% (conservative)</span>
        </div>
      </div>
    </div>
    <div class="form-row-inline">
      <div class="form-row">
        <label>Max Cycles <span id="pipe-cycles-note" style="color:var(--text2)"></span></label>
        <input type="number" id="pipe-cycles" value="3" min="1" max="10000">
      </div>
      <div class="form-row">
        <label>Max Time (min) <span id="pipe-time-note" style="color:var(--text2)"></span></label>
        <input type="number" id="pipe-max-time" value="240" min="0">
      </div>
    </div>
    <div class="form-row">
      <label>Token Budget <span id="pipe-tokens-note" style="color:var(--text2)"></span></label>
      <input type="number" id="pipe-max-tokens" value="5000000" min="0" step="100000">
    </div>
    <div class="form-row">
      <label><input type="checkbox" id="pipe-strict-token-budget"> Enforce token budget immediately</label>
      <div class="field-help">Off (default): budget checked after each full cycle. On: stop right after a phase exceeds budget.</div>
    </div>
    <div class="form-row" id="pipe-convergence-row">
      <label><input type="checkbox" id="pipe-stop-convergence" checked> Stop on convergence (4 low-impact phases) <span id="pipe-convergence-note" style="color:var(--text2)"></span></label>
    </div>
  </div>

  <!-- Agent & Brain -->
  <div class="config-section">
    <h3>Agent &amp; Brain</h3>
    <div class="form-row">
      <label>Agent</label>
      <select id="pipe-agent">
        <option value="codex">Codex (OpenAI)</option>
        <option value="claude_code">Claude Code (Anthropic)</option>
      </select>
    </div>
    <!-- Local Only Toggle -->
    <div class="form-row" style="background:linear-gradient(135deg, var(--bg), #1a2a1a);border:1px solid #2d5a2d;border-radius:var(--radius);padding:10px;margin-top:8px">
      <label style="margin-bottom:6px">
        <input type="checkbox" id="pipe-local-only" onchange="togglePipeLocalOnly()" style="accent-color:#4caf50">
        <strong style="color:#4caf50">Local Only</strong> - use only Ollama (no cloud APIs)
      </label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        All brain / optimizer / scientist calls go through your local Ollama server. Free, private, offline.
      </p>
      <div id="pipe-ollama-status" style="margin:6px 0 0 22px;font-size:11px;display:none">
        <span id="pipe-ollama-status-icon"></span>
        <span id="pipe-ollama-status-text" style="color:var(--text2)"></span>
      </div>
    </div>
    <div class="form-row" style="background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px;margin-top:8px">
      <label style="margin-bottom:4px">
        <input type="checkbox" id="pipe-brain" onchange="togglePipeBrain()">
        <strong style="color:var(--purple)">Enable Brain (Experimental)</strong> - AI thinks before agents act
      </label>
      <p style="font-size:11px;color:var(--text2);margin:4px 0 0 22px">
        Uses a separate AI model to plan prompts, evaluate results, handle errors, and escalate only when necessary.
      </p>
      <div id="pipe-brain-options" style="display:none;margin-top:8px">
        <label>Brain Model</label>
        <select id="pipe-brain-model">
          <optgroup label="OpenAI" class="cloud-model-group">
            <option value="gpt-5.2">GPT-5.2</option>
            <option value="gpt-4.1">GPT-4.1</option>
          </optgroup>
          <optgroup label="Anthropic" class="cloud-model-group">
            <option value="claude-opus-4-6">Claude Opus 4.6</option>
            <option value="claude-sonnet-4">Claude Sonnet 4</option>
          </optgroup>
          <optgroup label="Google" class="cloud-model-group">
            <option value="gemini-3-pro-preview">Gemini 3 Pro</option>
          </optgroup>
          <optgroup label="xAI" class="cloud-model-group">
            <option value="grok-4-1-fast-reasoning">Grok 4.1 Fast</option>
          </optgroup>
          <optgroup label="Local (Free)" id="pipe-ollama-models">
            <option value="ollama:gemma3:27b">Ollama - Gemma 3 27B</option>
          </optgroup>
        </select>
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--purple);padding:3px 8px;border-radius:12px">Plans prompts</span>
          <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--success);padding:3px 8px;border-radius:12px">Evaluates results</span>
          <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--warning);padding:3px 8px;border-radius:12px">Handles errors</span>
          <span class="badge" style="font-size:10px;background:var(--surface2);color:var(--danger);padding:3px 8px;border-radius:12px">Escalates if stuck</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Git Settings -->
  <div class="config-section">
    <h3>Git Settings</h3>
    <div class="form-row">
      <label><input type="checkbox" id="pipe-auto-commit" checked> Auto-commit after implementation &amp; debugging phases</label>
    </div>
    <div class="form-row">
      <label>Commit Frequency</label>
      <select id="pipe-commit-freq">
        <option value="per_phase">Per Phase</option>
        <option value="per_cycle">Per Cycle</option>
        <option value="manual">Manual (commit phase only)</option>
      </select>
    </div>
  </div>

  <!-- Advanced Settings (consistent with Chain Builder) -->
  <details class="config-section">
    <summary style="cursor:pointer;font-size:13px;font-weight:600;color:var(--text2)">Advanced Settings</summary>
    <div style="margin-top:10px">
      <p class="field-help">Most users only need the first two settings below. Everything else is optional tuning.</p>

      <div class="adv-block">
        <h4>Common Settings</h4>
        <div class="form-row">
          <label>Validation Command (optional) <span class="help-icon" title="Command to verify changes after each phase. Leave empty to skip validation.">?</span></label>
          <input type="text" id="pipe-test-cmd" value="" placeholder="e.g. python -m pytest -q">
          <div class="field-help">Runs after each phase to catch regressions early.</div>
        </div>
        <div class="form-row">
          <label>Smoke Test Command (optional) <span class="help-icon" title="Used by phases set to the smoke test policy. Falls back to Validation Command when empty.">?</span></label>
          <input type="text" id="pipe-smoke-test-cmd" value="" placeholder="e.g. python -m pytest -q -m smoke">
          <div class="field-help">Quick test command for implementation/debugging phases configured as smoke.</div>
        </div>
        <div class="form-row">
          <label>Permission Profile <span class="help-icon" title="Pick a preset. Most users should use Recommended.">?</span></label>
          <select id="pipe-codex-permission-profile" onchange="setPermissionProfile('pipeline', this.value)">
            <option value="safe">Recommended: Safe Repo Access</option>
            <option value="readonly">Read-Only Inspect</option>
            <option value="full_access">Trusted Repo Full Access</option>
            <option value="custom">Custom (manual settings)</option>
          </select>
          <div class="field-help">Start with Recommended. Use Custom only if you need to tune low-level controls.</div>
          <div id="pipe-codex-permission-summary" class="perm-summary"></div>
          <div id="pipe-codex-permission-warning" class="perm-warning hidden">
            Full access bypasses sandbox and approval checks. Use only with trusted local repositories.
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" onclick="openPermissionsHelpModal()">What do these settings mean?</button>
          </div>
        </div>
      </div>

      <div class="adv-block">
        <h4>Autonomy and Assets</h4>
        <div class="form-row">
          <label><input type="checkbox" id="pipe-allow-path-creation"> Allow creating new files and directories</label>
        </div>
        <div class="form-row">
          <label>Dependency Install Permissions</label>
          <select id="pipe-dependency-install-policy">
            <option value="project_only">Project environment only (recommended)</option>
            <option value="disallow">Disallow installs</option>
            <option value="allow_system">Allow project + system-wide installs</option>
          </select>
          <div class="field-help">Controls whether agents can install dependencies during a run.</div>
        </div>
        <div class="form-row">
          <label><input type="checkbox" id="pipe-image-generation-enabled" onchange="togglePipeImageOptions()"> Enable image generation for graphics/icons/assets</label>
        </div>
        <div id="pipe-image-options" style="display:none">
          <div class="form-row">
            <label>Image Provider</label>
            <select id="pipe-image-provider" onchange="onPipeImageProviderChanged()">
              <option value="openai">OpenAI</option>
              <option value="google">Google</option>
            </select>
          </div>
          <div class="form-row">
            <label>Image Model</label>
            <input type="text" id="pipe-image-model" value="gpt-image-1" placeholder="gpt-image-1 or nano-banana">
          </div>
        </div>

        <div class="form-row" style="margin-top:8px">
          <label><input type="checkbox" id="pipe-vector-memory-enabled" onchange="togglePipeVectorMemory()"> Enable per-repo vector memory (ChromaDB)</label>
          <div class="field-help">Stores high-signal notes, phase outcomes, and research artifacts for long-term retrieval.</div>
        </div>
        <div id="pipe-vector-memory-options" class="option-subpanel hidden">
          <div class="form-row">
            <label>Vector Backend</label>
            <select id="pipe-vector-memory-backend">
              <option value="chroma">ChromaDB</option>
            </select>
          </div>
          <div class="form-row">
            <label>Collection Name <span style="color:var(--text2)">(optional)</span></label>
            <input type="text" id="pipe-vector-memory-collection" placeholder="defaults to repo folder name">
          </div>
          <div class="form-row">
            <label>Memory Recall Top-K</label>
            <input type="number" id="pipe-vector-memory-top-k" value="8" min="1" max="30">
          </div>
          <div class="field-help">Higher values provide more context, but may increase token usage.</div>
        </div>

        <div class="form-row" style="margin-top:8px">
          <label><input type="checkbox" id="pipe-deep-research-enabled" onchange="togglePipeDeepResearch()"> Enable Deep Research phase</label>
          <div class="field-help">Adds a dedicated research step with cache-aware dedupe and persistent summaries.</div>
        </div>
        <div id="pipe-deep-research-options" class="option-subpanel hidden">
          <div class="form-row">
            <label>Research Provider Preference</label>
            <select id="pipe-deep-research-providers">
              <option value="both">OpenAI + Google</option>
              <option value="openai">OpenAI only</option>
              <option value="google">Google only</option>
            </select>
          </div>
          <div class="form-row">
            <label>Reuse Window (hours)</label>
            <input type="number" id="pipe-deep-research-max-age-hours" value="168" min="1" max="8760">
          </div>
          <div class="form-row">
            <label><input type="checkbox" id="pipe-deep-research-dedupe" checked> Skip redundant research when recent findings are similar</label>
          </div>
          <div class="form-row">
            <label><input type="checkbox" id="pipe-deep-research-native-enabled"> Prefer native provider deep-research APIs</label>
            <div class="field-help">Uses provider-native web-research calls with retries, quota limits, and budget controls before agent fallback.</div>
          </div>
          <div class="form-row-inline">
            <div class="form-row">
              <label>Retry Attempts</label>
              <input type="number" id="pipe-deep-research-retry-attempts" value="2" min="1" max="6">
            </div>
            <div class="form-row">
              <label>Daily Quota (runs)</label>
              <input type="number" id="pipe-deep-research-daily-quota" value="8" min="1" max="100">
            </div>
          </div>
          <div class="form-row-inline">
            <div class="form-row">
              <label>Per-Provider Max Tokens</label>
              <input type="number" id="pipe-deep-research-max-provider-tokens" value="12000" min="512" max="64000" step="128">
            </div>
            <div class="form-row">
              <label>Daily Budget (USD est.)</label>
              <input type="number" id="pipe-deep-research-budget-usd" value="5.0" min="0" step="0.1">
            </div>
          </div>
          <div class="form-row-inline">
            <div class="form-row">
              <label>OpenAI Deep Research Model</label>
              <input type="text" id="pipe-deep-research-openai-model" value="gpt-5.2">
            </div>
            <div class="form-row">
              <label>Google Deep Research Model</label>
              <input type="text" id="pipe-deep-research-google-model" value="gemini-3-pro-preview">
            </div>
          </div>
          <div class="form-row" style="margin-top:8px">
            <label>Source Governance Policy (global)</label>
            <div class="field-help">Domain allow/deny lists used for monetization governance checks and deep-research citation filtering.</div>
          </div>
          <div class="form-row-inline">
            <div class="form-row">
              <label>General Allowlist Domains</label>
              <input type="text" id="pipe-governance-research-allowed" placeholder="docs.python.org,openai.com">
            </div>
            <div class="form-row">
              <label>General Blocklist Domains</label>
              <input type="text" id="pipe-governance-research-blocked" placeholder="example.com,tiktok.com">
            </div>
          </div>
          <div class="form-row-inline">
            <div class="form-row">
              <label>Deep Research Allowlist Domains</label>
              <input type="text" id="pipe-governance-deep-allowed" placeholder="developer.mozilla.org,arxiv.org">
            </div>
            <div class="form-row">
              <label>Deep Research Blocklist Domains</label>
              <input type="text" id="pipe-governance-deep-blocked" placeholder="example.com,x.com">
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
            <button class="btn" type="button" onclick="loadGovernancePolicy()">Reload policy</button>
            <button class="btn btn-primary" type="button" onclick="saveGovernancePolicy()">Save policy</button>
          </div>
          <div class="field-help" id="pipe-governance-policy-status"></div>
        </div>

        <div class="form-row" style="margin-top:10px">
          <span class="scope-note">For <span class="program-name-slot">this program</span> only</span>
          <label><input type="checkbox" id="pipe-self-improvement-enabled" onchange="togglePipeSelfImprovement()"> Enable self-improvement restart checkpoint phase</label>
          <div class="field-help">Adds a special phase that writes a resume checkpoint so this program can restart and continue with updated code.</div>
        </div>
        <div class="form-row">
          <label><input type="checkbox" id="pipe-self-improvement-auto-restart"> Auto-restart this program and auto-resume from checkpoint</label>
        </div>
      </div>

      <details class="adv-block">
        <summary>More Controls (optional)</summary>
        <div class="form-row" style="margin-top:8px">
          <label>
            <input type="checkbox" id="pipe-timeout-enabled" onchange="onPipeTimeoutToggle()">
            Enforce Phase Inactivity Timeout
            <span class="help-icon" title="When enabled, a phase is stopped only after this many seconds with no stdout/stderr activity. Disable for unlimited runtime.">?</span>
          </label>
          <div class="field-help" id="pipe-timeout-note">Unlimited (no inactivity timeout).</div>
        </div>
        <div class="form-row">
          <label>Timeout Seconds</label>
          <input type="number" id="pipe-timeout" value="600" min="30" step="1" disabled>
        </div>

        <details class="perm-manual" id="pipe-codex-perm-manual">
          <summary>Manual Permission Controls</summary>
          <div class="form-row">
            <label>Filesystem Access Mode <span class="help-icon" title="workspace-write: read/write in repo only. read-only: inspect only. danger-full-access: broad local access.">?</span></label>
            <select id="pipe-codex-sandbox-mode" onchange="onPermissionControlChanged('pipeline')">
              <option value="workspace-write">workspace-write (recommended)</option>
              <option value="read-only">read-only</option>
              <option value="danger-full-access">danger-full-access</option>
            </select>
          </div>
          <div class="form-row">
            <label>Approval Prompt Mode <span class="help-icon" title="never: non-interactive runs. on-failure/on-request/untrusted: interactive approval prompts.">?</span></label>
            <select id="pipe-codex-approval-policy" onchange="onPermissionControlChanged('pipeline')">
              <option value="never">never (recommended for unattended runs)</option>
              <option value="on-failure">on-failure</option>
              <option value="on-request">on-request</option>
              <option value="untrusted">untrusted</option>
            </select>
          </div>
          <div class="form-row">
            <label>
              <input type="checkbox" id="pipe-codex-bypass-approvals" onchange="onPermissionControlChanged('pipeline')">
              Disable sandbox + approval prompts (trusted repo only)
            </label>
          </div>
        </details>

        <details class="perm-manual">
          <summary>CLI Command Overrides (rare)</summary>
          <div class="form-row">
            <label>Codex CLI Command <span class="help-icon" title="Path or command used to start Codex CLI.">?</span></label>
            <input type="text" id="pipe-codex-bin" value="codex">
          </div>
          <div class="form-row">
            <label>Codex Reasoning Effort <span class="help-icon" title="Controls how much reasoning Codex uses per task. Higher levels are usually slower and more expensive but can improve hard-problem quality.">?</span></label>
            <select id="pipe-codex-reasoning-effort" onchange="onPermissionControlChanged('pipeline')">
              <option value="xhigh">Extra High (recommended default)</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
              <option value="inherit">Inherit Codex CLI default</option>
            </select>
          </div>
          <div class="form-row">
            <label>Claude CLI Command <span class="help-icon" title="Path or command used to start Claude Code CLI.">?</span></label>
            <input type="text" id="pipe-claude-bin" value="claude">
          </div>
        </details>
      </details>
    </div>
  </details>

</aside>

<!-- -- RIGHT: Pipeline Execution -------------------------------- -->
<section class="pipeline-panel" id="pipeline-exec">

  <div style="display:flex;justify-content:space-between;align-items:center">
    <h2>Pipeline Execution</h2>
    <div class="exec-controls">
      <button class="btn btn-success" id="pipe-btn-start" onclick="startPipeline()">&#9654; Start Pipeline</button>
      <button class="btn btn-warning" id="pipe-btn-pause" onclick="pausePipeline()" disabled>&#9208; Pause</button>
      <button class="btn btn-danger"  id="pipe-btn-stop"  onclick="stopPipeline()"  disabled>&#9209; Stop</button>
    </div>
  </div>

  <div class="state-card warning resume-card hidden" id="pipe-resume-card" aria-live="polite">
    <div class="resume-card-title">Resume last run</div>
    <div class="resume-card-sub" id="pipe-resume-summary">
      A resumable pipeline checkpoint is available for this repository.
    </div>
    <div class="resume-card-meta" id="pipe-resume-meta"></div>
    <div class="resume-card-actions">
      <button class="btn btn-warning" type="button" id="pipe-resume-btn" onclick="resumePipelineFromCheckpoint()">Resume</button>
      <button class="btn" type="button" id="pipe-start-fresh-btn" onclick="startFreshPipelineRun()">Start fresh</button>
    </div>
  </div>

  <!-- Progress -->
  <div class="progress-section">
    <div class="progress-info">
      <span id="pipe-progress-text">Ready</span>
      <span id="pipe-progress-tokens" style="color:var(--text2)">0 tokens</span>
    </div>
    <div class="progress-bar"><div class="progress-fill" id="pipe-progress-fill"></div></div>
    <div class="activity-heartbeat" id="pipe-activity-heartbeat">Activity: idle</div>
    <div class="progress-last-log" id="pipe-progress-last-log">Last log: none yet</div>
    <div class="stop-guidance hidden" id="pipe-stop-guidance" aria-live="polite"></div>
  </div>

  <!-- Live Log + Log Files: one row for toolbar and tabs to avoid z-order overlap -->
  <div class="pipe-logs-wrap">
    <div class="pipe-logs-head-row">
      <div class="log-section pipe-logs-live">
        <h3>Live Log</h3>
        <div class="log-toolbar">
          <label><input type="checkbox" id="pipe-show-debug-logs" onchange="togglePipeDebugLogs()"> Show debug messages</label>
        </div>
      </div>
      <div class="log-files-section pipe-logs-files">
        <h3>Log Files</h3>
        <div class="log-tabs" id="log-file-tabs">
          <button class="active" data-file="WISHLIST.md" onclick="viewLogFile('WISHLIST.md')">WISHLIST</button>
          <button data-file="TESTPLAN.md" onclick="viewLogFile('TESTPLAN.md')">TESTPLAN</button>
          <button data-file="ERRORS.md" onclick="viewLogFile('ERRORS.md')">ERRORS</button>
          <button data-file="EXPERIMENTS.md" onclick="viewLogFile('EXPERIMENTS.md')">EXPERIMENTS</button>
          <button data-file="RESEARCH.md" onclick="viewLogFile('RESEARCH.md')">RESEARCH</button>
          <button data-file="SCIENTIST_REPORT.md" onclick="viewLogFile('SCIENTIST_REPORT.md')">SCIENCE REPORT</button>
          <button data-file="PROGRESS.md" onclick="viewLogFile('PROGRESS.md')">PROGRESS</button>
          <button data-file="BRAIN.md" onclick="viewLogFile('BRAIN.md')">BRAIN</button>
          <button data-file="HISTORY.md" onclick="viewLogFile('HISTORY.md')">HISTORY</button>
        </div>
        <div class="science-open-btn">
          <button class="btn btn-primary" onclick="openScienceDashboardModal()">Open Scientist Dashboard</button>
        </div>
      </div>
    </div>
    <div class="log-viewer" id="pipe-log-viewer" aria-live="polite">
      <div class="log-empty state-card">Configure phases and click Start Pipeline...</div>
    </div>
    <h3 id="log-file-label" style="margin-top:4px">Log File Contents</h3>
    <div class="log-content" id="log-file-content" aria-live="polite">Select a log file above to view its contents.</div>
  </div>

  <!-- Results -->
  <div class="results-section">
    <h3>Phase Results</h3>
    <div class="results-wrap">
      <table class="results-table">
        <thead>
          <tr>
            <th>Phase</th>
            <th>Iter</th>
            <th>Status</th>
            <th>Tests</th>
            <th>Files</th>
            <th>Changed Files</th>
            <th>Net &Delta;</th>
            <th>Time</th>
          </tr>
        </thead>
        <tbody id="pipe-results-body">
          <tr><td colspan="8"><div class="state-card">No pipeline results yet. Start a pipeline run to populate this table.</div></td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="results-section">
    <div class="results-head">
      <h3>Recent Run Comparison</h3>
      <div class="results-head-actions">
        <button class="btn btn-success" type="button" onclick="promoteLastDryRunToApply()">Promote Last Dry-Run</button>
        <button class="btn" type="button" onclick="refreshPipelineRunComparison()">Refresh</button>
      </div>
    </div>
    <div class="run-compare-summary" id="pipe-run-compare-summary">
      Compare recent finished runs to identify the most effective configuration.
    </div>
    <div class="results-wrap">
      <table class="results-table">
        <thead>
          <tr>
            <th>Ended</th>
            <th>Run</th>
            <th>Configuration</th>
            <th>Duration</th>
            <th>Tokens</th>
            <th>Est Cost (USD)</th>
            <th>Tests</th>
            <th>Stop Reason</th>
            <th>Commits</th>
            <th>Artifacts</th>
          </tr>
        </thead>
        <tbody id="pipe-run-compare-body">
          <tr><td colspan="10"><div class="state-card">Set Repository Path to load recent run comparisons.</div></td></tr>
        </tbody>
      </table>
    </div>
  </div>

</section>
</div>

<!-- Onboarding (first visit) -->
<div id="onboarding-overlay" class="hidden">
  <div class="onboarding-card" role="dialog" aria-modal="true" aria-labelledby="onboarding-title">
    <h2 id="onboarding-title">Welcome to {{ project_display_name }}</h2>
    <p>Configure and run AI-powered task chains on your repo: discovery, implementation, testing, refactoring, and more. Choose how much control you want:</p>
    <div class="mode-row"><strong>Autopilot</strong><span>Pick a recipe, set your repo path, and hit Start. Best for quick runs.</span></div>
    <div class="mode-row"><strong>Customize</strong><span>Build and reorder steps, set loop counts and stop conditions. No advanced options.</span></div>
    <div class="mode-row"><strong>Expert</strong><span>Full control: parallel execution, brain model, agent per step, timeouts, and advanced settings.</span></div>
    <div class="onboarding-actions">
      <button type="button" class="btn btn-primary" onclick="openFirstRunWizard()">Guided First Run</button>
      <button type="button" class="btn" onclick="dismissOnboarding()">Skip Wizard</button>
    </div>
  </div>
</div>

<div id="first-run-wizard-overlay" class="hidden" onclick="if(event.target===this)closeFirstRunWizard()">
  <div class="first-run-wizard-card" role="dialog" aria-modal="true" aria-labelledby="first-run-wizard-title">
    <div>
      <h2 id="first-run-wizard-title">First Successful Run Wizard</h2>
      <p class="first-run-wizard-subtitle">Set your repository, run setup diagnostics, apply safe defaults, and start one dry-run strategic pass.</p>
    </div>
    <div class="first-run-wizard-steps">
      <div class="first-run-wizard-step"><strong>1. Set Repo</strong>Pick the repository folder you want {{ project_display_name }} to work on.</div>
      <div class="first-run-wizard-step"><strong>2. Run Diagnostics</strong>Check repo access, CLI binaries, and authentication for selected agents.</div>
      <div class="first-run-wizard-step"><strong>3. Fix Required Items</strong>Use copy/run actions for missing dependencies and auth setup.</div>
      <div class="first-run-wizard-step"><strong>4. Start Safe Run</strong>Apply dry-run defaults and launch one strategic chain run.</div>
    </div>

    <div class="config-section" style="padding:12px">
      <label for="first-run-wizard-repo-path">Repository Path</label>
      <div class="first-run-wizard-repo-row">
        <input
          type="text"
          id="first-run-wizard-repo-path"
          placeholder="C:\path\to\your\repo"
          oninput="onFirstRunWizardRepoInput()"
        >
        <button type="button" class="btn" onclick="openBrowse('first-run-wizard-repo-path')">Browse</button>
        <button type="button" class="btn" onclick="syncFirstRunWizardRepoFromCurrent()">Use Current Repo</button>
      </div>
      <div class="first-run-wizard-status" id="first-run-wizard-status">Set a repository path, then run diagnostics.</div>
    </div>

    <div class="first-run-wizard-diag-summary" id="first-run-wizard-diag-summary">Diagnostics not run yet.</div>
    <div class="first-run-wizard-grid">
      <div class="first-run-wizard-panel">
        <h3>Checks</h3>
        <div id="first-run-wizard-diag-list" class="first-run-wizard-empty">Run diagnostics to populate checks.</div>
      </div>
      <div class="first-run-wizard-panel">
        <h3>Next Actions</h3>
        <div id="first-run-wizard-actions" class="first-run-wizard-empty">No actions yet.</div>
      </div>
    </div>

    <div class="first-run-wizard-footer">
      <button type="button" class="btn" onclick="closeFirstRunWizard()">Close</button>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button type="button" class="btn" onclick="runFirstRunWizardDiagnostics()">Run Diagnostics</button>
        <button type="button" class="btn" onclick="applyFirstRunWizardDefaults()">Apply Safe Defaults</button>
        <button type="button" class="btn btn-success" onclick="startFirstRunWizard()">Start First Dry Run</button>
      </div>
    </div>
  </div>
</div>

<!-- To-Do / Wishlist modal -->
<div id="todo-wishlist-overlay" class="hidden" onclick="if(event.target===this)hideTodoWishlistModal()">
  <div class="todo-wishlist-card" role="dialog" aria-modal="true" aria-labelledby="todo-wishlist-title">
    <h2 id="todo-wishlist-title">To-Do / Wishlist Workspace</h2>
    <p class="subtitle">Write your own backlog or let AI generate one, then implement it with one click.</p>

    <div class="form-row">
      <label>Repository Path</label>
      <div class="repo-row">
        <input type="text" id="todo-wishlist-repo" placeholder="C:\path\to\your\repo">
        <button class="btn" type="button" onclick="syncTodoWishlistRepoFromMain()">Use Current Repo</button>
      </div>
    </div>

    <div class="form-row">
      <label>To-Do / Wishlist (markdown checklist)</label>
      <textarea id="todo-wishlist-content" rows="18" placeholder="- [ ] Add feature X&#10;- [ ] Improve Y"></textarea>
      <div class="field-help">Use <code>- [ ]</code> for open items and <code>- [x]</code> for completed items.</div>
    </div>

    <details>
      <summary>AI Suggestion (optional)</summary>
      <div class="form-row" style="margin-top:8px">
        <label>Extra context for AI</label>
        <textarea id="todo-wishlist-context" rows="4" placeholder="What kind of features, priorities, constraints, or timeline do you want?"></textarea>
      </div>
      <div class="form-row">
        <label>Suggestion Model</label>
        <select id="todo-wishlist-model">
          <option value="gpt-5.2">GPT-5.2</option>
          <option value="claude-opus-4-6">Claude Opus 4.6</option>
          <option value="gemini-3-pro-preview">Gemini 3 Pro</option>
          <option value="grok-4-1-fast-reasoning">Grok 4.1 Fast</option>
        </select>
      </div>
      <div class="form-row">
        <label>Context Files (optional)</label>
        <input type="file" id="todo-wishlist-context-files" multiple onchange="onTodoWishlistContextFilesChanged(this)">
        <div class="field-help">Attach text-like files for backlog context (plain text, markdown, code, config).</div>
        <div class="context-file-list" id="todo-wishlist-context-files-list">No context files selected.</div>
      </div>
      <div class="inline-actions">
        <button class="btn" type="button" onclick="suggestTodoWishlist()">Suggest with AI</button>
        <button class="btn" type="button" onclick="appendTodoWishlistSuggestion()">Append Suggestion</button>
      </div>
      <div class="status" id="todo-wishlist-suggest-status"></div>
    </details>

    <div class="actions">
      <button class="btn" type="button" onclick="hideTodoWishlistModal()">Close</button>
      <button class="btn" type="button" onclick="loadTodoWishlist()">Load</button>
      <button class="btn btn-primary" type="button" onclick="saveTodoWishlist()">Save</button>
      <button class="btn btn-success" type="button" onclick="saveAndStartTodoWishlistAutopilot()">Save + Implement</button>
    </div>
  </div>
</div>

<!-- Feature Dreams modal -->
<div id="feature-dreams-overlay" class="hidden" onclick="if(event.target===this)hideFeatureDreamsModal()">
  <div class="feature-dreams-card" role="dialog" aria-modal="true" aria-labelledby="feature-dreams-title">
    <h2 id="feature-dreams-title">Feature Dreams Workspace</h2>
    <p class="subtitle">Capture feature ideas in priority order and refine the list with AI suggestions.</p>

    <div class="form-row">
      <label>Repository Path</label>
      <div class="repo-row">
        <input type="text" id="feature-dreams-repo" placeholder="C:\path\to\your\repo">
        <button class="btn" type="button" onclick="syncFeatureDreamsRepoFromMain()">Use Current Repo</button>
      </div>
    </div>

    <div class="form-row">
      <label>Feature Dreams (markdown checklist)</label>
      <textarea id="feature-dreams-content" rows="18" placeholder="- [ ] [S] Add onboarding assistant&#10;- [ ] [M] Add release digest panel"></textarea>
      <div class="field-help">Use <code>- [ ]</code> for open items, <code>- [x]</code> for completed items, and effort tags like <code>[S]</code>/<code>[M]</code>/<code>[L]</code>.</div>
    </div>

    <details>
      <summary>AI Suggestion (optional)</summary>
      <div class="form-row" style="margin-top:8px">
        <label>Extra context for AI</label>
        <textarea id="feature-dreams-context" rows="4" placeholder="What product direction, user outcomes, or constraints should shape feature prioritization?"></textarea>
      </div>
      <div class="form-row">
        <label>Suggestion Model</label>
        <select id="feature-dreams-model">
          <option value="gpt-5.2">GPT-5.2</option>
          <option value="claude-opus-4-6">Claude Opus 4.6</option>
          <option value="gemini-3-pro-preview">Gemini 3 Pro</option>
          <option value="grok-4-1-fast-reasoning">Grok 4.1 Fast</option>
        </select>
      </div>
      <div class="inline-actions">
        <button class="btn" type="button" onclick="suggestFeatureDreams()">Suggest with AI</button>
        <button class="btn" type="button" onclick="appendFeatureDreamsSuggestion()">Append Suggestion</button>
      </div>
      <div class="status" id="feature-dreams-suggest-status"></div>
    </details>

    <div class="actions">
      <button class="btn" type="button" onclick="hideFeatureDreamsModal()">Close</button>
      <button class="btn" type="button" onclick="loadFeatureDreams()">Load</button>
      <button class="btn btn-primary" type="button" onclick="saveFeatureDreams()">Save</button>
      <button class="btn btn-success" type="button" onclick="saveAndStartFeatureDreamAutopilot()">Save + Implement</button>
    </div>
  </div>
</div>

<!-- General Request modal -->
<div id="general-request-overlay" class="hidden" onclick="if(event.target===this)hideGeneralRequestModal()">
  <div class="general-request-card" role="dialog" aria-modal="true" aria-labelledby="general-request-title">
    <h2 id="general-request-title">General Request Workspace</h2>
    <p class="subtitle">Drop one general request, let AI consider it (or run a direct implementation pass), and keep a timestamped history.</p>

    <div class="form-row">
      <label>Repository Path</label>
      <div class="repo-row">
        <input type="text" id="general-request-repo" placeholder="C:\path\to\your\repo">
        <button class="btn" type="button" onclick="syncGeneralRequestRepoFromMain()">Use Current Repo</button>
      </div>
    </div>

    <div class="form-row">
      <label>General Request</label>
      <textarea id="general-request-content" rows="7" placeholder="Example: Add keyboard shortcuts to key actions and update the docs so users can discover them."></textarea>
      <div class="field-help">The request box is cleared after the request is considered or implementation run is recorded.</div>
    </div>

    <details>
      <summary>AI Options (optional)</summary>
      <div class="form-row" style="margin-top:8px">
        <label>Extra context for AI</label>
        <textarea id="general-request-context" rows="3" placeholder="Any constraints, product goals, or non-negotiables?"></textarea>
      </div>
      <div class="form-row">
        <label>Model</label>
        <select id="general-request-model">
          <option value="gpt-5.2">GPT-5.2</option>
          <option value="claude-opus-4-6">Claude Opus 4.6</option>
          <option value="gemini-3-pro-preview">Gemini 3 Pro</option>
          <option value="grok-4-1-fast-reasoning">Grok 4.1 Fast</option>
        </select>
      </div>
    </details>

    <div class="form-row">
      <label>Latest AI Output (exact)</label>
      <textarea id="general-request-output" rows="8" readonly placeholder="AI output will appear here exactly as returned."></textarea>
    </div>
    <div class="status" id="general-request-status"></div>

    <details id="general-request-history-panel">
      <summary>Recent History</summary>
      <div class="inline-actions" style="margin-top:8px">
        <button class="btn" type="button" onclick="loadGeneralRequestHistory()">Refresh History</button>
      </div>
      <div id="general-request-history" class="general-request-history">
        <div class="state-card">No history yet.</div>
      </div>
    </details>

    <div class="actions">
      <button class="btn" type="button" onclick="hideGeneralRequestModal()">Close</button>
      <button class="btn" type="button" onclick="considerGeneralRequest()">Consider with AI</button>
      <button class="btn btn-success" type="button" onclick="implementGeneralRequestViaChain()">Implement Request</button>
    </div>
  </div>
</div>

<!-- Commit workflow modal -->
<div id="git-commit-overlay" class="hidden" onclick="if(event.target===this)hideGitCommitModal()">
  <div class="git-commit-card" role="dialog" aria-modal="true" aria-labelledby="git-commit-title">
    <h2 id="git-commit-title">Commit Workflow</h2>
    <p class="subtitle">Stage or unstage files, write a commit message, and review the most recent commit summary.</p>

    <div class="git-commit-meta">
      <div class="git-commit-card-block">
        <h3>Repository</h3>
        <div class="field-help" id="git-commit-repo-path">No repo selected</div>
      </div>
      <div class="git-commit-card-block">
        <h3>Last Commit</h3>
        <div class="git-commit-last-commit" id="git-commit-last-summary">No commits yet.</div>
      </div>
    </div>

    <div class="git-commit-file-toolbar">
      <div class="summary" id="git-commit-change-summary">No changes loaded.</div>
      <button class="btn" id="git-commit-refresh-btn" type="button" onclick="refreshGitCommitWorkflowNow()">Refresh</button>
      <button class="btn" id="git-commit-stage-all-btn" type="button" onclick="gitCommitStageAll()">Stage All</button>
      <button class="btn" id="git-commit-unstage-all-btn" type="button" onclick="gitCommitUnstageAll()">Unstage All</button>
    </div>

    <div class="git-commit-file-list">
      <table class="git-commit-file-table">
        <thead>
          <tr>
            <th style="width:46%">Path</th>
            <th style="width:32%">State</th>
            <th style="width:22%">Actions</th>
          </tr>
        </thead>
        <tbody id="git-commit-files-body">
          <tr>
            <td colspan="3" style="color:var(--text2)">Select a repository path to load changed files.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="git-commit-message">
      <label for="git-commit-message">Commit Message</label>
      <textarea
        id="git-commit-message"
        rows="5"
        placeholder="Describe the change you are committing..."
        oninput="_syncGitCommitControls()"
      ></textarea>
      <div class="field-help">Commits use this message exactly as entered.</div>
    </div>

    <div class="status" id="git-commit-status" data-tone="muted"></div>

    <div class="actions">
      <button class="btn" type="button" onclick="hideGitCommitModal()">Close</button>
      <button class="btn btn-success" id="git-commit-create-btn" type="button" onclick="gitCommitCreate()">Commit</button>
    </div>
  </div>
</div>

<!-- Git Remote Management modal -->
<div id="git-remote-overlay" class="hidden" onclick="if(event.target===this)hideGitRemoteModal()">
  <div class="git-remote-card" role="dialog" aria-modal="true" aria-labelledby="git-remote-title">
    <h2 id="git-remote-title">Remote Management</h2>
    <p class="subtitle">View/add/remove remotes, choose a default push remote, and validate HTTPS/SSH URLs.</p>

    <div class="git-remote-meta">
      <div class="git-remote-card-block">
        <h3>Repository</h3>
        <div class="field-help" id="git-remote-repo-path">No repo selected</div>
      </div>
      <div class="git-remote-card-block">
        <h3>Default Remote</h3>
        <div class="field-help" id="git-remote-default">No remotes loaded.</div>
      </div>
    </div>

    <div class="git-remote-toolbar">
      <button class="btn" id="git-remote-refresh-btn" type="button" onclick="refreshGitRemotesNow()">Refresh</button>
      <button class="btn" id="git-remote-clear-default-btn" type="button" onclick="gitRemoteClearDefault()">Clear Default</button>
    </div>

    <div class="git-remote-list">
      <table class="git-remote-table">
        <thead>
          <tr>
            <th style="width:18%">Remote</th>
            <th style="width:54%">URLs</th>
            <th style="width:28%">Actions</th>
          </tr>
        </thead>
        <tbody id="git-remote-body">
          <tr>
            <td colspan="3" style="color:var(--text2)">Select a repository path to load remotes.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="git-remote-add">
      <h3>Add Remote</h3>
      <div class="git-remote-add-grid">
        <div class="form-row" style="margin-bottom:0">
          <label for="git-remote-name-input">Remote Name</label>
          <input
            id="git-remote-name-input"
            type="text"
            placeholder="origin"
            oninput="_syncGitRemoteControls()"
          >
        </div>
        <div class="form-row" style="margin-bottom:0">
          <label for="git-remote-url-input">Remote URL (HTTPS/SSH)</label>
          <input
            id="git-remote-url-input"
            type="text"
            placeholder="https://github.com/owner/repo.git or git@github.com:owner/repo.git"
            oninput="_syncGitRemoteControls()"
          >
        </div>
        <button class="btn" id="git-remote-validate-btn" type="button" onclick="gitRemoteValidateUrl()">Validate URL</button>
      </div>
      <div class="git-remote-add-row">
        <label for="git-remote-add-default-check" title="Set this remote as the default target for push actions.">
          <input id="git-remote-add-default-check" type="checkbox">
          set as default remote
        </label>
        <button class="btn btn-success" id="git-remote-add-btn" type="button" onclick="gitRemoteAdd()">Add Remote</button>
      </div>
      <div class="field-help" id="git-remote-add-help">Use HTTPS or SSH URL formats only.</div>
    </div>

    <div class="status" id="git-remote-status" data-tone="muted"></div>

    <div class="actions">
      <button class="btn" type="button" onclick="hideGitRemoteModal()">Close</button>
    </div>
  </div>
</div>

<!-- Git Signing Management modal -->
<div id="git-signing-overlay" class="hidden" onclick="if(event.target===this)hideGitSigningModal()">
  <div class="git-signing-card" role="dialog" aria-modal="true" aria-labelledby="git-signing-title">
    <h2 id="git-signing-title">Git Signing Setup</h2>
    <p class="subtitle">Configure commit/tag signing with GPG or SSH, validate key readiness, and enforce push guardrails.</p>

    <div class="git-signing-meta">
      <div class="git-signing-card-block">
        <h3>Repository</h3>
        <div class="field-help" id="git-signing-repo-path">No repo selected</div>
      </div>
      <div class="git-signing-card-block">
        <h3>Validation Summary</h3>
        <div class="field-help" id="git-signing-summary">No signing settings loaded.</div>
      </div>
    </div>

    <div class="git-signing-form-grid">
      <div class="form-row">
        <label for="git-signing-mode">Signing Mode</label>
        <select id="git-signing-mode" onchange="_syncGitSigningControls()">
          <option value="gpg">GPG (OpenPGP)</option>
          <option value="ssh">SSH</option>
        </select>
      </div>
      <div class="form-row">
        <label for="git-signing-key">Signing Key ID / Value / Path</label>
        <input
          id="git-signing-key"
          type="text"
          placeholder="GPG key id/email, ssh-ed25519 ..., or path to key file"
          oninput="_syncGitSigningControls()"
        >
      </div>
    </div>

    <div class="git-signing-options">
      <label for="git-signing-clear-key" title="Unset user.signingkey in this repository.">
        <input id="git-signing-clear-key" type="checkbox" onchange="_syncGitSigningControls()">
        clear signing key
      </label>
      <label for="git-signing-commit-sign" title="Maps to git config commit.gpgsign.">
        <input id="git-signing-commit-sign" type="checkbox" onchange="_syncGitSigningControls()">
        sign commits
      </label>
      <label for="git-signing-tag-sign" title="Maps to git config tag.gpgSign.">
        <input id="git-signing-tag-sign" type="checkbox" onchange="_syncGitSigningControls()">
        sign tags
      </label>
      <label for="git-signing-require-push-guard" title="Block push when signing is enabled but validation fails.">
        <input id="git-signing-require-push-guard" type="checkbox" onchange="_syncGitSigningControls()">
        block push when invalid
      </label>
    </div>

    <div class="git-signing-checks" id="git-signing-checks">
      <div class="state-card">Select a repository path to load signing checks.</div>
    </div>

    <div class="status" id="git-signing-status" data-tone="muted"></div>

    <div class="actions">
      <button class="btn" type="button" onclick="hideGitSigningModal()">Close</button>
      <button class="btn" id="git-signing-refresh-btn" type="button" onclick="refreshGitSigningSettingsNow()">Reload</button>
      <button class="btn" id="git-signing-validate-btn" type="button" onclick="validateGitSigningSettings()">Validate</button>
      <button class="btn btn-primary" id="git-signing-save-btn" type="button" onclick="saveGitSigningSettings()">Save</button>
    </div>
  </div>
</div>

<!-- API Keys modal -->
<div id="api-keys-overlay" class="hidden" onclick="if(event.target===this)hideApiKeysModal()">
  <div class="api-keys-card" role="dialog" aria-modal="true" aria-labelledby="api-keys-title">
    <h2 id="api-keys-title">API Keys</h2>
    <p class="subtitle">Store credentials for the API providers supported by this project.</p>
    <div class="meta" id="api-keys-meta">Loading key status...</div>
    <div class="fields" id="api-keys-fields">
      <div class="state-card loading">Loading supported API keys...</div>
    </div>
    <div class="status" id="api-keys-status"></div>
    <div class="actions">
      <button class="btn" type="button" onclick="hideApiKeysModal()">Close</button>
      <button class="btn" type="button" onclick="loadApiKeysState()">Reload</button>
      <button class="btn btn-primary" type="button" onclick="saveApiKeysState()">Save</button>
    </div>
  </div>
</div>

<!-- GitHub Auth modal -->
<div id="github-auth-overlay" class="hidden" onclick="if(event.target===this)hideGithubAuthModal()">
  <div class="github-auth-card" role="dialog" aria-modal="true" aria-labelledby="github-auth-title">
    <h2 id="github-auth-title">GitHub Auth Setup</h2>
    <p class="subtitle">Store a GitHub PAT and optional SSH key in secure local storage, then verify access.</p>

    <div class="form-row">
      <label>Preferred Git Transport</label>
      <select id="github-auth-method" onchange="syncGithubAuthForm()">
        <option value="https">HTTPS (PAT)</option>
        <option value="ssh">SSH key</option>
      </select>
    </div>

    <div class="form-row">
      <label>GitHub Personal Access Token (PAT)</label>
      <input type="password" id="github-auth-pat" placeholder="ghp_xxxxx or github_pat_xxxxx" autocomplete="off">
      <div class="field-help">Leave blank to keep existing token unchanged.</div>
      <label style="margin-top:6px"><input type="checkbox" id="github-auth-clear-pat"> Remove saved PAT</label>
    </div>

    <details id="github-auth-ssh-details">
      <summary>Optional SSH Private Key</summary>
      <div class="form-row" style="margin-top:8px">
        <label>Private Key</label>
        <textarea id="github-auth-ssh-key" rows="8" placeholder="-----BEGIN OPENSSH PRIVATE KEY-----&#10;...&#10;-----END OPENSSH PRIVATE KEY-----"></textarea>
        <div class="field-help">Leave blank to keep existing key unchanged.</div>
        <label style="margin-top:6px"><input type="checkbox" id="github-auth-clear-ssh"> Remove saved SSH key</label>
      </div>
    </details>

    <div class="meta" id="github-auth-meta">Loading current GitHub auth settings...</div>
    <div class="status" id="github-auth-status"></div>
    <div class="github-auth-troubleshooting hidden" id="github-auth-troubleshooting"></div>

    <div class="actions">
      <button class="btn" type="button" onclick="hideGithubAuthModal()">Close</button>
      <button class="btn" type="button" onclick="loadGithubAuthSettings()">Reload</button>
      <button class="btn" type="button" onclick="testGithubAuthConnection()">Test Connection</button>
      <button class="btn btn-primary" type="button" onclick="saveGithubAuthSettings()">Save</button>
    </div>
  </div>
</div>

<!-- New Project modal -->
<div id="new-project-overlay" class="hidden">
  <div class="new-project-card" role="dialog" aria-modal="true" aria-labelledby="new-project-title">
    <h2 id="new-project-title">New Project</h2>
    <p class="subtitle">Create a new project folder with a local Git repository.</p>

    <div class="form-row">
      <label>Parent Directory</label>
      <input type="text" id="np-parent" placeholder="C:\Users\you\Projects">
    </div>
    <div class="form-row">
      <label>Project Name</label>
      <input type="text" id="np-name" placeholder="my-awesome-project">
    </div>
    <div class="form-row">
      <label>Description <span style="color:var(--text2)">(optional)</span></label>
      <input type="text" id="np-desc" placeholder="A short description for the README">
    </div>

    <div class="form-row">
      <label>Git Author Name</label>
      <input type="text" id="np-git-name" placeholder="Your Name" value="">
    </div>
    <div class="form-row">
      <label>Git Author Email</label>
      <input type="text" id="np-git-email" placeholder="you@example.com" value="">
    </div>

    <div class="toggle-row">
      <label><input type="checkbox" id="np-readme" checked> Create README.md</label>
      <label><input type="checkbox" id="np-gitignore" checked> Create .gitignore</label>
    </div>

    <details>
      <summary>Remote &amp; Branch Settings</summary>
      <div class="form-row">
        <label>Initial Branch Name</label>
        <input type="text" id="np-branch" placeholder="main" value="main">
      </div>
      <div class="form-row">
        <label>Remote URL <span style="color:var(--text2)">(optional - GitHub, GitLab, etc.)</span></label>
        <input type="text" id="np-remote" placeholder="https://github.com/you/repo.git">
      </div>
    </details>

    <details>
      <summary>Foundational Prompt &amp; Bootstrap (optional)</summary>
      <div class="form-row" style="margin-top:8px">
        <label><input type="checkbox" id="np-foundation-enabled" onchange="toggleFoundationOptions()"> Enable foundational prompt setup</label>
      </div>
      <div id="np-foundation-options" class="option-subpanel hidden">
        <div class="form-row">
          <label>Foundational Prompt</label>
          <textarea id="np-foundation-prompt" rows="8" placeholder="Describe what should be built, constraints, priorities, and quality bar..."></textarea>
        </div>
        <div class="form-row">
          <label>Prompt Improvement Assistants</label>
          <div class="foundation-tools">
            <label><input type="checkbox" class="np-foundation-assistant" value="codex" checked> Codex</label>
            <label><input type="checkbox" class="np-foundation-assistant" value="openai"> OpenAI</label>
            <label><input type="checkbox" class="np-foundation-assistant" value="google"> Google</label>
            <label><input type="checkbox" class="np-foundation-assistant" value="claude"> Claude</label>
            <button class="btn" type="button" onclick="improveFoundationalPrompt()">Improve my foundational prompt</button>
          </div>
          <div class="field-help" id="np-foundation-status">Choose assistants and click "Improve..." to refine prompt structure.</div>
        </div>
        <div class="toggle-row">
          <label><input type="checkbox" id="np-foundation-generate-docs" checked> Auto-generate foundational docs/plans</label>
          <label><input type="checkbox" id="np-foundation-bootstrap-once" checked> Mark one-time bootstrap request</label>
          <label><input type="checkbox" id="np-foundation-bootstrap-autorun" checked> Auto-run one-time bootstrap chain after project creation</label>
        </div>
      </div>
    </details>

    <details>
      <summary>Licensing &amp; Commercial Packaging (optional)</summary>
      <div class="form-row" style="margin-top:8px">
        <label><input type="checkbox" id="np-licensing-enabled" onchange="toggleLicensingOptions()"> Generate licensing/commercial planning docs</label>
      </div>
      <div id="np-licensing-options" class="option-subpanel hidden">
        <div class="form-row">
          <label>Strategy</label>
          <select id="np-licensing-strategy">
            <option value="oss_only">Open-source only</option>
            <option value="open_core">Open core (OSS + paid add-ons)</option>
            <option value="dual_license">Dual license (OSS + commercial)</option>
            <option value="hosted_service">Hosted service (SaaS/API)</option>
          </select>
        </div>
        <div class="toggle-row">
          <label><input type="checkbox" id="np-licensing-commercial" checked> Include pricing-tier planning template</label>
        </div>
        <div class="form-row">
          <label>Owner Contact Email <span style="color:var(--text2)">(optional)</span></label>
          <input type="text" id="np-licensing-email" placeholder="owner@example.com">
        </div>
        <div class="form-row">
          <label><input type="checkbox" id="np-licensing-legal-review-required" checked onchange="toggleLicensingLegalSignoff()"> Require legal-review checkpoint before publishing docs</label>
        </div>
        <div class="form-row">
          <label><input type="checkbox" id="np-licensing-legal-signoff"> Mark legal sign-off complete now</label>
        </div>
        <div class="form-row">
          <label>Legal Reviewer <span style="color:var(--text2)">(optional)</span></label>
          <input type="text" id="np-licensing-legal-reviewer" placeholder="owner or counsel">
        </div>
        <div class="form-row">
          <label>Legal Notes <span style="color:var(--text2)">(optional)</span></label>
          <input type="text" id="np-licensing-legal-notes" placeholder="Internal sign-off notes">
        </div>
        <div class="field-help">Creates draft docs under <code>docs/</code> and profile config under <code>.codex_manager/business/</code>.</div>
      </div>
    </details>

    <div class="creation-result" id="np-result"></div>

    <div class="actions">
      <button class="btn" onclick="hideNewProjectModal()">Cancel</button>
      <button class="btn btn-primary" id="np-create-btn" onclick="createProject()">Create Project</button>
    </div>
  </div>
</div>

<!--  -->
<!-- JAVASCRIPT                                                    -->
<!--  -->
<!-- Clone Repo modal -->
<div id="clone-repo-overlay" class="hidden" onclick="if(event.target===this)hideCloneRepoModal()">
  <div class="clone-repo-card" role="dialog" aria-modal="true" aria-labelledby="clone-repo-title">
    <h2 id="clone-repo-title">Clone Remote Repo</h2>
    <p class="subtitle">Paste a GitHub URL, choose a destination, select a branch, and initialize <code>.codex_manager</code>.</p>

    <div class="form-row">
      <label>GitHub Repo URL</label>
      <input type="text" id="clone-remote-url" placeholder="https://github.com/owner/repo.git">
    </div>

    <div class="form-row">
      <label>Destination Directory</label>
      <div class="row-with-button">
        <input type="text" id="clone-destination-dir" placeholder="C:\Users\you\Projects">
        <button class="btn" type="button" onclick="openBrowse('clone-destination-dir')">Browse</button>
      </div>
    </div>

    <div class="form-row">
      <label>Project Folder Name <span style="color:var(--text2)">(optional)</span></label>
      <input type="text" id="clone-project-name" placeholder="repo (auto-detected if blank)">
    </div>

    <div class="form-row">
      <label>Default Branch</label>
      <div class="row-with-button">
        <select id="clone-default-branch">
          <option value="__remote_default__">Use remote default branch</option>
        </select>
        <button class="btn" type="button" onclick="loadCloneRemoteBranches()">Load Branches</button>
      </div>
      <div class="field-help" id="clone-branch-help">Load branch names from the remote (optional).</div>
    </div>

    <div class="meta">After clone, {{ project_display_name }} scaffolding is initialized under <code>.codex_manager/</code>.</div>
    <div class="status" id="clone-repo-status"></div>

    <div class="actions">
      <button class="btn" type="button" onclick="hideCloneRepoModal()">Cancel</button>
      <button class="btn btn-primary" id="clone-repo-btn" type="button" onclick="cloneRemoteRepo()">Clone Repo</button>
    </div>
  </div>
</div>

<script>
/* -- State ------------------------------------------------------ */
function cloneState(obj) {
  return JSON.parse(JSON.stringify(obj));
}

const config = {
  name: 'Untitled Chain',
  repo_path: '',
  mode: 'dry-run',
  steps: [],
  max_loops: 3,
  unlimited: false,
  improvement_threshold: 1.0,
  max_time_minutes: 120,
  max_total_tokens: 2000000,
  strict_token_budget: false,
  stop_on_convergence: true,
  test_cmd: '',
  codex_binary: 'codex',
  codex_reasoning_effort: 'xhigh',
  claude_binary: 'claude',
  codex_sandbox_mode: 'workspace-write',
  codex_approval_policy: 'never',
  codex_bypass_approvals_and_sandbox: false,
  codex_danger_confirmation: '',
  allow_path_creation: true,
  dependency_install_policy: 'project_only',
  image_generation_enabled: false,
  image_provider: 'openai',
  image_model: 'gpt-image-1',
  vector_memory_enabled: false,
  vector_memory_backend: 'chroma',
  vector_memory_collection: '',
  vector_memory_top_k: 8,
  git_preflight_enabled: false,
  git_preflight_auto_stash: false,
  git_preflight_auto_pull: false,
  timeout_per_step: 0,
  parallel_execution: false,
  brain_enabled: false,
  brain_model: 'gpt-5.2',
  local_only: false,
};
const DEFAULT_CHAIN_CONFIG = cloneState(config);

let presets = [];
let selectedStepId = null;
let eventSource = null;
let pollTimer = null;
let chainOutputFiles = [];
let _lastOutputRefreshStepCount = -1;
let chainResultsCache = [];
let pipeResultsCache = [];
let chainResultsCount = 0;
let pipeResultsCount = 0;
let _chainResultsRenderSignature = '';
let _pipeResultsRenderSignature = '';
let chainLogEntries = [];
let pipeLogEntries = [];
let chainLastActivityMs = 0;
let pipeLastActivityMs = 0;
let chainRunning = false;
let chainPaused = false;
let pipeRunning = false;
let pipePaused = false;
let activityHeartbeatTimer = null;
let backendHealthTimer = null;
let backendOnline = true;
let backendLastError = '';
let pendingServerRestart = null;
let selfRestartNoticeCheckpoint = '';
let watchdogAlertsTimer = null;
let watchdogAlertsMutedUntil = 0;
let watchdogAlertDigest = '';
let watchdogMigrationSuggestions = [];
let apiKeysState = null;
let githubAuthState = null;
let githubAuthTroubleshooting = null;
let aboutState = null;
const _autoVectorMemoryNotified = { chain: '', pipeline: '' };
let gitSyncState = null;
let gitSyncBranchState = null;
let gitRemoteState = null;
let gitCommitWorkflowState = null;
let gitSigningState = null;
let gitSyncBusyAction = '';
let gitSyncPullRequestUrl = '';
let gitSyncGithubRepoUrl = '';
let gitSyncRefreshTimer = null;
let gitSyncPollTimer = null;
const GIT_SYNC_POLL_INTERVAL_MS = 20000;
let workspaceState = null;
let workspaceBusy = false;
let firstRunWizardReport = null;
let firstRunWizardBusy = false;

let currentMode = (typeof localStorage !== 'undefined' && localStorage.getItem('cm_mode')) || 'easy';
const GIT_SYNC_DRAWER_STORAGE_KEY = 'cm_git_sync_open';

const RECIPES_PAYLOAD = {{ recipes_payload | tojson }};
const RECIPES = (RECIPES_PAYLOAD && RECIPES_PAYLOAD.recipes) || {};
const DEFAULT_EASY_RECIPE_ID = (RECIPES_PAYLOAD && RECIPES_PAYLOAD.default_recipe_id) || 'autopilot_default';
const PROGRAM_DISPLAY_NAME = {{ project_display_name | tojson }};

const VALID_CODEX_SANDBOX_MODES = ['read-only', 'workspace-write', 'danger-full-access'];
const VALID_CODEX_APPROVAL_POLICIES = ['untrusted', 'on-failure', 'on-request', 'never'];
const VALID_CODEX_REASONING_EFFORTS = ['inherit', 'low', 'medium', 'high', 'xhigh'];
const VALID_DEPENDENCY_INSTALL_POLICIES = ['disallow', 'project_only', 'allow_system'];
const VALID_IMAGE_PROVIDERS = ['openai', 'google'];
const DEFAULT_IMAGE_MODEL_BY_PROVIDER = { openai: 'gpt-image-1', google: 'nano-banana' };
const DANGER_CONFIRMATION_PHRASE = 'I UNDERSTAND';
const PERMISSION_PROFILE_LABEL = {
  safe: 'Recommended: Safe Repo Access',
  readonly: 'Read-Only Inspect',
  full_access: 'Trusted Repo Full Access',
  custom: 'Custom',
};
const PERMISSION_PROFILE_SUMMARY = {
  safe: 'Recommended default. Read/write inside your repository with unattended execution.',
  readonly: 'Inspection mode. Reads repository files but does not allow writing changes.',
  full_access: 'Trusted-repo mode. Full local access with sandbox/approval checks disabled.',
  custom: 'Manual settings are active. Review sandbox, approval policy, and bypass toggle.',
};
const CODEX_MODEL_LABEL = 'GPT-5.3-Codex';
const CLONE_DEFAULT_BRANCH_SENTINEL = '__remote_default__';
const _permissionProfileUiState = { chain: null, pipeline: null };
const _modalFocusReturnTargets = Object.create(null);
const _modalOverlayIds = [
  'docs-overlay',
  'science-dashboard-overlay',
  'permissions-help-overlay',
  'run-plan-overlay',
  'readonly-warning-overlay',
  'browse-overlay',
  'new-project-overlay',
  'clone-repo-overlay',
  'git-remote-overlay',
  'git-signing-overlay',
  'git-commit-overlay',
  'api-keys-overlay',
  'github-auth-overlay',
  'todo-wishlist-overlay',
  'feature-dreams-overlay',
  'general-request-overlay',
  'about-overlay',
  'onboarding-overlay',
  'first-run-wizard-overlay',
];
const _modalFocusableSelector = [
  'button:not([disabled])',
  'a[href]',
  'input:not([type="hidden"]):not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
].join(',');

function _getOpenOverlays() {
  return _modalOverlayIds
    .map(id => document.getElementById(id))
    .filter(el => !!el && !el.classList.contains('hidden'));
}

function _getTopOpenOverlay() {
  const open = _getOpenOverlays();
  return open.length ? open[open.length - 1] : null;
}

function _getFocusableInOverlay(overlay) {
  if (!overlay) return [];
  return Array.from(overlay.querySelectorAll(_modalFocusableSelector))
    .filter(el => !el.hasAttribute('disabled') && el.getAttribute('aria-hidden') !== 'true');
}

function _captureModalFocus(overlayId) {
  const active = document.activeElement;
  if (active && typeof active.focus === 'function') {
    _modalFocusReturnTargets[overlayId] = active;
  }
}

function _restoreModalFocus(overlayId) {
  const target = _modalFocusReturnTargets[overlayId];
  delete _modalFocusReturnTargets[overlayId];
  if (!target || !document.contains(target)) return;
  try {
    target.focus({ preventScroll: true });
  } catch (_err) {
    try { target.focus(); } catch (_err2) {}
  }
}

function _syncModalOpenState() {
  let anyOpen = false;
  _modalOverlayIds.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    const isOpen = !el.classList.contains('hidden');
    el.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    if (isOpen) anyOpen = true;
  });
  document.body.classList.toggle('modal-open', anyOpen);
}

function _openOverlay(overlayId, focusSelector = '') {
  const overlay = document.getElementById(overlayId);
  if (!overlay) return null;
  _captureModalFocus(overlayId);
  overlay.classList.remove('hidden');
  overlay.setAttribute('aria-hidden', 'false');
  if (!overlay.hasAttribute('tabindex')) overlay.setAttribute('tabindex', '-1');
  _syncModalOpenState();
  let focusTarget = null;
  if (focusSelector) {
    focusTarget = overlay.querySelector(focusSelector);
  }
  if (!focusTarget) {
    const focusables = _getFocusableInOverlay(overlay);
    focusTarget = focusables.length ? focusables[0] : overlay;
  }
  if (focusTarget && typeof focusTarget.focus === 'function') {
    try {
      focusTarget.focus({ preventScroll: true });
    } catch (_err) {
      focusTarget.focus();
    }
  }
  return overlay;
}

function applyProgramNameLabels() {
  const label = String(PROGRAM_DISPLAY_NAME || '').trim() || 'this program';
  document.querySelectorAll('.program-name-slot').forEach(el => {
    el.textContent = label;
  });
}

function setGitSyncDrawerOpen(open, opts = {}) {
  const drawer = document.getElementById('git-sync-drawer');
  const panel = document.getElementById('git-sync-controls');
  const toggle = document.getElementById('git-sync-drawer-toggle');
  if (!drawer || !panel || !toggle) return;

  const isOpen = !!open;
  const shouldPersist = opts.persist !== false;
  drawer.classList.toggle('open', isOpen);
  panel.hidden = !isOpen;
  toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

  if (shouldPersist && typeof localStorage !== 'undefined') {
    localStorage.setItem(GIT_SYNC_DRAWER_STORAGE_KEY, isOpen ? '1' : '0');
  }
}

function toggleGitSyncDrawer(forceOpen) {
  const drawer = document.getElementById('git-sync-drawer');
  if (!drawer) return;
  const currentOpen = drawer.classList.contains('open');
  const nextOpen = typeof forceOpen === 'boolean' ? forceOpen : !currentOpen;
  setGitSyncDrawerOpen(nextOpen);
}

function initGitSyncDrawer() {
  const savedOpen = typeof localStorage !== 'undefined'
    && localStorage.getItem(GIT_SYNC_DRAWER_STORAGE_KEY) === '1';
  setGitSyncDrawerOpen(!!savedOpen, { persist: false });

  if (document.body && !document.body.dataset.gitSyncDrawerBound) {
    document.body.dataset.gitSyncDrawerBound = '1';
    document.addEventListener('click', (event) => {
      const drawer = document.getElementById('git-sync-drawer');
      if (!drawer || !drawer.classList.contains('open')) return;
      if (drawer.contains(event.target)) return;
      setGitSyncDrawerOpen(false);
    });
  }
}

function _closeOverlay(overlayId) {
  const overlay = document.getElementById(overlayId);
  if (!overlay) return null;
  overlay.classList.add('hidden');
  overlay.setAttribute('aria-hidden', 'true');
  _syncModalOpenState();
  _restoreModalFocus(overlayId);
  return overlay;
}

function _closeTopOverlay() {
  const overlay = _getTopOpenOverlay();
  if (!overlay) return false;
  const overlayId = overlay.id;
  if (overlayId === 'run-plan-overlay') {
    closeRunPlanModal({ action: 'cancel' });
    return true;
  }
  if (overlayId === 'readonly-warning-overlay') {
    closeReadOnlyWarningModal('cancel');
    return true;
  }
  if (overlayId === 'docs-overlay') {
    closeDocsModal();
    return true;
  }
  if (overlayId === 'permissions-help-overlay') {
    closePermissionsHelpModal();
    return true;
  }
  if (overlayId === 'science-dashboard-overlay') {
    closeScienceDashboardModal();
    return true;
  }
  if (overlayId === 'browse-overlay') {
    browseClose();
    return true;
  }
  if (overlayId === 'first-run-wizard-overlay') {
    closeFirstRunWizard();
    return true;
  }
  if (overlayId === 'new-project-overlay') {
    hideNewProjectModal();
    return true;
  }
  if (overlayId === 'clone-repo-overlay') {
    hideCloneRepoModal();
    return true;
  }
  if (overlayId === 'git-remote-overlay') {
    hideGitRemoteModal();
    return true;
  }
  if (overlayId === 'git-commit-overlay') {
    hideGitCommitModal();
    return true;
  }
  if (overlayId === 'api-keys-overlay') {
    hideApiKeysModal();
    return true;
  }
  if (overlayId === 'github-auth-overlay') {
    hideGithubAuthModal();
    return true;
  }
  if (overlayId === 'todo-wishlist-overlay') {
    hideTodoWishlistModal();
    return true;
  }
  if (overlayId === 'feature-dreams-overlay') {
    hideFeatureDreamsModal();
    return true;
  }
  if (overlayId === 'general-request-overlay') {
    hideGeneralRequestModal();
    return true;
  }
  if (overlayId === 'about-overlay') {
    hideAboutModal();
    return true;
  }
  if (overlayId === 'onboarding-overlay') {
    _closeOverlay('onboarding-overlay');
    return true;
  }
  _closeOverlay(overlayId);
  return true;
}

function _trapFocusInOverlay(event) {
  if (event.key !== 'Tab') return;
  const overlay = _getTopOpenOverlay();
  if (!overlay) return;
  const focusables = _getFocusableInOverlay(overlay);
  if (!focusables.length) {
    event.preventDefault();
    overlay.focus();
    return;
  }
  const first = focusables[0];
  const last = focusables[focusables.length - 1];
  const active = document.activeElement;
  const activeInside = overlay.contains(active);
  if (event.shiftKey) {
    if (!activeInside || active === first) {
      event.preventDefault();
      last.focus();
    }
    return;
  }
  if (!activeInside || active === last) {
    event.preventDefault();
    first.focus();
  }
}

function normalizeCodexPermissions(cfg) {
  if (!VALID_CODEX_SANDBOX_MODES.includes(cfg.codex_sandbox_mode)) {
    cfg.codex_sandbox_mode = 'workspace-write';
  }
  if (!VALID_CODEX_APPROVAL_POLICIES.includes(cfg.codex_approval_policy)) {
    cfg.codex_approval_policy = 'never';
  }
  if (!VALID_CODEX_REASONING_EFFORTS.includes(cfg.codex_reasoning_effort)) {
    cfg.codex_reasoning_effort = 'xhigh';
  }
  cfg.codex_bypass_approvals_and_sandbox = !!cfg.codex_bypass_approvals_and_sandbox;
  cfg.codex_danger_confirmation = '';
}

function normalizeCapabilitySettings(cfg) {
  cfg.allow_path_creation = cfg.allow_path_creation !== false;
  const depPolicy = String(cfg.dependency_install_policy || 'project_only').trim().toLowerCase();
  cfg.dependency_install_policy = VALID_DEPENDENCY_INSTALL_POLICIES.includes(depPolicy)
    ? depPolicy
    : 'project_only';

  cfg.image_generation_enabled = !!cfg.image_generation_enabled;
  const provider = String(cfg.image_provider || 'openai').trim().toLowerCase();
  cfg.image_provider = VALID_IMAGE_PROVIDERS.includes(provider) ? provider : 'openai';
  cfg.image_model = String(cfg.image_model || '').trim();
  if (!cfg.image_model) cfg.image_model = DEFAULT_IMAGE_MODEL_BY_PROVIDER[cfg.image_provider];

  cfg.vector_memory_enabled = !!cfg.vector_memory_enabled;
  cfg.vector_memory_backend = String(cfg.vector_memory_backend || 'chroma').trim().toLowerCase();
  if (cfg.vector_memory_backend !== 'chroma') cfg.vector_memory_backend = 'chroma';
  cfg.vector_memory_collection = String(cfg.vector_memory_collection || '').trim();
  cfg.vector_memory_top_k = Math.min(30, Math.max(1, parseInt(cfg.vector_memory_top_k, 10) || 8));

  cfg.deep_research_enabled = !!cfg.deep_research_enabled;
  const providers = String(cfg.deep_research_providers || 'both').trim().toLowerCase();
  cfg.deep_research_providers = ['openai', 'google', 'both'].includes(providers) ? providers : 'both';
  cfg.deep_research_max_age_hours = Math.min(
    8760,
    Math.max(1, parseInt(cfg.deep_research_max_age_hours, 10) || 168),
  );
  cfg.deep_research_dedupe = cfg.deep_research_dedupe !== false;
  cfg.deep_research_native_enabled = !!cfg.deep_research_native_enabled;
  cfg.deep_research_retry_attempts = Math.min(
    6,
    Math.max(1, parseInt(cfg.deep_research_retry_attempts, 10) || 2),
  );
  cfg.deep_research_daily_quota = Math.min(
    100,
    Math.max(1, parseInt(cfg.deep_research_daily_quota, 10) || 8),
  );
  cfg.deep_research_max_provider_tokens = Math.min(
    64000,
    Math.max(512, parseInt(cfg.deep_research_max_provider_tokens, 10) || 12000),
  );
  cfg.deep_research_budget_usd = Math.max(0, parseFloat(cfg.deep_research_budget_usd) || 5.0);
  cfg.deep_research_openai_model = String(cfg.deep_research_openai_model || 'gpt-5.2').trim() || 'gpt-5.2';
  cfg.deep_research_google_model = String(cfg.deep_research_google_model || 'gemini-3-pro-preview').trim() || 'gemini-3-pro-preview';
}

function syncChainCapabilityControlsFromConfig() {
  normalizeCapabilitySettings(config);
  document.getElementById('chain-allow-path-creation').checked = !!config.allow_path_creation;
  document.getElementById('chain-dependency-install-policy').value = config.dependency_install_policy;
  document.getElementById('chain-image-generation-enabled').checked = !!config.image_generation_enabled;
  document.getElementById('chain-image-provider').value = config.image_provider;
  document.getElementById('chain-image-model').value = config.image_model || DEFAULT_IMAGE_MODEL_BY_PROVIDER[config.image_provider];
  document.getElementById('chain-vector-memory-enabled').checked = !!config.vector_memory_enabled;
  document.getElementById('chain-vector-memory-backend').value = config.vector_memory_backend || 'chroma';
  document.getElementById('chain-vector-memory-collection').value = config.vector_memory_collection || '';
  document.getElementById('chain-vector-memory-top-k').value = config.vector_memory_top_k || 8;
  toggleChainImageOptions(false);
  toggleChainVectorMemory(false);
}

function syncPipelineCapabilityControlsFromConfig() {
  normalizeCapabilitySettings(pipeConfig);
  document.getElementById('pipe-allow-path-creation').checked = !!pipeConfig.allow_path_creation;
  document.getElementById('pipe-dependency-install-policy').value = pipeConfig.dependency_install_policy;
  document.getElementById('pipe-image-generation-enabled').checked = !!pipeConfig.image_generation_enabled;
  document.getElementById('pipe-image-provider').value = pipeConfig.image_provider;
  document.getElementById('pipe-image-model').value = pipeConfig.image_model || DEFAULT_IMAGE_MODEL_BY_PROVIDER[pipeConfig.image_provider];
  document.getElementById('pipe-vector-memory-enabled').checked = !!pipeConfig.vector_memory_enabled;
  document.getElementById('pipe-vector-memory-backend').value = pipeConfig.vector_memory_backend || 'chroma';
  document.getElementById('pipe-vector-memory-collection').value = pipeConfig.vector_memory_collection || '';
  document.getElementById('pipe-vector-memory-top-k').value = pipeConfig.vector_memory_top_k || 8;
  document.getElementById('pipe-deep-research-enabled').checked = !!pipeConfig.deep_research_enabled;
  document.getElementById('pipe-deep-research-providers').value = pipeConfig.deep_research_providers || 'both';
  document.getElementById('pipe-deep-research-max-age-hours').value = pipeConfig.deep_research_max_age_hours || 168;
  document.getElementById('pipe-deep-research-dedupe').checked = pipeConfig.deep_research_dedupe !== false;
  document.getElementById('pipe-deep-research-native-enabled').checked = !!pipeConfig.deep_research_native_enabled;
  document.getElementById('pipe-deep-research-retry-attempts').value = pipeConfig.deep_research_retry_attempts || 2;
  document.getElementById('pipe-deep-research-daily-quota').value = pipeConfig.deep_research_daily_quota || 8;
  document.getElementById('pipe-deep-research-max-provider-tokens').value = pipeConfig.deep_research_max_provider_tokens || 12000;
  document.getElementById('pipe-deep-research-budget-usd').value = pipeConfig.deep_research_budget_usd || 5.0;
  document.getElementById('pipe-deep-research-openai-model').value = pipeConfig.deep_research_openai_model || 'gpt-5.2';
  document.getElementById('pipe-deep-research-google-model').value = pipeConfig.deep_research_google_model || 'gemini-3-pro-preview';
  document.getElementById('pipe-self-improvement-enabled').checked = !!pipeConfig.self_improvement_enabled;
  document.getElementById('pipe-self-improvement-auto-restart').checked = !!pipeConfig.self_improvement_auto_restart;
  document.getElementById('pipe-self-improvement-auto-restart').disabled = !pipeConfig.self_improvement_enabled;
  togglePipeImageOptions(false);
  togglePipeVectorMemory(false);
  togglePipeDeepResearch(false);
}

function toggleChainImageOptions(syncConfig = true) {
  const enabled = document.getElementById('chain-image-generation-enabled').checked;
  document.getElementById('chain-image-options').style.display = enabled ? '' : 'none';
  if (syncConfig) {
    config.image_generation_enabled = enabled;
    normalizeCapabilitySettings(config);
  }
}

function onChainImageProviderChanged() {
  const provider = document.getElementById('chain-image-provider').value;
  config.image_provider = provider;
  const modelInput = document.getElementById('chain-image-model');
  if (!String(modelInput.value || '').trim()) {
    modelInput.value = DEFAULT_IMAGE_MODEL_BY_PROVIDER[provider] || 'gpt-image-1';
  }
  config.image_model = modelInput.value.trim();
  normalizeCapabilitySettings(config);
}

function toggleChainVectorMemory(syncConfig = true) {
  const enabled = document.getElementById('chain-vector-memory-enabled').checked;
  const panel = document.getElementById('chain-vector-memory-options');
  panel.classList.toggle('hidden', !enabled);
  if (syncConfig) {
    config.vector_memory_enabled = enabled;
    normalizeCapabilitySettings(config);
  }
}

function togglePipeImageOptions(syncConfig = true) {
  const enabled = document.getElementById('pipe-image-generation-enabled').checked;
  document.getElementById('pipe-image-options').style.display = enabled ? '' : 'none';
  if (syncConfig) {
    pipeConfig.image_generation_enabled = enabled;
    normalizeCapabilitySettings(pipeConfig);
  }
}

function onPipeImageProviderChanged() {
  const provider = document.getElementById('pipe-image-provider').value;
  pipeConfig.image_provider = provider;
  const modelInput = document.getElementById('pipe-image-model');
  if (!String(modelInput.value || '').trim()) {
    modelInput.value = DEFAULT_IMAGE_MODEL_BY_PROVIDER[provider] || 'gpt-image-1';
  }
  pipeConfig.image_model = modelInput.value.trim();
  normalizeCapabilitySettings(pipeConfig);
}

function togglePipeVectorMemory(syncConfig = true) {
  const enabled = document.getElementById('pipe-vector-memory-enabled').checked;
  const panel = document.getElementById('pipe-vector-memory-options');
  panel.classList.toggle('hidden', !enabled);
  if (syncConfig) {
    pipeConfig.vector_memory_enabled = enabled;
    normalizeCapabilitySettings(pipeConfig);
  }
}

function togglePipeDeepResearch(syncConfig = true) {
  const enabled = document.getElementById('pipe-deep-research-enabled').checked;
  const panel = document.getElementById('pipe-deep-research-options');
  panel.classList.toggle('hidden', !enabled);
  if (syncConfig) {
    pipeConfig.deep_research_enabled = enabled;
    normalizeCapabilitySettings(pipeConfig);
  }
  renderPipelinePhases();
}

function _normalizeDomainCsv(value) {
  const tokens = String(value || '')
    .toLowerCase()
    .split(/[\s,;]+/)
    .map(chunk => chunk.trim().replace(/^\./, ''))
    .filter(Boolean);
  return Array.from(new Set(tokens)).join(',');
}

function _setGovernancePolicyStatus(text, tone = 'muted') {
  const el = document.getElementById('pipe-governance-policy-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') el.style.color = 'var(--success)';
  else if (tone === 'warn') el.style.color = 'var(--warning)';
  else if (tone === 'error') el.style.color = 'var(--danger)';
  else el.style.color = 'var(--text2)';
}

function _applyGovernancePolicyToUi(policy) {
  const payload = policy || {};
  const map = {
    research_allowed_domains: 'pipe-governance-research-allowed',
    research_blocked_domains: 'pipe-governance-research-blocked',
    deep_research_allowed_domains: 'pipe-governance-deep-allowed',
    deep_research_blocked_domains: 'pipe-governance-deep-blocked',
  };
  Object.keys(map).forEach(key => {
    const el = document.getElementById(map[key]);
    if (!el) return;
    el.value = _normalizeDomainCsv(payload[key] || '');
  });
}

function _readGovernancePolicyFromUi() {
  return {
    research_allowed_domains: _normalizeDomainCsv(document.getElementById('pipe-governance-research-allowed').value),
    research_blocked_domains: _normalizeDomainCsv(document.getElementById('pipe-governance-research-blocked').value),
    deep_research_allowed_domains: _normalizeDomainCsv(document.getElementById('pipe-governance-deep-allowed').value),
    deep_research_blocked_domains: _normalizeDomainCsv(document.getElementById('pipe-governance-deep-blocked').value),
  };
}

async function loadGovernancePolicy(opts = {}) {
  try {
    const resp = await api('/api/governance/source-policy');
    if (resp.error) throw new Error(resp.error);
    _applyGovernancePolicyToUi(resp);
    if (!opts.silent) {
      _setGovernancePolicyStatus('Governance policy loaded.', 'ok');
    } else {
      _setGovernancePolicyStatus('Governance policy loaded from server.', 'muted');
    }
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setGovernancePolicyStatus('Could not load policy: ' + message, 'error');
    if (!opts.silent) {
      toast('Could not load governance policy: ' + message, 'error');
    }
  }
}

async function saveGovernancePolicy() {
  const payload = _readGovernancePolicyFromUi();
  try {
    const resp = await postJson('/api/governance/source-policy', payload);
    if (resp.error) throw new Error(resp.error);
    const saved = (resp && resp.policy) ? resp.policy : payload;
    _applyGovernancePolicyToUi(saved);
    _setGovernancePolicyStatus('Governance policy saved.', 'ok');
    toast('Governance source policy saved', 'success');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setGovernancePolicyStatus('Could not save policy: ' + message, 'error');
    toast('Could not save governance policy: ' + message, 'error');
  }
}

function _setApiKeysStatus(text, tone = 'muted') {
  const el = document.getElementById('api-keys-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') el.style.color = 'var(--success)';
  else if (tone === 'warn') el.style.color = 'var(--warning)';
  else if (tone === 'error') el.style.color = 'var(--danger)';
  else el.style.color = 'var(--text2)';
}

function _apiKeyFieldId(envVar, kind) {
  const slug = String(envVar || '').replace(/[^A-Za-z0-9_]/g, '_');
  return 'api-key-' + kind + '-' + slug;
}

function _apiKeysMetaText(state) {
  const payload = state || {};
  const storage = payload.secure_storage_available
    ? ('Secure storage: available (' + String(payload.storage_backend || 'keyring') + ')')
    : ('Secure storage: unavailable'
      + (payload.storage_error ? (' - ' + String(payload.storage_error)) : ''));
  const rows = Array.isArray(payload.supported_keys) ? payload.supported_keys : [];
  const savedCount = rows.filter(item => !!(item && item.saved)).length;
  const envCount = rows.filter(item => !!(item && item.in_environment)).length;
  const summary = 'Saved keys: ' + savedCount + '/' + rows.length + ', loaded in session: ' + envCount + '/' + rows.length;
  return [storage, summary].join('\n');
}

function _renderApiKeysFields(state) {
  const fieldsEl = document.getElementById('api-keys-fields');
  const metaEl = document.getElementById('api-keys-meta');
  if (!fieldsEl) return;
  const payload = state || {};
  if (metaEl) metaEl.textContent = _apiKeysMetaText(payload);
  const rows = Array.isArray(payload.supported_keys) ? payload.supported_keys : [];
  if (!rows.length) {
    fieldsEl.innerHTML = '<div class="state-card">No supported API key fields are configured.</div>';
    return;
  }
  fieldsEl.innerHTML = rows.map((rawItem) => {
    const item = rawItem && typeof rawItem === 'object' ? rawItem : {};
    const envVar = String(item.env_var || '').trim();
    const provider = String(item.provider || '').trim();
    const description = String(item.description || '').trim();
    const saved = !!item.saved;
    const inEnv = !!item.in_environment;
    const inputId = _apiKeyFieldId(envVar, 'input');
    const clearId = _apiKeyFieldId(envVar, 'clear');
    const savedText = saved ? 'Saved in secure storage.' : 'Not saved in secure storage.';
    const envText = inEnv ? 'Loaded in current GUI session.' : 'Not loaded in current GUI session.';
    return ''
      + '<div class="field">'
      + '<label for="' + escAttr(inputId) + '"><code>' + esc(envVar) + '</code>'
      + (provider ? (' <span style="color:var(--text2)">(' + esc(provider) + ')</span>') : '')
      + '</label>'
      + '<input type="password" id="' + escAttr(inputId) + '" autocomplete="off" placeholder="Enter key to update">'
      + (description ? ('<div class="field-help">' + esc(description) + '</div>') : '')
      + '<div class="field-help">' + esc(savedText + ' ' + envText) + '</div>'
      + '<label style="margin-top:6px"><input type="checkbox" id="' + escAttr(clearId) + '"' + (saved ? '' : ' disabled') + '> Remove saved key</label>'
      + '</div>';
  }).join('');

  rows.forEach((rawItem) => {
    const item = rawItem && typeof rawItem === 'object' ? rawItem : {};
    const envVar = String(item.env_var || '').trim();
    if (!envVar) return;
    const inputEl = document.getElementById(_apiKeyFieldId(envVar, 'input'));
    const clearEl = document.getElementById(_apiKeyFieldId(envVar, 'clear'));
    if (!inputEl || !clearEl) return;
    inputEl.addEventListener('input', () => {
      if (String(inputEl.value || '').trim()) clearEl.checked = false;
    });
  });
}

async function loadApiKeysState(opts = {}) {
  try {
    const resp = await api('/api/api-keys');
    if (resp.error) throw new Error(resp.error);
    apiKeysState = resp || {};
    _renderApiKeysFields(apiKeysState);
    if (!opts.silent) _setApiKeysStatus('API key settings loaded.', 'ok');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setApiKeysStatus('Could not load API key settings: ' + message, 'error');
    if (!opts.silent) toast('Could not load API key settings: ' + message, 'error');
  }
}

function showApiKeysModal() {
  _openOverlay('api-keys-overlay', '#api-keys-overlay .btn-primary');
  _setApiKeysStatus('');
  loadApiKeysState({ silent: true });
}

function hideApiKeysModal() {
  _closeOverlay('api-keys-overlay');
}

async function saveApiKeysState() {
  const rows = Array.isArray(apiKeysState && apiKeysState.supported_keys)
    ? apiKeysState.supported_keys
    : [];
  const payload = { keys: {}, clear_keys: [] };

  rows.forEach((rawItem) => {
    const item = rawItem && typeof rawItem === 'object' ? rawItem : {};
    const envVar = String(item.env_var || '').trim();
    if (!envVar) return;
    const inputEl = document.getElementById(_apiKeyFieldId(envVar, 'input'));
    const clearEl = document.getElementById(_apiKeyFieldId(envVar, 'clear'));
    const value = String(inputEl ? inputEl.value : '').trim();
    const clear = !!(clearEl && clearEl.checked);
    if (value) payload.keys[envVar] = value;
    else if (clear) payload.clear_keys.push(envVar);
  });

  if (!Object.keys(payload.keys).length && !payload.clear_keys.length) {
    _setApiKeysStatus('No key updates selected.', 'warn');
    return;
  }

  try {
    const resp = await postJson('/api/api-keys', payload);
    if (resp.error) throw new Error(resp.error);
    apiKeysState = (resp && resp.settings) ? resp.settings : null;
    _renderApiKeysFields(apiKeysState || {});
    _setApiKeysStatus('API key settings saved.', 'ok');
    toast('API key settings saved.', 'success');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setApiKeysStatus('Could not save API key settings: ' + message, 'error');
    toast('Could not save API key settings: ' + message, 'error');
  }
}

function _setGithubAuthStatus(text, tone = 'muted') {
  const el = document.getElementById('github-auth-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') el.style.color = 'var(--success)';
  else if (tone === 'warn') el.style.color = 'var(--warning)';
  else if (tone === 'error') el.style.color = 'var(--danger)';
  else el.style.color = 'var(--text2)';
}

function _githubTroubleshootingStatusLabel(status) {
  if (status === 'ok') return 'OK';
  if (status === 'action_required') return 'Action required';
  return 'Review';
}

function _setGithubAuthTroubleshooting(payload) {
  const container = document.getElementById('github-auth-troubleshooting');
  if (!container) return;
  const data = payload && typeof payload === 'object' ? payload : null;
  githubAuthTroubleshooting = data;
  if (!data || data.available === false) {
    container.classList.add('hidden');
    container.innerHTML = '';
    return;
  }
  const title = String(data.title || 'Credential Troubleshooting Assistant').trim();
  const summary = String(data.summary || '').trim();
  const checks = Array.isArray(data.checks) ? data.checks : [];
  const nextSteps = Array.isArray(data.next_steps) ? data.next_steps : [];

  const checksHtml = checks.length
    ? ('<ul>'
      + checks.map((rawCheck) => {
        const check = rawCheck && typeof rawCheck === 'object' ? rawCheck : {};
        const label = String(check.label || check.key || 'Check').trim() || 'Check';
        const statusRaw = String(check.status || 'review').trim().toLowerCase();
        const status = ['ok', 'action_required', 'review'].includes(statusRaw) ? statusRaw : 'review';
        const detail = String(check.detail || '').trim();
        const commands = Array.isArray(check.commands) ? check.commands : [];
        const commandsHtml = commands.length
          ? ('<div class="commands"><strong>Try:</strong>'
            + commands.map((command) => '<code>' + esc(String(command || '')) + '</code>').join('')
            + '</div>')
          : '';
        return ''
          + '<li>'
          + '<div class="check-title"><span class="status-badge status-' + escAttr(status) + '">'
          + esc(_githubTroubleshootingStatusLabel(status))
          + '</span><span>' + esc(label) + '</span></div>'
          + (detail ? ('<div class="check-detail">' + esc(detail) + '</div>') : '')
          + commandsHtml
          + '</li>';
      }).join('')
      + '</ul>')
    : '<div class="summary">No targeted checks were returned for this failure.</div>';

  const nextStepsHtml = nextSteps.length
    ? ('<div class="next-steps"><strong>Recommended next steps</strong><ol>'
      + nextSteps.map((step) => '<li>' + esc(String(step || '')) + '</li>').join('')
      + '</ol></div>')
    : '';

  container.classList.remove('hidden');
  container.innerHTML = ''
    + '<h3>' + esc(title) + '</h3>'
    + (summary ? ('<div class="summary">' + esc(summary) + '</div>') : '')
    + checksHtml
    + nextStepsHtml;
}

function _githubAuthMetaText(state) {
  const payload = state || {};
  const storage = payload.secure_storage_available
    ? ('Secure storage: available (' + String(payload.storage_backend || 'keyring') + ')')
    : ('Secure storage: unavailable'
      + (payload.storage_error ? (' - ' + String(payload.storage_error)) : ''));
  const saved = 'Saved credentials: PAT='
    + (payload.has_pat ? 'yes' : 'no')
    + ', SSH key='
    + (payload.has_ssh_key ? 'yes' : 'no');
  const updated = payload.updated_at
    ? ('Last updated: ' + String(payload.updated_at))
    : 'Last updated: never';
  const tested = payload.last_test_at
    ? ('Last test: ' + String(payload.last_test_at) + ' ('
      + (payload.last_test_ok ? 'ok' : 'failed') + ')')
    : 'Last test: none';
  return [storage, saved, updated, tested].join('\n');
}

function syncGithubAuthForm() {
  const methodEl = document.getElementById('github-auth-method');
  const detailsEl = document.getElementById('github-auth-ssh-details');
  if (!methodEl || !detailsEl) return;
  const usingSsh = String(methodEl.value || '').toLowerCase() === 'ssh';
  if (usingSsh) detailsEl.open = true;
}

async function loadGithubAuthSettings(opts = {}) {
  try {
    const resp = await api('/api/github/auth');
    if (resp.error) throw new Error(resp.error);
    githubAuthState = resp || {};
    const methodEl = document.getElementById('github-auth-method');
    const patEl = document.getElementById('github-auth-pat');
    const sshEl = document.getElementById('github-auth-ssh-key');
    const clearPat = document.getElementById('github-auth-clear-pat');
    const clearSsh = document.getElementById('github-auth-clear-ssh');
    const metaEl = document.getElementById('github-auth-meta');
    if (methodEl) {
      methodEl.value = String(githubAuthState.preferred_auth || 'https');
    }
    if (patEl) patEl.value = '';
    if (sshEl) sshEl.value = '';
    if (clearPat) clearPat.checked = false;
    if (clearSsh) clearSsh.checked = false;
    if (metaEl) metaEl.textContent = _githubAuthMetaText(githubAuthState);
    if (!opts.preserveTroubleshooting) _setGithubAuthTroubleshooting(null);
    syncGithubAuthForm();
    if (!opts.silent) _setGithubAuthStatus('GitHub auth settings loaded.', 'ok');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setGithubAuthStatus('Could not load GitHub auth settings: ' + message, 'error');
    if (!opts.silent) toast('Could not load GitHub auth settings: ' + message, 'error');
  }
}

function showGithubAuthModal() {
  _openOverlay('github-auth-overlay', '#github-auth-method');
  _setGithubAuthStatus('');
  _setGithubAuthTroubleshooting(githubAuthTroubleshooting);
  loadGithubAuthSettings({ silent: true, preserveTroubleshooting: true });
}

function hideGithubAuthModal() {
  _closeOverlay('github-auth-overlay');
}

async function saveGithubAuthSettings() {
  const methodEl = document.getElementById('github-auth-method');
  const patEl = document.getElementById('github-auth-pat');
  const sshEl = document.getElementById('github-auth-ssh-key');
  const clearPat = document.getElementById('github-auth-clear-pat');
  const clearSsh = document.getElementById('github-auth-clear-ssh');
  const payload = {
    preferred_auth: String(methodEl ? methodEl.value : 'https') || 'https',
    pat: String(patEl ? patEl.value : ''),
    ssh_private_key: String(sshEl ? sshEl.value : ''),
    clear_pat: !!(clearPat && clearPat.checked),
    clear_ssh_key: !!(clearSsh && clearSsh.checked),
  };
  if (String(payload.pat || '').trim()) payload.clear_pat = false;
  if (String(payload.ssh_private_key || '').trim()) payload.clear_ssh_key = false;

  try {
    const resp = await postJson('/api/github/auth', payload);
    if (resp.error) throw new Error(resp.error);
    if (patEl) patEl.value = '';
    if (sshEl) sshEl.value = '';
    if (clearPat) clearPat.checked = false;
    if (clearSsh) clearSsh.checked = false;
    githubAuthState = (resp && resp.settings) ? resp.settings : null;
    const metaEl = document.getElementById('github-auth-meta');
    if (metaEl && githubAuthState) metaEl.textContent = _githubAuthMetaText(githubAuthState);
    _setGithubAuthTroubleshooting(null);
    _setGithubAuthStatus('GitHub auth settings saved.', 'ok');
    toast('GitHub auth settings saved.', 'success');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setGithubAuthStatus('Could not save GitHub auth settings: ' + message, 'error');
    toast('Could not save GitHub auth settings: ' + message, 'error');
  }
}

async function testGithubAuthConnection() {
  const methodEl = document.getElementById('github-auth-method');
  const patEl = document.getElementById('github-auth-pat');
  const sshEl = document.getElementById('github-auth-ssh-key');
  const payload = {
    auth_method: String(methodEl ? methodEl.value : 'https') || 'https',
    use_saved: true,
  };
  if (patEl && String(patEl.value || '').trim()) payload.pat = String(patEl.value || '');
  if (sshEl && String(sshEl.value || '').trim()) payload.ssh_private_key = String(sshEl.value || '');

  _setGithubAuthStatus('Testing GitHub connection...', 'muted');
  try {
    const resp = await postJson('/api/github/auth/test', payload);
    const message = String((resp && (resp.message || resp.error)) || 'No response details.');
    _setGithubAuthTroubleshooting((resp && resp.troubleshooting) ? resp.troubleshooting : null);
    if (resp && resp.ok) {
      _setGithubAuthStatus(message, 'ok');
      toast('GitHub connection test passed.', 'success');
    } else {
      _setGithubAuthStatus(message, 'error');
      toast('GitHub connection test failed: ' + message, 'error');
    }
    await loadGithubAuthSettings({ silent: true, preserveTroubleshooting: true });
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    _setGithubAuthStatus('GitHub connection test failed: ' + message, 'error');
    toast('GitHub connection test failed: ' + message, 'error');
  }
}

function togglePipeSelfImprovement() {
  const enabled = document.getElementById('pipe-self-improvement-enabled').checked;
  pipeConfig.self_improvement_enabled = enabled;
  const autoRestartEl = document.getElementById('pipe-self-improvement-auto-restart');
  autoRestartEl.disabled = !enabled;
  if (!enabled) autoRestartEl.checked = false;
  pipeConfig.self_improvement_auto_restart = !!autoRestartEl.checked;
  renderPipelinePhases();
}

function _permissionProfileFromConfig(cfg) {
  if (cfg.codex_bypass_approvals_and_sandbox) return 'full_access';
  if (cfg.codex_sandbox_mode === 'read-only') return 'readonly';
  if (
    cfg.codex_sandbox_mode === 'workspace-write'
    && cfg.codex_approval_policy === 'never'
    && !cfg.codex_bypass_approvals_and_sandbox
  ) return 'safe';
  return 'custom';
}

function _applyPermissionProfile(cfg, profile) {
  if (profile === 'readonly') {
    cfg.codex_sandbox_mode = 'read-only';
    cfg.codex_approval_policy = 'never';
    cfg.codex_bypass_approvals_and_sandbox = false;
  } else if (profile === 'full_access') {
    cfg.codex_sandbox_mode = 'danger-full-access';
    cfg.codex_approval_policy = 'never';
    cfg.codex_bypass_approvals_and_sandbox = true;
  } else if (profile === 'safe') {
    cfg.codex_sandbox_mode = 'workspace-write';
    cfg.codex_approval_policy = 'never';
    cfg.codex_bypass_approvals_and_sandbox = false;
  }
  cfg.codex_danger_confirmation = '';
}

function _permissionUiRefs(target) {
  const isPipe = target === 'pipeline';
  return {
    cfg: isPipe ? pipeConfig : config,
    profile: document.getElementById(isPipe ? 'pipe-codex-permission-profile' : 'codex-permission-profile'),
    summary: document.getElementById(isPipe ? 'pipe-codex-permission-summary' : 'codex-permission-summary'),
    warning: document.getElementById(isPipe ? 'pipe-codex-permission-warning' : 'codex-permission-warning'),
    manual: document.getElementById(isPipe ? 'pipe-codex-perm-manual' : 'codex-perm-manual'),
    sandbox: document.getElementById(isPipe ? 'pipe-codex-sandbox-mode' : 'codex-sandbox-mode'),
    approval: document.getElementById(isPipe ? 'pipe-codex-approval-policy' : 'codex-approval-policy'),
    bypass: document.getElementById(isPipe ? 'pipe-codex-bypass-approvals' : 'codex-bypass-approvals'),
  };
}

function resetPermissionProfileUiState(target) {
  _permissionProfileUiState[target === 'pipeline' ? 'pipeline' : 'chain'] = null;
}

function updatePermissionUi(target) {
  const refs = _permissionUiRefs(target);
  const inferred = _permissionProfileFromConfig(refs.cfg);
  const sticky = _permissionProfileUiState[target];
  const profile = sticky === 'custom' ? 'custom' : inferred;
  if (sticky !== 'custom') _permissionProfileUiState[target] = inferred;
  if (refs.profile) refs.profile.value = profile;
  if (refs.summary) {
    if (profile === 'custom' && inferred !== 'custom') {
      refs.summary.textContent = 'Custom profile selected. Current values match '
        + PERMISSION_PROFILE_LABEL[inferred] + '.';
    } else {
      refs.summary.textContent = PERMISSION_PROFILE_SUMMARY[profile];
    }
  }
  if (refs.warning) {
    const bypassRisk = refs.cfg.codex_bypass_approvals_and_sandbox;
    const sandboxRisk = refs.cfg.codex_sandbox_mode === 'danger-full-access';
    const risky = bypassRisk || sandboxRisk;
    refs.warning.textContent = bypassRisk
      ? 'Full access bypasses sandbox and approval checks. Use only with trusted local repositories.'
      : 'Danger sandbox mode enables broad local access. Use only with trusted local repositories.';
    refs.warning.classList.toggle('hidden', !risky);
  }
}

function syncChainPermissionControlsFromConfig() {
  document.getElementById('codex-sandbox-mode').value = config.codex_sandbox_mode || 'workspace-write';
  document.getElementById('codex-approval-policy').value = config.codex_approval_policy || 'never';
  document.getElementById('codex-reasoning-effort').value = config.codex_reasoning_effort || 'xhigh';
  document.getElementById('codex-bypass-approvals').checked = !!config.codex_bypass_approvals_and_sandbox;
  updatePermissionUi('chain');
}

function syncPipelinePermissionControlsFromConfig() {
  document.getElementById('pipe-codex-sandbox-mode').value = pipeConfig.codex_sandbox_mode || 'workspace-write';
  document.getElementById('pipe-codex-approval-policy').value = pipeConfig.codex_approval_policy || 'never';
  document.getElementById('pipe-codex-reasoning-effort').value = pipeConfig.codex_reasoning_effort || 'xhigh';
  document.getElementById('pipe-codex-bypass-approvals').checked = !!pipeConfig.codex_bypass_approvals_and_sandbox;
  updatePermissionUi('pipeline');
}

function setPermissionProfile(target, profile) {
  const refs = _permissionUiRefs(target);
  if (profile === 'custom') {
    _permissionProfileUiState[target] = 'custom';
    if (refs.manual) refs.manual.open = true;
    updatePermissionUi(target);
    toast('Custom profile selected', 'info');
    return;
  }
  _permissionProfileUiState[target] = profile;
  _applyPermissionProfile(refs.cfg, profile);
  if (refs.manual) refs.manual.open = false;
  if (target === 'pipeline') syncPipelinePermissionControlsFromConfig();
  else syncChainPermissionControlsFromConfig();

  if (profile === 'safe') toast('Applied Recommended: Safe Repo Access', 'info');
  if (profile === 'readonly') toast('Applied Read-Only Inspect profile', 'info');
  if (profile === 'full_access') toast('Applied Trusted Repo Full Access profile', 'info');
}

function onPermissionControlChanged(target) {
  const refs = _permissionUiRefs(target);
  refs.cfg.codex_sandbox_mode = refs.sandbox.value;
  refs.cfg.codex_approval_policy = refs.approval.value;
  refs.cfg.codex_reasoning_effort = (target === 'pipeline'
    ? document.getElementById('pipe-codex-reasoning-effort')
    : document.getElementById('codex-reasoning-effort')
  ).value;
  refs.cfg.codex_bypass_approvals_and_sandbox = !!refs.bypass.checked;
  refs.cfg.codex_danger_confirmation = '';
  normalizeCodexPermissions(refs.cfg);
  _permissionProfileUiState[target] = 'custom';
  if (refs.manual) refs.manual.open = true;
  if (target === 'pipeline') syncPipelinePermissionControlsFromConfig();
  else syncChainPermissionControlsFromConfig();
}

function openPermissionsHelpModal() {
  _openOverlay('permissions-help-overlay', '.permissions-help-header .btn');
}

function closePermissionsHelpModal() {
  _closeOverlay('permissions-help-overlay');
}

function closeDocsModal() {
  _closeOverlay('docs-overlay');
}

function _setActiveDocTab(docKey) {
  document.querySelectorAll('#docs-tab-row [data-doc]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.doc === docKey);
  });
}

async function loadDoc(docKey) {
  _setActiveDocTab(docKey);
  const titleEl = document.getElementById('docs-title');
  const subtitleEl = document.getElementById('docs-subtitle');
  const contentEl = document.getElementById('docs-content');
  if (!contentEl) return;

  contentEl.textContent = 'Loading documentation...';
  if (titleEl) titleEl.textContent = 'Documentation';
  if (subtitleEl) subtitleEl.textContent = '';

  try {
    const doc = await api('/api/docs/' + docKey);
    if (doc.error) throw new Error(doc.error);
    if (titleEl) titleEl.textContent = doc.title || 'Documentation';
    if (subtitleEl) subtitleEl.textContent = doc.filename || '';
    contentEl.textContent = doc.content || '(empty)';
  } catch (e) {
    if (titleEl) titleEl.textContent = 'Documentation';
    if (subtitleEl) subtitleEl.textContent = 'Could not load document';
    contentEl.textContent = 'Could not load this guide. ' + (e && e.message ? e.message : '');
  }
}

function openDoc(docKey) {
  const overlay = _openOverlay('docs-overlay', '.docs-modal-header .btn');
  if (!overlay) return;
  loadDoc(docKey || 'quickstart');
}

function _renderAboutDocLinks(docs) {
  const host = document.getElementById('about-doc-links');
  if (!host) return;
  const rows = Array.isArray(docs) ? docs : [];
  if (!rows.length) {
    host.innerHTML = '';
    return;
  }
  host.innerHTML = rows
    .filter(item => item && item.key && item.title)
    .slice(0, 8)
    .map(item => ''
      + '<button class="btn" type="button" data-doc-key="' + escAttr(String(item.key)) + '">'
      + esc(String(item.title))
      + '</button>'
    ).join('');
  host.querySelectorAll('button[data-doc-key]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const docKey = String(btn.getAttribute('data-doc-key') || '').trim();
      if (!docKey) return;
      openDoc(docKey);
    });
  });
}

async function loadAboutModal(opts = {}) {
  const titleEl = document.getElementById('about-title');
  const subtitleEl = document.getElementById('about-subtitle');
  const metaEl = document.getElementById('about-meta');
  const readmeEl = document.getElementById('about-readme');
  if (!readmeEl) return;

  readmeEl.textContent = 'Loading README.md...';
  if (metaEl) metaEl.textContent = 'Loading About details...';

  try {
    const resp = await api('/api/about');
    if (resp.error) throw new Error(resp.error);
    aboutState = resp || {};
    const project = String(aboutState.project_display_name || PROGRAM_DISPLAY_NAME || 'WarpFoundry').trim();
    const author = String(aboutState.author || 'Matthew Felsted').trim();
    const version = String(aboutState.version || '').trim();
    const readmeFilename = String(aboutState.readme_filename || 'README.md').trim();
    if (titleEl) titleEl.textContent = 'About ' + project;
    if (subtitleEl) subtitleEl.textContent = 'Author: ' + author;
    if (metaEl) {
      const metaLines = [
        'Project: ' + project,
        (version ? ('Version: ' + version) : ''),
        'Source: ' + readmeFilename,
      ].filter(Boolean);
      metaEl.textContent = metaLines.join('\n');
    }
    readmeEl.textContent = String(aboutState.readme_content || '(empty)');
    _renderAboutDocLinks(aboutState.docs);
    if (!opts.silent) toast('About loaded', 'success');
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    if (titleEl) titleEl.textContent = 'About';
    if (subtitleEl) subtitleEl.textContent = 'Author: Matthew Felsted';
    if (metaEl) metaEl.textContent = 'Could not load About data.';
    readmeEl.textContent = 'Could not load README.md. ' + message;
    _renderAboutDocLinks([]);
    if (!opts.silent) toast('Could not load About details: ' + message, 'error');
  }
}

function showAboutModal() {
  _openOverlay('about-overlay', '#about-overlay .btn');
  loadAboutModal({ silent: true });
}

function hideAboutModal() {
  _closeOverlay('about-overlay');
}

let _runPlanResolver = null;
let _runPlanTarget = 'chain';

function _runPlanTargetLabel(target) {
  return target === 'pipeline' ? 'Pipeline' : 'Chain';
}

function updateRunPlanModalPreview() {
  const modeEl = document.getElementById('run-plan-mode');
  const profileEl = document.getElementById('run-plan-profile');
  if (!modeEl || !profileEl) return;

  const runMode = modeEl.value || 'dry-run';
  const profile = profileEl.value || 'safe';
  const modeLabel = runMode === 'apply' ? 'Apply' : 'Dry Run';
  const profileLabel = PERMISSION_PROFILE_LABEL[profile] || profile;
  const modeLine = document.getElementById('run-plan-summary-mode');
  const profileLine = document.getElementById('run-plan-summary-profile');
  const callout = document.getElementById('run-plan-summary-callout');
  const dangerWrap = document.getElementById('run-plan-danger-wrap');
  const dangerAck = document.getElementById('run-plan-danger-ack');

  if (modeLine) {
    modeLine.innerHTML = '<strong>Execution:</strong> ' + modeLabel
      + (runMode === 'dry-run'
        ? ' (edits are reverted at the end of the run)'
        : ' (edits are kept and can be committed)');
  }
  if (profileLine) {
    profileLine.innerHTML = '<strong>Codex Access:</strong> ' + profileLabel;
  }

  if (dangerWrap) {
    const showDangerAck = profile === 'full_access';
    dangerWrap.classList.toggle('hidden', !showDangerAck);
    if (!showDangerAck && dangerAck) dangerAck.checked = false;
  }

  if (!callout) return;
  callout.classList.remove('warn', 'danger');
  if (profile === 'full_access') {
    callout.textContent = (
      runMode === 'dry-run'
        ? 'Trusted Repo Full Access selected in Dry Run: edits are still reverted at the end, but sandbox and approval checks are disabled during execution.'
        : 'Trusted Repo Full Access: sandbox and approval checks are disabled. Use only for repositories you fully trust.'
    );
    callout.classList.add('danger');
    return;
  }
  if (runMode === 'dry-run') {
    callout.textContent = 'Dry Run preview: Codex can attempt edits, tests, and analysis, but workspace changes are reverted before completion.';
    callout.classList.add('warn');
    return;
  }
  if (profile === 'readonly') {
    callout.textContent = 'Read-Only Inspect selected: Codex can analyze but cannot write files, even in Apply mode.';
    callout.classList.add('warn');
    return;
  }
  callout.textContent = 'Recommended Safe Repo Access: Codex can read/write inside your repository with unattended execution.';
}

function openRunPlanModal(target) {
  const normalizedTarget = target === 'pipeline' ? 'pipeline' : 'chain';
  const overlay = document.getElementById('run-plan-overlay');
  if (!overlay) return Promise.resolve({ action: 'confirm', target: normalizedTarget, mode: 'dry-run', profile: 'safe' });

  _runPlanTarget = normalizedTarget;
  const cfg = normalizedTarget === 'pipeline' ? pipeConfig : config;
  const inferredProfile = _permissionProfileFromConfig(cfg);
  const defaultProfile = ['safe', 'readonly', 'full_access'].includes(inferredProfile)
    ? inferredProfile
    : 'safe';

  const area = _runPlanTargetLabel(normalizedTarget);
  const modeEl = document.getElementById('run-plan-mode');
  const profileEl = document.getElementById('run-plan-profile');
  const titleEl = document.getElementById('run-plan-title');
  const subtitleEl = document.getElementById('run-plan-subtitle');
  const modelChipEl = document.getElementById('run-plan-model-chip');
  const dangerAck = document.getElementById('run-plan-danger-ack');

  if (titleEl) titleEl.textContent = area + ' Run Configuration';
  if (subtitleEl) {
    subtitleEl.textContent = 'Review what will happen, then choose execution behavior and Codex access mode before starting.';
  }
  if (modelChipEl) modelChipEl.textContent = 'Model: ' + CODEX_MODEL_LABEL;
  if (modeEl) modeEl.value = (cfg.mode || 'dry-run');
  if (profileEl) profileEl.value = defaultProfile;
  if (dangerAck) dangerAck.checked = false;
  updateRunPlanModalPreview();

  _openOverlay('run-plan-overlay', '#run-plan-mode');
  return new Promise(resolve => {
    _runPlanResolver = resolve;
  });
}

function closeRunPlanModal(payload = { action: 'cancel' }) {
  _closeOverlay('run-plan-overlay');
  if (_runPlanResolver) {
    const resolve = _runPlanResolver;
    _runPlanResolver = null;
    resolve(payload);
  }
}

function confirmRunPlanModal() {
  const modeEl = document.getElementById('run-plan-mode');
  const profileEl = document.getElementById('run-plan-profile');
  const dangerAck = document.getElementById('run-plan-danger-ack');
  const mode = modeEl ? modeEl.value : 'dry-run';
  const profile = profileEl ? profileEl.value : 'safe';

  if (profile === 'full_access' && !(dangerAck && dangerAck.checked)) {
    toast('Please acknowledge the trusted full-access warning before starting.', 'error');
    return;
  }

  closeRunPlanModal({
    action: 'confirm',
    target: _runPlanTarget,
    mode,
    profile,
    danger_ack: !!(dangerAck && dangerAck.checked),
  });
}

function applyRunPlanChoice(choice) {
  if (!choice || choice.action !== 'confirm') return false;
  const target = choice.target === 'pipeline' ? 'pipeline' : 'chain';
  const runMode = choice.mode === 'apply' ? 'apply' : 'dry-run';
  const profile = ['safe', 'readonly', 'full_access'].includes(choice.profile) ? choice.profile : 'safe';

  if (target === 'pipeline') setPipeMode(runMode);
  else setMode(runMode);
  setPermissionProfile(target, profile);

  const cfg = target === 'pipeline' ? pipeConfig : config;
  cfg.mode = runMode;
  cfg.codex_danger_confirmation = (
    profile === 'full_access' && choice.danger_ack
      ? DANGER_CONFIRMATION_PHRASE
      : ''
  );
  return true;
}

let _readOnlyWarningResolver = null;

function openReadOnlyWarningModal(target, runMode) {
  const overlay = document.getElementById('readonly-warning-overlay');
  if (!overlay) return Promise.resolve('continue_readonly');

  const area = target === 'pipeline' ? 'Pipeline' : 'Chain';
  const modeLabel = runMode === 'apply' ? 'Apply mode' : 'Dry Run mode';

  document.getElementById('readonly-warning-title').textContent = 'Read-Only Sandbox Active';
  document.getElementById('readonly-warning-message').textContent =
    area + ' run requested in ' + modeLabel + ' with Codex sandbox set to read-only. Codex can inspect files but cannot write changes.';
  document.getElementById('readonly-warning-guidance').textContent = runMode === 'apply'
    ? 'Apply mode is selected, but write operations will be blocked until you switch to a write-enabled permission profile.'
    : 'This mode is fine for analysis-only runs. Switch to a write-enabled profile if you want Codex to edit files.';

  _openOverlay('readonly-warning-overlay', '#readonly-warning-cancel');

  return new Promise(resolve => {
    _readOnlyWarningResolver = resolve;
  });
}

function closeReadOnlyWarningModal(action = 'cancel') {
  _closeOverlay('readonly-warning-overlay');
  if (_readOnlyWarningResolver) {
    const resolve = _readOnlyWarningResolver;
    _readOnlyWarningResolver = null;
    resolve(action);
  }
}

async function guardReadOnlySandboxBeforeRun(target, usesCodex, runMode) {
  const cfg = target === 'pipeline' ? pipeConfig : config;
  if (!usesCodex || cfg.codex_sandbox_mode !== 'read-only') return true;

  const choice = await openReadOnlyWarningModal(target, runMode);
  if (choice === 'cancel') return false;

  if (choice === 'switch_trusted') {
    setPermissionProfile(target, 'full_access');
    toast('Switched to Trusted Repo Full Access. Write access is now enabled for this run.', 'info');
    return true;
  }

  if (choice === 'switch_safe') {
    setPermissionProfile(target, 'safe');
    toast('Switched to Recommended: Safe Repo Access (sandboxed write access).', 'info');
    return true;
  }

  toast('Continuing in read-only inspect mode. Codex cannot write files in this run.', runMode === 'apply' ? 'error' : 'info');
  return true;
}

function applyCodexPermissionPreset(target, preset) {
  if (preset === 'safe') return setPermissionProfile(target, 'safe');
  if (preset === 'isolated_full') return setPermissionProfile(target, 'full_access');
  return setPermissionProfile(target, 'custom');
}

function requestDangerConfirmationIfNeeded(cfg) {
  if (!cfg.codex_bypass_approvals_and_sandbox) {
    cfg.codex_danger_confirmation = '';
    return true;
  }
  if ((cfg.codex_danger_confirmation || '').trim() === DANGER_CONFIRMATION_PHRASE) {
    return true;
  }
  const ack = prompt(
    'Trusted Repo Full Access is enabled for this run.\n\n'
    + 'This disables sandbox and approval checks.\n'
    + 'Use only in repositories you fully trust.\n\n'
    + 'Type "' + DANGER_CONFIRMATION_PHRASE + '" to continue.'
  );
  if ((ack || '').trim() !== DANGER_CONFIRMATION_PHRASE) {
    toast('Dangerous mode cancelled: confirmation text did not match', 'error');
    cfg.codex_danger_confirmation = '';
    return false;
  }
  cfg.codex_danger_confirmation = DANGER_CONFIRMATION_PHRASE;
  return true;
}

function stepOutputFilename(step) {
  const raw = (step.name || step.job_type || 'step').trim();
  const slug = raw.replace(/[^\w\-]+/g, '-').replace(/^-+|-+$/g, '');
  return (slug || 'step') + '.md';
}

function getStepOutputCollisionDetails(steps) {
  const byFile = {};
  (steps || []).filter(s => s && s.enabled !== false).forEach(step => {
    const file = stepOutputFilename(step);
    if (!byFile[file]) byFile[file] = [];
    byFile[file].push({
      id: step.id,
      name: (step.name || step.job_type || 'step'),
    });
  });
  return Object.entries(byFile)
    .filter(([, entries]) => entries.length > 1)
    .map(([file, entries]) => ({ file, steps: entries }));
}

function findStepOutputCollisions(steps) {
  return getStepOutputCollisionDetails(steps)
    .map(c => [c.file, c.steps.map(s => s.name)]);
}

function duplicateStepIdSet(collisionDetails) {
  const ids = new Set();
  (collisionDetails || []).forEach(c => {
    (c.steps || []).forEach(s => ids.add(s.id));
  });
  return ids;
}

function renderStepCollisionAlert(collisionDetails) {
  const alert = document.getElementById('step-collision-alert');
  if (!alert) return;
  if (!collisionDetails || !collisionDetails.length) {
    alert.style.display = 'none';
    alert.innerHTML = '';
    return;
  }
  const rows = collisionDetails.map(c => {
    const names = (c.steps || []).map(s => esc(s.name || 'step')).join(', ');
    return '<div><code>' + esc(c.file) + '</code> &larr; ' + names + '</div>';
  }).join('');
  alert.innerHTML =
    '<div><strong>&#10060; Duplicate step names detected</strong></div>'
    + '<div style="margin-top:4px">These enabled steps map to the same output file:</div>'
    + '<div style="margin-top:6px;display:flex;flex-direction:column;gap:4px">' + rows + '</div>'
    + '<div style="margin-top:8px"><strong>How to fix:</strong> rename each marked step so every step name is unique.</div>';
  alert.style.display = 'block';
}

function applyMode(mode) {
  currentMode = mode;
  if (typeof localStorage !== 'undefined') localStorage.setItem('cm_mode', mode);
  document.body.classList.remove('mode-easy', 'mode-medium', 'mode-expert');
  document.body.classList.add('mode-' + mode);
  document.querySelectorAll('#difficulty-mode-toggle button').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
  if (mode === 'easy') {
    config.mode = 'dry-run';
    config.unlimited = true;
    config.stop_on_convergence = true;
    config.brain_enabled = false;
    config.parallel_execution = false;
    if (document.getElementById('mode-toggle')) {
      document.querySelectorAll('#mode-toggle button').forEach(b => { b.classList.toggle('active', b.dataset.mode === 'dry-run'); });
    }
    document.getElementById('unlimited').checked = true;
    toggleUnlimited();
    document.getElementById('brain-enabled').checked = false;
    toggleBrain();
    document.getElementById('parallel-exec').checked = false;
  }
  if (mode === 'easy' && (!config.steps || !config.steps.length)) {
    applyDefaultEasyRecipe();
    return;
  }
  renderSteps();
  renderStepDetails();
}

function selectRecipe(recipeId) {
  const recipe = RECIPES[recipeId];
  if (!recipe) return;
  document.querySelectorAll('.recipe-card').forEach(c => {
    const selected = c.dataset.recipe === recipeId;
    c.classList.toggle('selected', selected);
    c.setAttribute('aria-pressed', selected ? 'true' : 'false');
  });
  const steps = [];
  recipe.forEach((r, i) => {
    const p = presets.find(x => x.key === r.job_type);
    const promptMode = r.prompt_mode || (r.custom_prompt ? 'custom' : 'preset');
    steps.push({
      id: Math.random().toString(36).substring(2, 10),
      name: r.name || (p ? p.name : r.job_type),
      job_type: r.job_type,
      prompt_mode: promptMode,
      custom_prompt: promptMode === 'custom' ? (r.custom_prompt || '') : '',
      on_failure: r.on_failure || 'skip',
      max_retries: Number.isFinite(r.max_retries) ? r.max_retries : 1,
      loop_count: r.loop_count || 1,
      enabled: r.enabled !== false,
      agent: r.agent || 'auto',
    });
  });
  config.steps = steps;
  selectedStepId = steps.length ? steps[0].id : null;
  config.unlimited = true;
  config.stop_on_convergence = true;
  config.brain_enabled = false;
  config.parallel_execution = false;
  config.mode = 'dry-run';
  document.getElementById('unlimited').checked = true;
  toggleUnlimited();
  document.getElementById('brain-enabled').checked = false;
  toggleBrain();
  document.getElementById('parallel-exec').checked = false;
  if (document.getElementById('mode-toggle')) {
    document.querySelectorAll('#mode-toggle button').forEach(b => { b.classList.toggle('active', b.dataset.mode === 'dry-run'); });
  }
  renderSteps();
  renderStepDetails();
}

function applyDefaultEasyRecipe() {
  if (!RECIPES[DEFAULT_EASY_RECIPE_ID]) return;
  selectRecipe(DEFAULT_EASY_RECIPE_ID);
}

function initRecipeCardKeyboardAccess() {
  document.querySelectorAll('.recipe-card').forEach(card => {
    card.setAttribute('role', 'button');
    card.setAttribute('tabindex', '0');
    if (!card.hasAttribute('aria-pressed')) card.setAttribute('aria-pressed', 'false');
    if (card.dataset.keyboardBound === '1') return;
    card.dataset.keyboardBound = '1';
    card.addEventListener('keydown', (event) => {
      if (event.key !== 'Enter' && event.key !== ' ') return;
      event.preventDefault();
      const recipeId = card.dataset.recipe || '';
      if (recipeId) selectRecipe(recipeId);
    });
  });
}

function initMainTabKeyboardNav() {
  const tabList = document.getElementById('main-tabs');
  if (!tabList || tabList.dataset.keyboardBound === '1') return;
  tabList.dataset.keyboardBound = '1';
  tabList.addEventListener('keydown', (event) => {
    const keys = ['ArrowLeft', 'ArrowRight', 'Home', 'End'];
    if (!keys.includes(event.key)) return;
    const tabs = Array.from(tabList.querySelectorAll('button[data-tab]'));
    if (!tabs.length) return;

    const focusedIdx = tabs.indexOf(document.activeElement);
    const currentIdx = focusedIdx >= 0
      ? focusedIdx
      : Math.max(0, tabs.findIndex(btn => btn.getAttribute('aria-selected') === 'true'));
    let nextIdx = currentIdx;
    if (event.key === 'ArrowLeft') nextIdx = (currentIdx - 1 + tabs.length) % tabs.length;
    if (event.key === 'ArrowRight') nextIdx = (currentIdx + 1) % tabs.length;
    if (event.key === 'Home') nextIdx = 0;
    if (event.key === 'End') nextIdx = tabs.length - 1;

    const target = tabs[nextIdx];
    if (!target) return;
    event.preventDefault();
    target.focus();
    switchTab(target.dataset.tab);
  });
}

/* -- Init ------------------------------------------------------- */
document.addEventListener('DOMContentLoaded', async () => {
  applyProgramNameLabels();
  initGitSyncDrawer();
  try {
    presets = await api('/api/presets');
  } catch(e) { console.warn('Could not load presets', e); }
  resetPermissionProfileUiState('chain');
  resetPermissionProfileUiState('pipeline');
  normalizeCodexPermissions(config);
  normalizeCodexPermissions(pipeConfig);
  normalizeCapabilitySettings(config);
  normalizeCapabilitySettings(pipeConfig);
  syncChainPermissionControlsFromConfig();
  syncPipelinePermissionControlsFromConfig();
  syncChainCapabilityControlsFromConfig();
  syncPipelineCapabilityControlsFromConfig();
  syncChainTimeoutControlsFromConfig();
  syncPipeTimeoutControlsFromConfig();
  initMainTabKeyboardNav();
  initRecipeCardKeyboardAccess();
  renderActivityHeartbeats();
  if (activityHeartbeatTimer) clearInterval(activityHeartbeatTimer);
  activityHeartbeatTimer = setInterval(renderActivityHeartbeats, 1000);
  startBackendHealthPolling();
  startWatchdogAlertPolling();
  switchTab('chain');
  _syncGitSyncButtonState();
  refreshWorkspaceRepos({ silent: true, includeBranches: true });
  scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
  if (gitSyncPollTimer) clearInterval(gitSyncPollTimer);
  gitSyncPollTimer = setInterval(() => {
    scheduleGitSyncRefresh({ delayMs: 0, silent: true });
  }, GIT_SYNC_POLL_INTERVAL_MS);
  applyMode(currentMode);
  loadConfigList();
  renderSteps();
  // Fetch Ollama models in background - populates both brain dropdowns
  fetchOllamaModels();
  refreshChainOutputs(false);
  loadGovernancePolicy({ silent: true });
  loadGithubAuthSettings({ silent: true });
  loadOwnerIdeas();
  ['codex-bin', 'claude-bin'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => scheduleDiagnosticsRefresh('chain'));
    el.addEventListener('change', () => scheduleDiagnosticsRefresh('chain'));
  });
  ['pipe-codex-bin', 'pipe-claude-bin'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => scheduleDiagnosticsRefresh('pipeline'));
    el.addEventListener('change', () => scheduleDiagnosticsRefresh('pipeline'));
  });
  const pipeAgent = document.getElementById('pipe-agent');
  if (pipeAgent) {
    pipeAgent.addEventListener('change', () => {
      pipeConfig.agent = pipeAgent.value;
      scheduleDiagnosticsRefresh('pipeline');
    });
  }
  await restoreRuntimeSession();
  refreshDiagnostics('chain', { silent: true });
  refreshDiagnostics('pipeline', { silent: true });
  if (typeof localStorage !== 'undefined' && !localStorage.getItem('cm_onboarded')) {
    _openOverlay('onboarding-overlay', '.onboarding-card .btn-primary');
  }
  _syncModalOpenState();
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      _trapFocusInOverlay(e);
      return;
    }
    if (e.key !== 'Escape') return;
    if (_closeTopOverlay()) {
      e.preventDefault();
      return;
    }
    setGitSyncDrawerOpen(false);
  });
});

async function restoreRuntimeSession() {
  const session = await api('/api/runtime/session');
  if (!session || session.error) return false;

  const chain = (session.chain && typeof session.chain === 'object') ? session.chain : {};
  const pipeline = (session.pipeline && typeof session.pipeline === 'object') ? session.pipeline : {};
  const chainActive = !!chain.active;
  const pipelineActive = !!pipeline.active;
  if (!chainActive && !pipelineActive) return false;

  const chainRepoPath = String(chain.repo_path || '').trim();
  const pipelineRepoPath = String(pipeline.repo_path || '').trim();

  if (chainRepoPath) {
    config.repo_path = chainRepoPath;
    const repoInput = document.getElementById('repo-path');
    if (repoInput) repoInput.value = chainRepoPath;
    if (chain.mode === 'apply' || chain.mode === 'dry-run') {
      setMode(chain.mode);
    }
    const chainRunMaxLoops = Number(chain.run_max_loops);
    if (Number.isFinite(chainRunMaxLoops) && chainRunMaxLoops > 0) {
      config.max_loops = chainRunMaxLoops;
      const maxLoopsInput = document.getElementById('max-loops');
      if (maxLoopsInput) maxLoopsInput.value = String(chainRunMaxLoops);
    }
    if (typeof chain.run_unlimited === 'boolean') {
      config.unlimited = !!chain.run_unlimited;
      const unlimitedInput = document.getElementById('unlimited');
      if (unlimitedInput) unlimitedInput.checked = config.unlimited;
      toggleUnlimited();
    }
    validateRepo();
    refreshChainOutputs(false);
  }

  if (pipelineRepoPath) {
    pipeConfig.repo_path = pipelineRepoPath;
    const pipeRepoInput = document.getElementById('pipe-repo-path');
    if (pipeRepoInput) pipeRepoInput.value = pipelineRepoPath;
    if (pipeline.mode === 'apply' || pipeline.mode === 'dry-run') {
      setPipeMode(pipeline.mode);
    }
    const pipeRunMaxCycles = Number(pipeline.run_max_cycles);
    if (Number.isFinite(pipeRunMaxCycles) && pipeRunMaxCycles > 0) {
      pipeConfig.max_cycles = pipeRunMaxCycles;
      const maxCyclesInput = document.getElementById('pipe-cycles');
      if (maxCyclesInput) maxCyclesInput.value = String(pipeRunMaxCycles);
    }
    if (typeof pipeline.run_unlimited === 'boolean') {
      pipeConfig.unlimited = !!pipeline.run_unlimited;
      const pipeUnlimitedInput = document.getElementById('pipe-unlimited');
      if (pipeUnlimitedInput) pipeUnlimitedInput.checked = pipeConfig.unlimited;
      togglePipeUnlimited();
    }
    validatePipeRepo();
    schedulePipelineResumeRefresh(pipelineRepoPath, { delayMs: 0, silent: true });
    refreshPipelineRunComparison({ repoPath: pipelineRepoPath, silent: true });
  }

  if (chainActive) {
    chainRunning = true;
    chainPaused = !!chain.paused;
    setControlsRunning(true);
    connectSSE();
    startPolling();
    await pollStatus();
  }

  if (pipelineActive) {
    pipeRunning = true;
    pipePaused = !!pipeline.paused;
    setPipeControlsRunning(true);
    connectPipeSSE();
    startPipePolling();
    await pollPipeStatus();
  }

  renderActivityHeartbeats();
  if (pipelineActive && !chainActive) switchTab('pipeline');
  if (chainActive || pipelineActive) {
    const labels = [];
    if (chainActive) labels.push('chain');
    if (pipelineActive) labels.push('pipeline');
    toast('Reattached to active ' + labels.join(' + ') + ' run after refresh.', 'info');
    refreshWorkspaceRepos({ silent: true, includeBranches: true });
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
  }
  return true;
}

function dismissOnboarding() {
  _closeOverlay('onboarding-overlay');
  if (typeof localStorage !== 'undefined') localStorage.setItem('cm_onboarded', '1');
  applyMode('easy');
}

function _setFirstRunWizardStatus(text, tone) {
  const statusEl = document.getElementById('first-run-wizard-status');
  if (!statusEl) return;
  statusEl.textContent = text || '';
  const normalizedTone = ['ok', 'warn', 'error'].includes(tone) ? tone : '';
  if (normalizedTone) statusEl.setAttribute('data-tone', normalizedTone);
  else statusEl.removeAttribute('data-tone');
}

function _firstRunWizardRepoPath() {
  const input = document.getElementById('first-run-wizard-repo-path');
  return String(input && input.value ? input.value : '').trim();
}

function _firstRunWizardDiagnosticsPayload(repoPath) {
  return {
    repo_path: repoPath,
    codex_binary: String(document.getElementById('codex-bin').value || '').trim() || 'codex',
    claude_binary: String(document.getElementById('claude-bin').value || '').trim() || 'claude',
    agents: _collectChainAgentsForDiagnostics(),
  };
}

function _setFirstRunWizardRepoPath(repoPath) {
  const input = document.getElementById('first-run-wizard-repo-path');
  if (!input) return;
  input.value = String(repoPath || '').trim();
}

function _currentFirstRunWizardRepoSeed() {
  const chainRepo = String(document.getElementById('repo-path').value || '').trim();
  if (chainRepo) return chainRepo;
  const pipeRepo = String(document.getElementById('pipe-repo-path').value || '').trim();
  if (pipeRepo) return pipeRepo;
  return String(config.repo_path || pipeConfig.repo_path || '').trim();
}

function _renderFirstRunWizardDiagnostics(payload) {
  const summaryEl = document.getElementById('first-run-wizard-diag-summary');
  const checksEl = document.getElementById('first-run-wizard-diag-list');
  const actionsEl = document.getElementById('first-run-wizard-actions');
  if (!summaryEl || !checksEl || !actionsEl) return;

  const report = payload && typeof payload === 'object' ? payload : {};
  const summary = report.summary || { pass: 0, warn: 0, fail: 0 };
  const pass = Number(summary.pass || 0);
  const warn = Number(summary.warn || 0);
  const fail = Number(summary.fail || 0);
  if (fail > 0) {
    summaryEl.textContent = 'Diagnostics: ' + fail + ' failing checks, ' + warn + ' warnings.';
  } else if (warn > 0) {
    summaryEl.textContent = 'Diagnostics: ready with warnings (' + pass + ' pass, ' + warn + ' warn).';
  } else if (pass > 0) {
    summaryEl.textContent = 'Diagnostics: ready (' + pass + ' checks passed).';
  } else {
    summaryEl.textContent = 'Diagnostics not run yet.';
  }

  const checks = Array.isArray(report.checks) ? report.checks : [];
  if (!checks.length) {
    checksEl.innerHTML = '<div class="first-run-wizard-empty">Run diagnostics to populate checks.</div>';
  } else {
    checksEl.innerHTML = checks.map(check => {
      const status = String(check.status || 'warn').toLowerCase();
      const category = DIAG_CATEGORY_LABEL[check.category] || String(check.category || 'Check');
      const label = String(check.label || 'Check');
      const detail = String(check.detail || '');
      const hint = String(check.hint || '');
      return '<div class="first-run-wizard-check ' + escAttr(status) + '">'
        + '<div class="first-run-wizard-check-title">' + _diagStatusIcon(status) + ' '
        + escHtml(category + ': ' + label) + '</div>'
        + (detail ? ('<div class="first-run-wizard-check-detail">' + escHtml(detail) + '</div>') : '')
        + (hint ? ('<div class="first-run-wizard-check-hint">Fix: ' + escHtml(hint) + '</div>') : '')
        + '</div>';
    }).join('');
  }

  const actions = Array.isArray(report.next_actions) ? report.next_actions : [];
  if (!actions.length) {
    actionsEl.innerHTML = '<div class="first-run-wizard-empty">No next actions for the current diagnostics result.</div>';
  } else {
    actionsEl.innerHTML = actions.map(action => {
      const key = String(action.key || '');
      const severity = String(action.severity || 'required').toLowerCase();
      const badge = severity === 'required' ? '[Required]' : '[Recommended]';
      const title = String(action.title || 'Action');
      const detail = String(action.detail || '');
      const command = String(action.command || '');
      const canRun = !!action.can_run;
      return '<div class="first-run-wizard-action">'
        + '<div class="first-run-wizard-action-title">' + escHtml(badge + ' ' + title) + '</div>'
        + (detail ? ('<div class="first-run-wizard-check-detail">' + escHtml(detail) + '</div>') : '')
        + (command ? ('<div class="first-run-wizard-action-command">Command: ' + escHtml(command) + '</div>') : '')
        + (command
          ? ('<div class="first-run-wizard-action-controls">'
            + '<button type="button" class="btn" data-command="' + escAttr(command)
            + '" onclick="copyFirstRunWizardCommand(this)">Copy</button>'
            + (canRun
              ? ('<button type="button" class="btn btn-primary" data-action-key="' + escAttr(key)
                + '" onclick="runFirstRunWizardActionFromButton(this)">Run</button>')
              : '')
            + '</div>')
          : '')
        + '</div>';
    }).join('');
  }
}

function onFirstRunWizardRepoInput() {
  const repoPath = _firstRunWizardRepoPath();
  firstRunWizardReport = null;
  _renderFirstRunWizardDiagnostics({});
  if (!repoPath) {
    _setFirstRunWizardStatus('Set a repository path, then run diagnostics.');
    return;
  }
  _setFirstRunWizardStatus('Repository set. Run diagnostics to validate setup.');
}

function syncFirstRunWizardRepoFromCurrent() {
  const current = _currentFirstRunWizardRepoSeed();
  _setFirstRunWizardRepoPath(current);
  onFirstRunWizardRepoInput();
}

function openFirstRunWizard() {
  _closeOverlay('onboarding-overlay');
  syncFirstRunWizardRepoFromCurrent();
  _openOverlay('first-run-wizard-overlay', '#first-run-wizard-repo-path');
}

function closeFirstRunWizard() {
  _closeOverlay('first-run-wizard-overlay');
}

function _applyFirstRunWizardRepoToMainInputs(repoPath) {
  const normalized = String(repoPath || '').trim();
  const chainRepoEl = document.getElementById('repo-path');
  const pipeRepoEl = document.getElementById('pipe-repo-path');
  if (chainRepoEl) chainRepoEl.value = normalized;
  if (pipeRepoEl) pipeRepoEl.value = normalized;
  config.repo_path = normalized;
  pipeConfig.repo_path = normalized;
  validateRepo();
  validatePipeRepo();
}

async function runFirstRunWizardDiagnostics() {
  if (firstRunWizardBusy) return null;
  const repoPath = _firstRunWizardRepoPath();
  if (!repoPath) {
    _setFirstRunWizardStatus('Repository path is required before diagnostics can run.', 'error');
    return null;
  }

  firstRunWizardBusy = true;
  _setFirstRunWizardStatus('Running diagnostics...', 'warn');
  try {
    const payload = _firstRunWizardDiagnosticsPayload(repoPath);
    const report = await postJson('/api/diagnostics', payload);
    if (report && report.error) throw new Error(report.error);
    firstRunWizardReport = report || {};
    _renderFirstRunWizardDiagnostics(firstRunWizardReport);
    const ready = !!(firstRunWizardReport && firstRunWizardReport.ready);
    if (ready) {
      _setFirstRunWizardStatus('Setup checks passed. You can start a safe first run.', 'ok');
    } else {
      const failCount = Number((firstRunWizardReport.summary && firstRunWizardReport.summary.fail) || 0);
      if (failCount > 0) {
        _setFirstRunWizardStatus('Fix required checks before starting your first run.', 'error');
      } else {
        _setFirstRunWizardStatus('Diagnostics passed with warnings. Starting is allowed but review warnings first.', 'warn');
      }
    }
    return firstRunWizardReport;
  } catch (e) {
    const message = (e && e.message) ? e.message : 'Failed to run diagnostics.';
    _setFirstRunWizardStatus(message, 'error');
    _renderFirstRunWizardDiagnostics({});
    return null;
  } finally {
    firstRunWizardBusy = false;
  }
}

async function copyFirstRunWizardCommand(btn) {
  const command = String((btn && btn.dataset && btn.dataset.command) || '').trim();
  if (!command) {
    toast('No command is available for this action.', 'error');
    return;
  }
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(command);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = command;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      textarea.remove();
    }
    toast('Copied diagnostics command.', 'success');
  } catch (_err) {
    toast('Could not copy command to clipboard.', 'error');
  }
}

async function runFirstRunWizardActionFromButton(btn) {
  if (!btn || firstRunWizardBusy) return;
  const actionKey = String((btn.dataset && btn.dataset.actionKey) || '').trim();
  if (!actionKey) {
    toast('Missing diagnostics action key.', 'error');
    return;
  }

  const repoPath = _firstRunWizardRepoPath();
  if (!repoPath) {
    _setFirstRunWizardStatus('Repository path is required before running actions.', 'error');
    return;
  }

  const originalText = String(btn.textContent || 'Run');
  btn.disabled = true;
  btn.textContent = 'Running...';
  firstRunWizardBusy = true;
  _setFirstRunWizardStatus('Running diagnostics action...', 'warn');
  try {
    const payload = _firstRunWizardDiagnosticsPayload(repoPath);
    payload.action_key = actionKey;
    const result = await postJson('/api/diagnostics/actions/run', payload);
    if (result && result.error) throw new Error(result.error);
    if (result && result.ok) {
      _setFirstRunWizardStatus('Diagnostics action completed. Re-running checks...', 'warn');
      toast('Diagnostics action completed.', 'success');
    } else {
      const exitCode = String((result && result.exit_code) || '?');
      throw new Error('Diagnostics action failed (exit ' + exitCode + ').');
    }
    await runFirstRunWizardDiagnostics();
  } catch (e) {
    const message = (e && e.message) ? e.message : 'Failed to run diagnostics action.';
    _setFirstRunWizardStatus(message, 'error');
    toast(message, 'error');
  } finally {
    firstRunWizardBusy = false;
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

function applyFirstRunWizardDefaults() {
  const repoPath = _firstRunWizardRepoPath();
  if (!repoPath) {
    _setFirstRunWizardStatus('Set a repository path first.', 'error');
    return;
  }
  _applyFirstRunWizardRepoToMainInputs(repoPath);
  applyMode('easy');
  if (RECIPES.strategic) {
    selectRecipe('strategic');
  } else {
    applyDefaultEasyRecipe();
  }
  setMode('dry-run');
  setPermissionProfile('chain', 'safe');

  const unlimitedEl = document.getElementById('unlimited');
  if (unlimitedEl) unlimitedEl.checked = false;
  toggleUnlimited();
  const maxLoopsEl = document.getElementById('max-loops');
  if (maxLoopsEl) maxLoopsEl.value = '1';
  config.max_loops = 1;
  scheduleDiagnosticsRefresh('chain');
  _setFirstRunWizardStatus('Safe defaults applied: Strategic recipe + dry-run + 1 loop.', 'ok');
}

async function startFirstRunWizard() {
  if (chainRunning || chainPaused) {
    _setFirstRunWizardStatus('A chain run is already active. Stop it before starting another.', 'error');
    return;
  }
  const repoPath = _firstRunWizardRepoPath();
  if (!repoPath) {
    _setFirstRunWizardStatus('Set a repository path first.', 'error');
    return;
  }

  const reportRepo = firstRunWizardReport
    ? String(firstRunWizardReport.resolved_repo_path || firstRunWizardReport.repo_path || '').trim()
    : '';
  const needsDiagnostics = !firstRunWizardReport || !reportRepo || reportRepo !== repoPath;
  if (needsDiagnostics) {
    const report = await runFirstRunWizardDiagnostics();
    if (!report) return;
  }
  if (!firstRunWizardReport || !firstRunWizardReport.ready) {
    _setFirstRunWizardStatus('Setup is not ready yet. Resolve required diagnostics actions first.', 'error');
    return;
  }

  applyFirstRunWizardDefaults();
  closeFirstRunWizard();
  _closeOverlay('onboarding-overlay');
  if (typeof localStorage !== 'undefined') localStorage.setItem('cm_onboarded', '1');
  switchTab('chain');
  await startChain({ skipRunPlan: true });
}

/* -- To-Do / Wishlist workspace -- */
let lastTodoWishlistSuggestion = '';
let todoWishlistContextFiles = [];
let pendingGeneralRequestRun = null;
let _generalRequestFinalizeInFlight = false;

function _activeRepoPath() {
  const chainRepo = String(document.getElementById('repo-path').value || '').trim();
  if (chainRepo) return chainRepo;
  const pipeRepo = String(document.getElementById('pipe-repo-path').value || '').trim();
  return pipeRepo;
}

function _activeMainTabId() {
  const active = document.querySelector('#main-tabs button[aria-selected="true"]');
  const tabId = String(active ? active.dataset.tab : '').trim();
  return tabId === 'pipeline' ? 'pipeline' : 'chain';
}

function _activeRepoPathForGitSync() {
  const chainRepo = String(document.getElementById('repo-path').value || '').trim();
  const pipeRepo = String(document.getElementById('pipe-repo-path').value || '').trim();
  if (_activeMainTabId() === 'pipeline') {
    return pipeRepo || chainRepo;
  }
  return chainRepo || pipeRepo;
}

function _workspaceRepoPathKey(repoPath) {
  return String(repoPath || '').trim().toLowerCase();
}

function _sameRepoPath(a, b) {
  const left = _workspaceRepoPathKey(a);
  const right = _workspaceRepoPathKey(b);
  if (!left || !right) return false;
  return left === right;
}

function _workspaceRepoSelectId(repoPath) {
  const text = String(repoPath || '');
  let hash = 2166136261;
  for (let i = 0; i < text.length; i += 1) {
    hash ^= text.charCodeAt(i);
    hash = (hash * 16777619) >>> 0;
  }
  return 'workspace-branch-select-' + hash.toString(16);
}

function _setWorkspaceStatus(text, tone = 'muted') {
  const el = document.getElementById('workspace-repo-status');
  if (!el) return;
  const toneValue = ['ok', 'warn', 'error', 'muted'].includes(tone) ? tone : 'muted';
  el.dataset.tone = toneValue;
  el.textContent = String(text || '');
}

function _workspaceBranchOptionsHtml(entry) {
  const branches = entry && typeof entry.branches === 'object' ? entry.branches : {};
  const current = String(branches.current_branch || '').trim();
  const local = Array.isArray(branches.local_branches)
    ? branches.local_branches.map(v => String(v || '').trim()).filter(Boolean)
    : [];
  const remote = Array.isArray(branches.remote_branches)
    ? branches.remote_branches.map(v => String(v || '').trim()).filter(Boolean)
    : [];

  if (!local.length && !remote.length) {
    return '<option value="">No branches</option>';
  }

  let html = '<option value="">Select branch...</option>';
  if (local.length) {
    html += '<optgroup label="Local branches">';
    local.forEach(branch => {
      const value = _gitSyncBranchValue('local', branch);
      const label = branch === current ? (branch + ' (current)') : branch;
      html += '<option value="' + esc(value) + '">' + esc(label) + '</option>';
    });
    html += '</optgroup>';
  }
  if (remote.length) {
    html += '<optgroup label="Remote branches">';
    remote.forEach(branch => {
      const value = _gitSyncBranchValue('remote', branch);
      html += '<option value="' + esc(value) + '">' + esc(branch) + '</option>';
    });
    html += '</optgroup>';
  }
  return html;
}

function _workspaceRunSummaryLabel(recentRuns) {
  const payload = recentRuns && typeof recentRuns === 'object' ? recentRuns : {};
  const latest = payload.latest && typeof payload.latest === 'object' ? payload.latest : null;
  if (!latest) {
    return {
      text: String(payload.message || 'No recent runs'),
      title: String(payload.message || 'No recent runs available for this repository.'),
    };
  }
  const finished = String(latest.finished_at || '').trim();
  const when = finished ? finished.replace('T', ' ').replace('Z', ' UTC') : 'unknown time';
  const scope = String(latest.scope || 'run').trim() || 'run';
  const duration = Number(latest.duration_seconds || 0);
  const durationLabel = Number.isFinite(duration) && duration > 0 ? (duration.toFixed(1) + 's') : 'n/a';
  const tokens = Number(latest.token_usage || 0);
  const tokenLabel = Number.isFinite(tokens) && tokens > 0 ? String(tokens) : 'n/a';
  const testsSummary = String(latest.tests_summary || '').trim() || 'tests n/a';
  const text = scope + ' | ' + when + ' | ' + testsSummary;
  const title = [
    'Scope: ' + scope,
    'Finished: ' + when,
    'Duration: ' + durationLabel,
    'Tokens: ' + tokenLabel,
    'Tests: ' + testsSummary,
    'Stop reason: ' + String(latest.stop_reason || 'n/a'),
  ].join('\n');
  return { text, title };
}

function _renderWorkspaceRepoRows(payload) {
  const tbody = document.getElementById('workspace-repo-body');
  if (!tbody) return;
  const data = payload && typeof payload === 'object' ? payload : {};
  const repos = Array.isArray(data.repos) ? data.repos : [];
  const activeRepoPath = String(data.active_repo_path || '').trim();

  if (!repos.length) {
    tbody.innerHTML = '<tr><td colspan="5" style="color:var(--text2)">No workspace repos added yet.</td></tr>';
    return;
  }

  tbody.innerHTML = repos.map(entry => {
    const repoPath = String(entry && entry.repo_path || '').trim();
    const name = String(entry && entry.name || '').trim() || repoPath || 'repo';
    const exists = !!(entry && entry.exists);
    const available = !!(entry && entry.available);
    const isActive = _sameRepoPath(activeRepoPath, repoPath);
    const encodedPath = encodeURIComponent(repoPath);
    const selectId = _workspaceRepoSelectId(repoPath);
    const sync = entry && typeof entry.sync === 'object' ? entry.sync : {};
    const branch = String(sync.branch || '').trim() || 'n/a';
    const ahead = Number(sync.ahead);
    const behind = Number(sync.behind);
    const aheadBehindKnown = Number.isFinite(ahead) && Number.isFinite(behind);
    const aheadBehind = aheadBehindKnown ? ('ahead ' + ahead + ' / behind ' + behind) : 'no upstream';
    const dirty = !!sync.dirty;
    const dirtyLabel = dirty ? 'dirty' : 'clean';
    const branchTitle = available
      ? ('Branch: ' + branch + '\n' + aheadBehind + '\nWorktree: ' + dirtyLabel)
      : (exists ? 'Git metadata unavailable for this repo.' : 'Repository path is missing.');

    const remote = entry && typeof entry.remote_settings === 'object' ? entry.remote_settings : {};
    const defaultRemote = String(remote.default_remote || '').trim();
    const remoteNames = Array.isArray(remote.remote_names)
      ? remote.remote_names.map(v => String(v || '').trim()).filter(Boolean)
      : [];
    const remoteLabel = defaultRemote ? defaultRemote : (remoteNames.length ? remoteNames[0] : 'none');
    const remoteMeta = remoteNames.length ? (remoteNames.length + ' remotes') : 'no remotes';
    const remoteTitle = defaultRemote
      ? ('Default remote: ' + defaultRemote + '\nAvailable: ' + remoteNames.join(', '))
      : (remoteNames.length
        ? ('Available remotes: ' + remoteNames.join(', '))
        : 'No remotes configured.');

    const runLabel = _workspaceRunSummaryLabel(entry ? entry.recent_runs : null);
    const errors = Array.isArray(entry && entry.errors) ? entry.errors : [];
    const errorText = errors.map(item => String(item || '').trim()).filter(Boolean).join(' | ');
    const useDisabledAttr = available ? '' : ' data-workspace-disabled="1" disabled';
    const disabledAttr = available ? '' : ' data-workspace-disabled="1" disabled';
    const branchOptions = _workspaceBranchOptionsHtml(entry);
    const badge = isActive
      ? '<span class="workspace-repo-badge active">active</span>'
      : '<span class="workspace-repo-badge">workspace</span>';

    return '<tr>'
      + '<td>'
      +   '<div class="workspace-repo-main"><strong>' + esc(name) + '</strong>' + badge + '</div>'
      +   '<code>' + esc(repoPath || 'n/a') + '</code>'
      +   (errorText ? '<span class="workspace-repo-meta" style="color:var(--danger)">' + esc(errorText) + '</span>' : '')
      + '</td>'
      + '<td>'
      +   '<span class="workspace-repo-branch">' + esc(branch) + '</span>'
      +   '<span class="workspace-repo-meta" title="' + esc(branchTitle) + '">' + esc(aheadBehind + ' | ' + dirtyLabel) + '</span>'
      + '</td>'
      + '<td>'
      +   '<span class="workspace-repo-branch">' + esc(remoteLabel) + '</span>'
      +   '<span class="workspace-repo-meta" title="' + esc(remoteTitle) + '">' + esc(remoteMeta) + '</span>'
      + '</td>'
      + '<td>'
      +   '<span class="workspace-repo-meta" title="' + esc(runLabel.title) + '">' + esc(runLabel.text) + '</span>'
      + '</td>'
      + '<td><div class="workspace-repo-actions">'
      +   '<button class="btn" type="button" data-workspace-action="1" onclick="workspaceUseRepo(decodeURIComponent(\'' + encodedPath + '\'))"' + useDisabledAttr + '>Use</button>'
      +   '<button class="btn" type="button" data-workspace-action="1" onclick="workspaceQuickPull(decodeURIComponent(\'' + encodedPath + '\'))"' + disabledAttr + '>Pull</button>'
      +   '<button class="btn btn-success" type="button" data-workspace-action="1" onclick="workspaceQuickPush(decodeURIComponent(\'' + encodedPath + '\'))"' + disabledAttr + '>Push</button>'
      +   '<select id="' + esc(selectId) + '" data-workspace-action="1"' + disabledAttr + '>'
      +     branchOptions
      +   '</select>'
      +   '<button class="btn" type="button" data-workspace-action="1" onclick="workspaceQuickCheckout(decodeURIComponent(\'' + encodedPath + '\'))"' + disabledAttr + '>Checkout</button>'
      +   '<button class="btn btn-danger" type="button" data-workspace-action="1" onclick="workspaceRemoveRepo(decodeURIComponent(\'' + encodedPath + '\'))">Remove</button>'
      + '</div></td>'
      + '</tr>';
  }).join('');
}

function _syncWorkspaceControls() {
  const input = document.getElementById('workspace-repo-path');
  const addBtn = document.getElementById('workspace-repo-add-btn');
  const refreshBtn = document.getElementById('workspace-repo-refresh-btn');
  const hasPath = !!String(input ? input.value : '').trim();
  const busy = workspaceBusy || !!gitSyncBusyAction;
  if (addBtn) addBtn.disabled = busy || !hasPath;
  if (refreshBtn) refreshBtn.disabled = busy;
  document.querySelectorAll('[data-workspace-action]').forEach(el => {
    const hardDisabled = String(el.getAttribute('data-workspace-disabled') || '') === '1';
    el.disabled = busy || hardDisabled;
  });
}

async function refreshWorkspaceRepos(opts = {}) {
  const includeBranches = opts.includeBranches !== false;
  const recentRunsLimitRaw = Number(opts.recentRunsLimit);
  const recentRunsLimit = Number.isFinite(recentRunsLimitRaw)
    ? Math.max(1, Math.floor(recentRunsLimitRaw))
    : 3;
  const query = '?include_branches=' + (includeBranches ? '1' : '0')
    + '&recent_runs_limit=' + encodeURIComponent(String(recentRunsLimit));
  const response = await api('/api/workspace/repos' + query);
  if (response.error) {
    workspaceState = null;
    _renderWorkspaceRepoRows({ repos: [] });
    _setWorkspaceStatus('Could not load workspace repos: ' + String(response.error || 'Unknown error'), 'error');
    if (!opts.silent) toast('Could not load workspace repos: ' + String(response.error || 'Unknown error'), 'error');
    _syncWorkspaceControls();
    return;
  }

  workspaceState = response;
  _renderWorkspaceRepoRows(response);
  const total = Number(response.total_repos || 0);
  const available = Number(response.available_repos || 0);
  if (!opts.preserveStatus) {
    if (!total) {
      _setWorkspaceStatus('No workspace repos configured yet.', 'muted');
    } else if (available < total) {
      _setWorkspaceStatus('Workspace loaded: ' + available + '/' + total + ' repos available.', 'warn');
    } else {
      _setWorkspaceStatus('Workspace loaded: ' + total + ' repos ready.', 'ok');
    }
  }
  _syncWorkspaceControls();
}

async function refreshWorkspaceReposNow() {
  await refreshWorkspaceRepos({ silent: false, includeBranches: true });
}

async function addWorkspaceRepoFromInput() {
  if (workspaceBusy) return;
  const input = document.getElementById('workspace-repo-path');
  const repoPath = String(input ? input.value : '').trim();
  if (!repoPath) {
    toast('Enter a repository path first.', 'warn');
    _syncWorkspaceControls();
    return;
  }

  workspaceBusy = true;
  _setWorkspaceStatus('Adding repository to workspace...', 'muted');
  _syncWorkspaceControls();
  const response = await postJson('/api/workspace/repos/add', {
    repo_path: repoPath,
    make_active: false,
    include_branches: true,
    recent_runs_limit: 3,
  });
  workspaceBusy = false;
  _syncWorkspaceControls();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setWorkspaceStatus('Add failed: ' + message, 'error');
    toast('Could not add workspace repo: ' + message, 'error');
    return;
  }

  if (input) input.value = '';
  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
  _setWorkspaceStatus(String(response.message || 'Workspace repo added.'), 'ok');
  toast(String(response.message || 'Workspace repo added.'), 'success');
}

async function workspaceRemoveRepo(repoPath) {
  if (workspaceBusy) return;
  const normalized = String(repoPath || '').trim();
  if (!normalized) return;

  workspaceBusy = true;
  _setWorkspaceStatus('Removing repository from workspace...', 'muted');
  _syncWorkspaceControls();
  const response = await postJson('/api/workspace/repos/remove', {
    repo_path: normalized,
    include_branches: true,
    recent_runs_limit: 3,
  });
  workspaceBusy = false;
  _syncWorkspaceControls();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setWorkspaceStatus('Remove failed: ' + message, 'error');
    toast('Could not remove workspace repo: ' + message, 'error');
    return;
  }

  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
  _setWorkspaceStatus(String(response.message || 'Workspace repo removed.'), 'ok');
  toast(String(response.message || 'Workspace repo removed.'), 'success');
}

async function workspaceUseRepo(repoPath) {
  const normalized = String(repoPath || '').trim();
  if (!normalized) return;

  const activeTab = _activeMainTabId();
  if (activeTab === 'pipeline') {
    const pipeInput = document.getElementById('pipe-repo-path');
    if (pipeInput) pipeInput.value = normalized;
    validatePipeRepo();
    const chainInput = document.getElementById('repo-path');
    if (chainInput && !String(chainInput.value || '').trim()) {
      chainInput.value = normalized;
      validateRepo();
    }
  } else {
    const chainInput = document.getElementById('repo-path');
    if (chainInput) chainInput.value = normalized;
    validateRepo();
    const pipeInput = document.getElementById('pipe-repo-path');
    if (pipeInput && !String(pipeInput.value || '').trim()) {
      pipeInput.value = normalized;
      validatePipeRepo();
    }
  }

  const response = await postJson('/api/workspace/repos/activate', {
    repo_path: normalized,
    add_if_missing: true,
    include_branches: true,
    recent_runs_limit: 3,
  });
  if (response.error) {
    toast('Could not set active workspace repo: ' + String(response.error || 'Unknown error'), 'error');
  }
  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
  _setWorkspaceStatus('Active workspace repo: ' + normalized, 'ok');
  scheduleGitSyncRefresh({ repoPath: normalized, delayMs: 0, silent: true, force: true });
}

async function _workspaceRunGitQuickAction(actionKey, repoPath, payload = {}) {
  if (workspaceBusy) return;
  const normalized = String(repoPath || '').trim();
  if (!normalized) return;

  const actions = {
    pull: {
      endpoint: '/api/git/sync/pull',
      running: 'Running quick pull...',
      fallback: 'Pull completed.',
      failure: 'Quick pull failed: ',
    },
    push: {
      endpoint: '/api/git/sync/push',
      running: 'Running quick push...',
      fallback: 'Push completed.',
      failure: 'Quick push failed: ',
    },
    checkout: {
      endpoint: '/api/git/sync/checkout',
      running: 'Running quick checkout...',
      fallback: 'Checkout completed.',
      failure: 'Quick checkout failed: ',
    },
  };
  const action = actions[actionKey];
  if (!action) return;

  workspaceBusy = true;
  _setWorkspaceStatus(action.running, 'muted');
  _syncWorkspaceControls();
  const body = Object.assign({ repo_path: normalized }, payload || {});
  const response = await postJson(action.endpoint, body);
  workspaceBusy = false;
  _syncWorkspaceControls();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setWorkspaceStatus(action.failure + message, 'error');
    toast(action.failure + message, 'error');
    if (actionKey === 'push' && response && response.error_type === 'signing_misconfigured') {
      const signingSettings = _gitSigningSettingsFromResponse(response.signing);
      if (signingSettings) {
        gitSigningState = signingSettings;
      }
      const issues = Array.isArray(signingSettings && signingSettings.issues) ? signingSettings.issues : [];
      if (issues.length) {
        toast('Signing issue: ' + String(issues[0]), 'info');
      } else {
        toast('Open Git Sync -> Signing to resolve signing validation issues.', 'info');
      }
    }
    const recovery = Array.isArray(response.recovery_steps) ? response.recovery_steps : [];
    if (recovery.length) {
      toast('Recovery: ' + recovery.join(' | '), 'info');
    }
    await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
    return;
  }

  const currentActiveRepo = _activeRepoPathForGitSync();
  if (_sameRepoPath(currentActiveRepo, normalized)) {
    if (response.sync) {
      gitSyncState = response.sync;
      _renderGitSyncState(response.sync);
    }
    if (response.branches) {
      gitSyncBranchState = response.branches;
      _renderGitSyncBranchOptions(response.branches, {
        preferredBranch: String(response.sync && response.sync.branch || '').trim(),
      });
    }
    if (actionKey === 'push') {
      const pullRequest = (response && typeof response.pull_request === 'object' && response.pull_request)
        ? response.pull_request
        : null;
      const pullRequestUrl = String(
        (pullRequest && pullRequest.url) || response.pull_request_url || ''
      ).trim();
      _setGitSyncPullRequestUrl(pullRequestUrl);
    }
    scheduleGitSyncRefresh({ repoPath: normalized, delayMs: 0, silent: true, force: true });
  }

  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
  const message = String(response.message || action.fallback);
  _setWorkspaceStatus(message, 'ok');
  toast(message, 'success');
}

async function workspaceQuickPull(repoPath) {
  await _workspaceRunGitQuickAction('pull', repoPath);
}

async function workspaceQuickPush(repoPath) {
  const setUpstreamCheckbox = document.getElementById('git-sync-set-upstream');
  const setUpstream = !!(setUpstreamCheckbox && setUpstreamCheckbox.checked);
  await _workspaceRunGitQuickAction('push', repoPath, { set_upstream: setUpstream });
}

async function workspaceQuickCheckout(repoPath) {
  const normalized = String(repoPath || '').trim();
  if (!normalized) return;
  const select = document.getElementById(_workspaceRepoSelectId(normalized));
  const branchTarget = _parseGitSyncBranchValue(select ? select.value : '');
  if (!branchTarget) {
    toast('Select a branch first.', 'warn');
    return;
  }
  await _workspaceRunGitQuickAction('checkout', normalized, {
    branch: branchTarget.branch,
    branch_type: branchTarget.branch_type,
    allow_dirty: _gitSyncAllowDirtySwitchEnabled(),
  });
}

function _setGitSyncIndicator(text, tone = 'muted', title = '') {
  const toneValue = ['ok', 'warn', 'error', 'muted'].includes(tone) ? tone : 'muted';
  const widget = document.getElementById('git-sync-widget');
  if (widget) {
    widget.dataset.tone = toneValue;
  }
  const el = document.getElementById('git-sync-indicator');
  if (!el) return;
  el.dataset.tone = toneValue;
  el.textContent = String(text || '');
  el.title = String(title || text || '');
}

function _setGitSyncWidgetValue(elementId, value, title = '') {
  const el = document.getElementById(elementId);
  if (!el) return;
  el.textContent = String(value || '');
  el.title = String(title || value || '');
}

function _clearGitSyncWidgetDetails() {
  _setGitSyncWidgetValue('git-sync-widget-branch', 'n/a', 'No active repository selected.');
  _setGitSyncWidgetValue('git-sync-widget-remote', 'none', 'No upstream tracking remote configured.');
  _setGitSyncWidgetValue('git-sync-widget-ahead-behind', 'n/a', 'Ahead/behind counts are unavailable.');
  _setGitSyncWidgetValue('git-sync-widget-last-fetch', 'never', 'No fetch metadata available yet.');
  _setGitSyncWidgetValue('git-sync-widget-github-name', 'n/a', 'GitHub repository metadata is unavailable.');
  _setGitSyncWidgetValue('git-sync-widget-github-visibility', 'n/a', 'GitHub visibility metadata is unavailable.');
  _setGitSyncWidgetValue('git-sync-widget-github-default-branch', 'n/a', 'GitHub default-branch metadata is unavailable.');
  _setGitSyncRepoUrl('');
}

function _formatGitSyncLastFetch(sync) {
  const epochRaw = sync ? sync.last_fetch_epoch_ms : null;
  const epochMs = Number(epochRaw);
  if (!Number.isFinite(epochMs) || epochMs <= 0) {
    return {
      label: 'never',
      title: 'No fetch metadata available yet. Run Fetch, Pull, or Stash + Pull.',
    };
  }

  const when = new Date(epochMs);
  if (Number.isNaN(when.getTime())) {
    return {
      label: 'unknown',
      title: 'Last fetch time is present but could not be parsed.',
    };
  }

  const minutesAgo = Math.max(0, Math.floor((Date.now() - epochMs) / 60000));
  let ageLabel = 'just now';
  if (minutesAgo === 1) ageLabel = '1 minute ago';
  else if (minutesAgo > 1 && minutesAgo < 60) ageLabel = String(minutesAgo) + ' minutes ago';
  else if (minutesAgo >= 60 && minutesAgo < 120) ageLabel = '1 hour ago';
  else if (minutesAgo >= 120 && minutesAgo < 1440) ageLabel = String(Math.floor(minutesAgo / 60)) + ' hours ago';
  else if (minutesAgo >= 1440 && minutesAgo < 2880) ageLabel = '1 day ago';
  else if (minutesAgo >= 2880) ageLabel = String(Math.floor(minutesAgo / 1440)) + ' days ago';

  const localLabel = when.toLocaleString([], {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
  const localFull = when.toLocaleString([], {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
  const utcRaw = String((sync && sync.last_fetch_at) || '').trim();
  const titleParts = [];
  if (utcRaw) titleParts.push('UTC: ' + utcRaw);
  titleParts.push('Local: ' + localFull);
  titleParts.push('Age: ' + ageLabel);
  return {
    label: localLabel,
    title: titleParts.join('\n'),
  };
}

function _setGitSyncPullRequestUrl(rawUrl) {
  const url = String(rawUrl || '').trim();
  gitSyncPullRequestUrl = url;
  const defaultTitle = 'Push a branch to generate a GitHub pull request URL.';
  const openBtn = document.getElementById('git-sync-open-pr-btn');
  if (openBtn) {
    openBtn.title = url ? ('Open pull request URL: ' + url) : defaultTitle;
  }
  const copyBtn = document.getElementById('git-sync-copy-pr-btn');
  if (copyBtn) {
    copyBtn.title = url ? ('Copy pull request URL: ' + url) : defaultTitle;
  }
}

function _setGitSyncRepoUrl(rawUrl) {
  const url = String(rawUrl || '').trim();
  gitSyncGithubRepoUrl = url;
  const defaultTitle = 'GitHub repository page is available when the selected remote points to github.com.';
  const openBtn = document.getElementById('git-sync-open-repo-btn');
  if (openBtn) {
    openBtn.title = url ? ('Open GitHub repository page: ' + url) : defaultTitle;
  }
}

function _gitSyncBranchValue(branchType, branchName) {
  const type = String(branchType || '').trim().toLowerCase();
  const branch = String(branchName || '').trim();
  if (!branch || (type !== 'local' && type !== 'remote')) return '';
  return type + ':' + branch;
}

function _parseGitSyncBranchValue(rawValue) {
  const value = String(rawValue || '').trim();
  if (!value) return null;
  const idx = value.indexOf(':');
  if (idx <= 0) return null;
  const branchType = value.slice(0, idx).trim().toLowerCase();
  const branch = value.slice(idx + 1).trim();
  if (!branch || (branchType !== 'local' && branchType !== 'remote')) return null;
  return { branch_type: branchType, branch };
}

function _clearGitSyncBranchOptions(placeholder = 'Switch branch...') {
  const selectEl = document.getElementById('git-sync-branch-select');
  if (!selectEl) return;
  selectEl.innerHTML = '';
  const option = document.createElement('option');
  option.value = '';
  option.textContent = String(placeholder || 'Switch branch...');
  selectEl.appendChild(option);
  selectEl.value = '';
}

function _renderGitSyncBranchOptions(payload, opts = {}) {
  const selectEl = document.getElementById('git-sync-branch-select');
  if (!selectEl) return;

  const previousSelection = String(selectEl.value || '').trim();
  const localBranches = Array.isArray(payload && payload.local_branches)
    ? payload.local_branches.map(v => String(v || '').trim()).filter(Boolean)
    : [];
  const remoteBranches = Array.isArray(payload && payload.remote_branches)
    ? payload.remote_branches.map(v => String(v || '').trim()).filter(Boolean)
    : [];
  const currentBranch = String(payload && payload.current_branch || '').trim();
  const preferredBranch = String(opts.preferredBranch || '').trim();

  selectEl.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Switch branch...';
  selectEl.appendChild(placeholder);

  const optionValues = new Set();
  if (localBranches.length) {
    const localGroup = document.createElement('optgroup');
    localGroup.label = 'Local branches';
    localBranches.forEach(branch => {
      const option = document.createElement('option');
      option.value = _gitSyncBranchValue('local', branch);
      option.textContent = branch === currentBranch ? branch + ' (current)' : branch;
      localGroup.appendChild(option);
      optionValues.add(option.value);
    });
    selectEl.appendChild(localGroup);
  }

  if (remoteBranches.length) {
    const remoteGroup = document.createElement('optgroup');
    remoteGroup.label = 'Remote branches';
    remoteBranches.forEach(branch => {
      const option = document.createElement('option');
      option.value = _gitSyncBranchValue('remote', branch);
      option.textContent = branch;
      remoteGroup.appendChild(option);
      optionValues.add(option.value);
    });
    selectEl.appendChild(remoteGroup);
  }

  const candidateValues = [];
  if (preferredBranch) candidateValues.push(_gitSyncBranchValue('local', preferredBranch));
  if (previousSelection) candidateValues.push(previousSelection);
  if (currentBranch) candidateValues.push(_gitSyncBranchValue('local', currentBranch));
  const selectedValue = candidateValues.find(value => optionValues.has(value)) || '';
  selectEl.value = selectedValue;
}

function _currentGitSyncBranchTarget() {
  const selectEl = document.getElementById('git-sync-branch-select');
  if (!selectEl) return null;
  return _parseGitSyncBranchValue(selectEl.value);
}

function _gitSyncAllowDirtySwitchEnabled() {
  const allowDirty = document.getElementById('git-sync-allow-dirty-switch');
  return !!(allowDirty && allowDirty.checked);
}

function _syncGitSyncButtonState() {
  const hasRepoPath = !!_activeRepoPathForGitSync();
  const disabled = !hasRepoPath || !!gitSyncBusyAction;
  [
    'git-sync-fetch-btn',
    'git-sync-pull-btn',
    'git-sync-push-btn',
    'git-sync-stash-pull-btn',
    'git-sync-commit-panel-btn',
    'git-sync-remotes-btn',
    'git-sync-signing-btn',
    'git-sync-refresh-btn',
  ].forEach(id => {
    const btn = document.getElementById(id);
    if (btn) btn.disabled = disabled;
  });
  const hasPullRequestUrl = !!String(gitSyncPullRequestUrl || '').trim();
  const hasGithubRepoUrl = !!String(gitSyncGithubRepoUrl || '').trim();
  const openRepoBtn = document.getElementById('git-sync-open-repo-btn');
  if (openRepoBtn) openRepoBtn.disabled = disabled || !hasGithubRepoUrl;
  const openPrBtn = document.getElementById('git-sync-open-pr-btn');
  if (openPrBtn) openPrBtn.disabled = disabled || !hasPullRequestUrl;
  const copyPrBtn = document.getElementById('git-sync-copy-pr-btn');
  if (copyPrBtn) copyPrBtn.disabled = disabled || !hasPullRequestUrl;
  const setUpstream = document.getElementById('git-sync-set-upstream');
  if (setUpstream) setUpstream.disabled = disabled;
  const branchRefreshBtn = document.getElementById('git-sync-branch-refresh-btn');
  if (branchRefreshBtn) branchRefreshBtn.disabled = disabled;
  const branchSelect = document.getElementById('git-sync-branch-select');
  if (branchSelect) branchSelect.disabled = disabled;
  const branchSwitchBtn = document.getElementById('git-sync-branch-switch-btn');
  if (branchSwitchBtn) branchSwitchBtn.disabled = disabled || !_currentGitSyncBranchTarget();
  const branchInput = document.getElementById('git-sync-branch-create-name');
  const branchName = String(branchInput ? branchInput.value : '').trim();
  if (branchInput) branchInput.disabled = disabled;
  const branchCreateBtn = document.getElementById('git-sync-branch-create-btn');
  if (branchCreateBtn) branchCreateBtn.disabled = disabled || !branchName;
  const allowDirty = document.getElementById('git-sync-allow-dirty-switch');
  if (allowDirty) allowDirty.disabled = disabled;
  _syncGitRemoteControls();
  _syncGitSigningControls();
  _syncGitCommitControls();
  _syncWorkspaceControls();
}

function _renderGitSyncState(sync) {
  const branch = String((sync && sync.branch) || 'HEAD').trim() || 'HEAD';
  const trackingBranch = String((sync && sync.tracking_branch) || '').trim();
  const trackingRemote = String((sync && sync.tracking_remote) || '').trim()
    || (trackingBranch.includes('/') ? trackingBranch.split('/', 1)[0].trim() : '');
  const aheadRaw = sync ? sync.ahead : null;
  const behindRaw = sync ? sync.behind : null;
  const aheadKnown = aheadRaw !== null && aheadRaw !== undefined && Number.isFinite(Number(aheadRaw));
  const behindKnown = behindRaw !== null && behindRaw !== undefined && Number.isFinite(Number(behindRaw));
  const ahead = aheadKnown ? Number(aheadRaw) : 0;
  const behind = behindKnown ? Number(behindRaw) : 0;
  const staged = Number((sync && sync.staged_changes) || 0);
  const unstaged = Number((sync && sync.unstaged_changes) || 0);
  const untracked = Number((sync && sync.untracked_changes) || 0);
  const dirty = !!(sync && sync.dirty);
  const changeCount = Math.max(0, staged + unstaged + untracked);
  const divergence = (aheadKnown && behindKnown)
    ? ('ahead ' + ahead + ' | behind ' + behind)
    : 'no upstream';
  const dirtyLabel = dirty ? ('dirty (' + changeCount + ')') : 'clean';
  const summary = branch + ' | ' + divergence + ' | ' + dirtyLabel;
  const lastFetch = _formatGitSyncLastFetch(sync);
  const githubRepo = (sync && typeof sync.github_repo === 'object' && sync.github_repo)
    ? sync.github_repo
    : null;
  const githubDetected = !!(githubRepo && githubRepo.detected);
  const githubRemote = String((githubRepo && githubRepo.remote) || '').trim();
  const githubRemoteUrl = String((githubRepo && githubRepo.remote_url) || '').trim();
  const githubName = String((githubRepo && (githubRepo.full_name || githubRepo.name)) || '').trim();
  const githubVisibility = String((githubRepo && githubRepo.visibility) || '').trim();
  const githubDefaultBranch = String((githubRepo && githubRepo.default_branch) || '').trim();
  const githubUrl = String((githubRepo && githubRepo.url) || '').trim();
  const githubReason = String((githubRepo && githubRepo.reason) || '').trim();
  const githubSource = String((githubRepo && githubRepo.source) || '').trim();
  const githubNameLabel = githubDetected ? (githubName || 'detected') : 'n/a';
  const githubVisibilityLabel = githubDetected ? (githubVisibility || 'unknown') : 'n/a';
  const githubDefaultBranchLabel = githubDetected ? (githubDefaultBranch || 'unknown') : 'n/a';
  const githubRepoTitleParts = [];
  if (githubName) githubRepoTitleParts.push('Repository: ' + githubName);
  if (githubRemote) githubRepoTitleParts.push('Remote: ' + githubRemote);
  if (githubRemoteUrl) githubRepoTitleParts.push('Remote URL: ' + githubRemoteUrl);
  if (githubUrl) githubRepoTitleParts.push('URL: ' + githubUrl);
  if (githubSource) githubRepoTitleParts.push('Source: ' + githubSource);
  if (githubReason) githubRepoTitleParts.push('Note: ' + githubReason);
  const githubRepoTitle = githubRepoTitleParts.length
    ? githubRepoTitleParts.join('\n')
    : 'GitHub repository metadata is unavailable.';

  let tone = 'ok';
  if (!trackingBranch || !aheadKnown || !behindKnown) tone = 'muted';
  if (dirty || (behindKnown && behind > 0)) tone = 'warn';

  _setGitSyncWidgetValue(
    'git-sync-widget-branch',
    branch,
    'Current branch: ' + branch,
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-remote',
    trackingRemote || 'none',
    trackingBranch
      ? ('Tracking branch: ' + trackingBranch)
      : 'No upstream tracking branch configured.',
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-ahead-behind',
    (aheadKnown && behindKnown) ? (ahead + ' / ' + behind) : 'n/a',
    (aheadKnown && behindKnown)
      ? ('Ahead: ' + ahead + ', Behind: ' + behind)
      : 'Ahead/behind unavailable (set upstream tracking to enable).',
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-last-fetch',
    lastFetch.label,
    lastFetch.title,
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-github-name',
    githubNameLabel,
    githubRepoTitle,
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-github-visibility',
    githubVisibilityLabel,
    githubDetected
      ? ('Visibility: ' + githubVisibilityLabel + (githubReason ? ('\nNote: ' + githubReason) : ''))
      : (githubReason || 'GitHub visibility metadata is unavailable.'),
  );
  _setGitSyncWidgetValue(
    'git-sync-widget-github-default-branch',
    githubDefaultBranchLabel,
    githubDetected
      ? ('Default branch: ' + githubDefaultBranchLabel + (githubReason ? ('\nNote: ' + githubReason) : ''))
      : (githubReason || 'GitHub default-branch metadata is unavailable.'),
  );
  _setGitSyncRepoUrl(githubUrl);

  let title = 'Branch: ' + branch;
  title += '\nTracking branch: ' + (trackingBranch || 'none');
  title += '\nTracking remote: ' + (trackingRemote || 'none');
  if (aheadKnown && behindKnown) {
    title += '\nAhead: ' + ahead + ', Behind: ' + behind;
  } else {
    title += '\nAhead/Behind: unavailable (set upstream tracking to enable)';
  }
  title += '\nLast fetch: ' + lastFetch.label;
  title += '\nChanges: staged ' + staged + ', unstaged ' + unstaged + ', untracked ' + untracked;
  if (githubDetected) {
    title += '\nGitHub repo: ' + (githubName || 'detected');
    title += '\nGitHub visibility: ' + (githubVisibility || 'unknown');
    title += '\nGitHub default branch: ' + (githubDefaultBranch || 'unknown');
    title += '\nGitHub remote: ' + (githubRemote || 'none');
    if (githubReason) title += '\nGitHub note: ' + githubReason;
  } else if (githubReason) {
    title += '\nGitHub: ' + githubReason;
  }

  _setGitSyncIndicator(summary, tone, title);
}

function scheduleGitSyncRefresh(opts = {}) {
  if (gitSyncRefreshTimer) {
    clearTimeout(gitSyncRefreshTimer);
    gitSyncRefreshTimer = null;
  }
  const delayRaw = Number(opts.delayMs);
  const delayMs = Number.isFinite(delayRaw) ? Math.max(0, Math.floor(delayRaw)) : 250;
  gitSyncRefreshTimer = setTimeout(() => {
    gitSyncRefreshTimer = null;
    refreshGitSyncStatus({
      repoPath: opts.repoPath || '',
      silent: opts.silent !== false,
      force: !!opts.force,
    });
  }, delayMs);
}

async function refreshGitSyncStatus(opts = {}) {
  const repoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (!repoPath) {
    gitSyncState = null;
    gitSyncBranchState = null;
    gitRemoteState = null;
    gitCommitWorkflowState = null;
    gitSigningState = null;
    _setGitSyncPullRequestUrl('');
    _clearGitSyncBranchOptions();
    _clearGitSyncWidgetDetails();
    _setGitSyncIndicator('No repo selected', 'muted', 'Select a repository path to view sync status');
    if (_isGitRemoteModalOpen()) {
      _clearGitRemoteView('Set a repository path first.');
    }
    if (_isGitSigningModalOpen()) {
      _clearGitSigningView('Set a repository path first.');
    }
    if (_isGitCommitModalOpen()) {
      _clearGitCommitWorkflowView('Set a repository path first.');
    }
    _syncGitSyncButtonState();
    return;
  }

  if (gitSyncBusyAction && !opts.force) {
    _syncGitSyncButtonState();
    return;
  }

  const response = await api('/api/git/sync/branches?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (repoPath !== currentRepoPath) {
    return;
  }
  if (response.error) {
    gitSyncState = null;
    gitSyncBranchState = null;
    _clearGitSyncWidgetDetails();
    _clearGitSyncBranchOptions('Branch list unavailable');
    const message = String(response.error || 'Unknown error');
    _setGitSyncIndicator(message, 'error', message);
    if (!opts.silent) toast('Could not load git sync status: ' + message, 'error');
    _syncGitSyncButtonState();
    return;
  }

  gitSyncBranchState = response;
  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  }
  _renderGitSyncBranchOptions(response, {
    preferredBranch: String(opts.preferredBranch || '').trim(),
  });
  if (_isGitRemoteModalOpen()) {
    await refreshGitRemotes({ repoPath, silent: true, force: !!opts.force });
  }
  if (_isGitSigningModalOpen()) {
    await refreshGitSigningSettings({ repoPath, silent: true, force: !!opts.force });
  }
  if (_isGitCommitModalOpen()) {
    await refreshGitCommitWorkflow({ repoPath, silent: true, force: !!opts.force });
  }
  _syncGitSyncButtonState();
}

async function refreshGitSyncBranches(opts = {}) {
  const repoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (!repoPath) {
    gitSyncBranchState = null;
    _clearGitSyncBranchOptions();
    _syncGitSyncButtonState();
    return;
  }

  if (gitSyncBusyAction && !opts.force) {
    _syncGitSyncButtonState();
    return;
  }

  const response = await api('/api/git/sync/branches?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (repoPath !== currentRepoPath) {
    return;
  }

  if (response.error) {
    gitSyncBranchState = null;
    const message = String(response.error || 'Unknown error');
    _clearGitSyncBranchOptions('Branch list unavailable');
    if (!opts.silent) toast('Could not load branch options: ' + message, 'error');
    _syncGitSyncButtonState();
    return;
  }

  gitSyncBranchState = response;
  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  }
  _renderGitSyncBranchOptions(response, {
    preferredBranch: String(opts.preferredBranch || '').trim(),
  });
  _syncGitSyncButtonState();
}

async function refreshGitSyncBranchesNow() {
  await refreshGitSyncBranches({ silent: false, force: true });
}

async function refreshGitSyncStatusNow() {
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'warn');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }
  await refreshGitSyncStatus({ repoPath, silent: false, force: true });
}

async function _runGitSyncAction(actionKey) {
  if (gitSyncBusyAction) return;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }

  const setUpstreamCheckbox = document.getElementById('git-sync-set-upstream');
  const setUpstream = !!(setUpstreamCheckbox && setUpstreamCheckbox.checked);
  const actions = {
    fetch: {
      endpoint: '/api/git/sync/fetch',
      running: 'Fetching remote updates...',
      successFallback: 'Fetch completed.',
      failurePrefix: 'Fetch failed: ',
    },
    pull: {
      endpoint: '/api/git/sync/pull',
      running: 'Pulling latest commits...',
      successFallback: 'Pull completed.',
      failurePrefix: 'Pull failed: ',
    },
    push: {
      endpoint: '/api/git/sync/push',
      running: setUpstream ? 'Pushing commits and setting upstream...' : 'Pushing local commits...',
      successFallback: setUpstream ? 'Push completed and upstream set.' : 'Push completed.',
      failurePrefix: 'Push failed: ',
      payload: {
        set_upstream: setUpstream,
      },
    },
    stash_pull: {
      endpoint: '/api/git/sync/stash-pull',
      running: 'Stashing changes and pulling...',
      successFallback: 'Stash + Pull completed.',
      failurePrefix: 'Stash + Pull failed: ',
    },
  };
  const action = actions[actionKey];
  if (!action) return;
  if (actionKey === 'push') {
    _setGitSyncPullRequestUrl('');
  }

  gitSyncBusyAction = actionKey;
  _syncGitSyncButtonState();
  _setGitSyncIndicator(action.running, 'muted', action.running);
  const requestPayload = Object.assign({ repo_path: repoPath }, action.payload || {});
  const response = await postJson(action.endpoint, requestPayload);
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSyncIndicator(message, 'error', message);
    toast(action.failurePrefix + message, 'error');
    if (actionKey === 'push' && response && response.error_type === 'signing_misconfigured') {
      const signingSettings = _gitSigningSettingsFromResponse(response.signing);
      if (signingSettings) {
        gitSigningState = signingSettings;
        if (_isGitSigningModalOpen()) {
          _applyGitSigningPayload(signingSettings, {
            statusText: 'Push blocked by signing guard.',
            statusTone: 'error',
          });
        }
        const issues = Array.isArray(signingSettings.issues) ? signingSettings.issues : [];
        if (issues.length) {
          toast('Signing issue: ' + String(issues[0]), 'info');
        } else {
          toast('Open Git Sync -> Signing to resolve signing validation issues.', 'info');
        }
      }
    }
    if (actionKey === 'push' && response && typeof response.auth_troubleshooting === 'object') {
      _setGithubAuthTroubleshooting(response.auth_troubleshooting);
      const summary = String(response.auth_troubleshooting.summary || '').trim();
      if (summary) {
        toast('Credential assistant: ' + summary, 'info');
      } else {
        toast('Credential assistant updated in GitHub Auth modal.', 'info');
      }
    }
    const recoverySteps = Array.isArray(response.recovery_steps) ? response.recovery_steps : [];
    if (recoverySteps.length) {
      toast('Recovery: ' + recoverySteps.join(' | '), 'info');
    }
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
    await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
    return;
  }

  if (actionKey === 'stash_pull' && response.stash_created) {
    toast('Local changes were stashed before pull.', 'info');
  }
  if (actionKey === 'push') {
    const pullRequest = (response && typeof response.pull_request === 'object' && response.pull_request)
      ? response.pull_request
      : null;
    const pullRequestUrl = String(
      (pullRequest && pullRequest.url) || response.pull_request_url || ''
    ).trim();
    _setGitSyncPullRequestUrl(pullRequestUrl);
    if (response.set_upstream && response.remote && response.branch) {
      toast('Upstream set to ' + response.remote + '/' + response.branch + '.', 'info');
    }
    if (pullRequestUrl) {
      toast('Pull request URL ready. Use Open PR or Copy PR URL.', 'info');
    } else {
      const reason = String((pullRequest && pullRequest.reason) || '').trim();
      if (reason) {
        toast('Push completed; PR URL unavailable: ' + reason, 'info');
      }
    }
  }

  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  } else {
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
  }
  if (response.branches) {
    gitSyncBranchState = response.branches;
    _renderGitSyncBranchOptions(response.branches, {
      preferredBranch: String(response.sync && response.sync.branch || '').trim(),
    });
  } else {
    await refreshGitSyncBranches({ repoPath, silent: true, force: true });
  }
  if (_isGitCommitModalOpen()) {
    await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
  }
  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });

  toast(String(response.message || action.successFallback), 'success');
}

async function gitSyncFetch() {
  await _runGitSyncAction('fetch');
}

async function gitSyncPull() {
  await _runGitSyncAction('pull');
}

async function gitSyncPush() {
  await _runGitSyncAction('push');
}

function gitSyncOpenRepoPage() {
  const url = String(gitSyncGithubRepoUrl || '').trim();
  if (!url) {
    toast('No GitHub repository URL is available yet.', 'info');
    _syncGitSyncButtonState();
    return;
  }
  const popup = window.open(url, '_blank', 'noopener,noreferrer');
  if (!popup) {
    toast('Could not open GitHub repository URL.', 'error');
    return;
  }
  toast('Opened GitHub repository page.', 'success');
}

function gitSyncOpenPullRequest() {
  const url = String(gitSyncPullRequestUrl || '').trim();
  if (!url) {
    toast('No pull request URL is available yet.', 'info');
    _syncGitSyncButtonState();
    return;
  }
  const popup = window.open(url, '_blank', 'noopener,noreferrer');
  if (!popup) {
    toast('Could not open pull request URL. Use Copy PR URL instead.', 'error');
    return;
  }
  toast('Opened pull request URL.', 'success');
}

async function gitSyncCopyPullRequestUrl() {
  const url = String(gitSyncPullRequestUrl || '').trim();
  if (!url) {
    toast('No pull request URL is available yet.', 'info');
    _syncGitSyncButtonState();
    return;
  }
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(url);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = url;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      textarea.remove();
    }
    toast('Copied pull request URL.', 'success');
  } catch (e) {
    toast('Could not copy pull request URL.', 'error');
  }
}

async function gitSyncStashAndPull() {
  await _runGitSyncAction('stash_pull');
}

async function gitSyncSwitchBranch() {
  if (gitSyncBusyAction) return;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }

  const target = _currentGitSyncBranchTarget();
  if (!target) {
    toast('Select a branch first.', 'warn');
    _syncGitSyncButtonState();
    return;
  }

  const currentBranch = String((gitSyncState && gitSyncState.branch) || '').trim();
  if (target.branch_type === 'local' && currentBranch && target.branch === currentBranch) {
    toast('Already on branch ' + currentBranch + '.', 'info');
    return;
  }

  const allowDirty = _gitSyncAllowDirtySwitchEnabled();
  const running = target.branch_type === 'remote'
    ? 'Checking out remote branch...'
    : 'Switching branch...';
  gitSyncBusyAction = 'checkout_branch';
  _syncGitSyncButtonState();
  _setGitSyncIndicator(running, 'muted', running);

  const response = await postJson('/api/git/sync/checkout', {
    repo_path: repoPath,
    branch: target.branch,
    branch_type: target.branch_type,
    allow_dirty: allowDirty,
  });
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSyncIndicator(message, 'error', message);
    toast('Branch switch failed: ' + message, 'error');
    const recoverySteps = Array.isArray(response.recovery_steps) ? response.recovery_steps : [];
    if (recoverySteps.length) {
      toast('Recovery: ' + recoverySteps.join(' | '), 'info');
    }
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
    await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
    return;
  }

  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  }
  _setGitSyncPullRequestUrl('');
  if (response.branches) {
    gitSyncBranchState = response.branches;
    _renderGitSyncBranchOptions(response.branches, {
      preferredBranch: String(response.sync && response.sync.branch || '').trim(),
    });
  } else {
    await refreshGitSyncBranches({ repoPath, silent: true, force: true });
  }
  if (_isGitCommitModalOpen()) {
    await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
  }
  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });

  toast(String(response.message || 'Branch switched.'), 'success');
}

async function gitSyncCreateBranch() {
  if (gitSyncBusyAction) return;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }

  const branchInput = document.getElementById('git-sync-branch-create-name');
  const branchName = String(branchInput ? branchInput.value : '').trim();
  if (!branchName) {
    toast('Enter a branch name first.', 'warn');
    _syncGitSyncButtonState();
    return;
  }

  const allowDirty = _gitSyncAllowDirtySwitchEnabled();
  const running = 'Creating branch and checking it out...';
  gitSyncBusyAction = 'create_branch';
  _syncGitSyncButtonState();
  _setGitSyncIndicator(running, 'muted', running);

  const response = await postJson('/api/git/sync/branch/create', {
    repo_path: repoPath,
    branch_name: branchName,
    allow_dirty: allowDirty,
  });
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSyncIndicator(message, 'error', message);
    toast('Branch creation failed: ' + message, 'error');
    const recoverySteps = Array.isArray(response.recovery_steps) ? response.recovery_steps : [];
    if (recoverySteps.length) {
      toast('Recovery: ' + recoverySteps.join(' | '), 'info');
    }
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
    await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });
    return;
  }

  if (branchInput) branchInput.value = '';
  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  }
  _setGitSyncPullRequestUrl('');
  if (response.branches) {
    gitSyncBranchState = response.branches;
    _renderGitSyncBranchOptions(response.branches, {
      preferredBranch: String(response.sync && response.sync.branch || '').trim(),
    });
  } else {
    await refreshGitSyncBranches({ repoPath, silent: true, force: true });
  }
  if (_isGitCommitModalOpen()) {
    await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
  }
  _syncGitSyncButtonState();
  await refreshWorkspaceRepos({ silent: true, includeBranches: true, preserveStatus: true });

  toast(String(response.message || 'Branch created.'), 'success');
}

function _isGitRemoteModalOpen() {
  const overlay = document.getElementById('git-remote-overlay');
  return !!(overlay && !overlay.classList.contains('hidden'));
}

function _setGitRemoteRepoPathLabel(path) {
  const repoEl = document.getElementById('git-remote-repo-path');
  if (!repoEl) return;
  const repoPath = String(path || '').trim();
  repoEl.textContent = repoPath || 'No repo selected';
  repoEl.title = repoPath || 'No repository selected';
}

function _setGitRemoteDefaultLabel(payload) {
  const el = document.getElementById('git-remote-default');
  if (!el) return;
  const data = payload && typeof payload === 'object' ? payload : {};
  const defaultRemote = String(data.default_remote || '').trim();
  const source = String(data.default_remote_source || '').trim();
  const configuredMissing = !!data.configured_default_missing;
  if (!defaultRemote) {
    el.textContent = 'No default remote configured.';
    el.title = 'Set a default remote to control push target selection.';
    return;
  }
  let sourceText = '';
  if (source === 'config') sourceText = 'from remote.pushDefault';
  else if (source === 'tracking') sourceText = 'from current tracking branch';
  else if (source === 'origin') sourceText = 'fallback to origin';
  const suffix = sourceText ? (' (' + sourceText + ')') : '';
  const warning = configuredMissing
    ? ' Note: configured default remote no longer exists.'
    : '';
  el.textContent = defaultRemote + suffix + warning;
  el.title = 'Default remote: ' + defaultRemote + (sourceText ? ('\nSource: ' + sourceText) : '');
}

function _setGitRemoteStatus(text, tone = 'muted') {
  const el = document.getElementById('git-remote-status');
  if (!el) return;
  const toneValue = ['ok', 'warn', 'error', 'muted'].includes(tone) ? tone : 'muted';
  el.dataset.tone = toneValue;
  el.textContent = String(text || '');
}

function _setGitRemoteAddHelp(text, tone = 'muted') {
  const el = document.getElementById('git-remote-add-help');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

function _renderGitRemoteRows(payload) {
  const tbody = document.getElementById('git-remote-body');
  if (!tbody) return;
  const data = payload && typeof payload === 'object' ? payload : {};
  const rows = Array.isArray(data.remotes) ? data.remotes : [];
  if (!rows.length) {
    tbody.innerHTML = '<tr><td colspan="3" style="color:var(--text2)">No remotes configured for this repository.</td></tr>';
    return;
  }

  const busy = !!gitSyncBusyAction;
  const trackingRemote = String(data.tracking_remote || '').trim();
  tbody.innerHTML = rows.map(entry => {
    const name = String(entry && entry.name || '').trim();
    if (!name) return '';
    const fetchUrl = String(entry && entry.fetch_url || '').trim();
    const pushUrl = String(entry && entry.push_url || '').trim() || fetchUrl;
    const isDefault = !!(entry && entry.is_default);
    const isTrackingRemote = !!(entry && entry.is_tracking_remote) || (!!trackingRemote && trackingRemote === name);
    const encodedName = encodeURIComponent(name);

    const badges = [];
    if (isDefault) badges.push('<span class="git-remote-badge default">default</span>');
    if (isTrackingRemote) badges.push('<span class="git-remote-badge tracking">tracking</span>');
    if (!badges.length) badges.push('<span class="git-remote-badge">remote</span>');

    const setDefaultDisabled = busy || isDefault;
    const removeDisabled = busy;
    const removeLabel = name === 'origin' ? 'Remove origin' : 'Remove';

    const urlLines = []
      .concat(fetchUrl ? ['<span class="git-remote-url"><strong>fetch:</strong> ' + esc(fetchUrl) + '</span>'] : [])
      .concat(pushUrl ? ['<span class="git-remote-url"><strong>push:</strong> ' + esc(pushUrl) + '</span>'] : []);
    if (!urlLines.length) {
      urlLines.push('<span class="git-remote-url">No URL configured.</span>');
    }

    return '<tr>'
      + '<td class="name">' + esc(name) + '<div style="margin-top:6px">' + badges.join('') + '</div></td>'
      + '<td>' + urlLines.join('') + '</td>'
      + '<td><div class="git-remote-actions">'
      + '<button class="btn" type="button" data-enabled="' + (isDefault ? '0' : '1') + '" onclick="gitRemoteSetDefault(decodeURIComponent(\'' + encodedName + '\'))"'
      + (setDefaultDisabled ? ' disabled' : '') + '>Set Default</button>'
      + '<button class="btn btn-danger" type="button" data-enabled="1" onclick="gitRemoteRemove(decodeURIComponent(\'' + encodedName + '\'))"'
      + (removeDisabled ? ' disabled' : '') + '>' + esc(removeLabel) + '</button>'
      + '</div></td>'
      + '</tr>';
  }).join('');
}

function _syncGitRemoteControls() {
  const hasRepo = !!_activeRepoPathForGitSync();
  const busy = !!gitSyncBusyAction;
  const disabled = !hasRepo || busy;
  const payload = gitRemoteState && typeof gitRemoteState === 'object' ? gitRemoteState : null;
  const defaultRemote = String(payload && payload.default_remote || '').trim();
  const nameInput = document.getElementById('git-remote-name-input');
  const urlInput = document.getElementById('git-remote-url-input');
  const setDefaultCheckbox = document.getElementById('git-remote-add-default-check');
  const name = String(nameInput ? nameInput.value : '').trim();
  const url = String(urlInput ? urlInput.value : '').trim();

  const refreshBtn = document.getElementById('git-remote-refresh-btn');
  if (refreshBtn) refreshBtn.disabled = disabled;
  const clearDefaultBtn = document.getElementById('git-remote-clear-default-btn');
  if (clearDefaultBtn) clearDefaultBtn.disabled = disabled || !defaultRemote;
  const validateBtn = document.getElementById('git-remote-validate-btn');
  if (validateBtn) validateBtn.disabled = disabled || !url;
  const addBtn = document.getElementById('git-remote-add-btn');
  if (addBtn) addBtn.disabled = disabled || !name || !url;
  if (nameInput) nameInput.disabled = disabled;
  if (urlInput) urlInput.disabled = disabled;
  if (setDefaultCheckbox) setDefaultCheckbox.disabled = disabled;
  document.querySelectorAll('#git-remote-body button[data-enabled]').forEach(btn => {
    const canRun = String(btn.getAttribute('data-enabled') || '') === '1';
    btn.disabled = disabled || !canRun;
  });
}

function _applyGitRemotePayload(payload, opts = {}) {
  if (!payload || typeof payload !== 'object') return;
  gitRemoteState = payload;
  _setGitRemoteRepoPathLabel(payload.repo_path || _activeRepoPathForGitSync());
  _setGitRemoteDefaultLabel(payload);
  _renderGitRemoteRows(payload);
  if (payload.sync) {
    gitSyncState = payload.sync;
    _renderGitSyncState(payload.sync);
  }
  if (opts.statusText) {
    _setGitRemoteStatus(opts.statusText, opts.statusTone || 'muted');
  }
  _syncGitRemoteControls();
}

function _clearGitRemoteView(message = 'No repository selected.') {
  gitRemoteState = null;
  _setGitRemoteRepoPathLabel('');
  _setGitRemoteDefaultLabel(null);
  _renderGitRemoteRows({ remotes: [] });
  _setGitRemoteStatus(message, 'muted');
  _syncGitRemoteControls();
}

async function showGitRemoteModal() {
  _openOverlay('git-remote-overlay', '#git-remote-name-input');
  _setGitRemoteAddHelp('Use HTTPS or SSH URL formats only.', 'muted');
  const repoPath = _activeRepoPathForGitSync();
  _setGitRemoteRepoPathLabel(repoPath);
  if (!repoPath) {
    _clearGitRemoteView('Set a repository path first.');
    return;
  }
  await refreshGitRemotes({ repoPath, silent: true, force: true });
}

function hideGitRemoteModal() {
  _closeOverlay('git-remote-overlay');
}

async function refreshGitRemotes(opts = {}) {
  const repoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (!repoPath) {
    _clearGitRemoteView('Set a repository path first.');
    return;
  }
  _setGitRemoteRepoPathLabel(repoPath);
  if (gitSyncBusyAction && !opts.force) {
    _syncGitRemoteControls();
    return;
  }

  if (!opts.silent) {
    _setGitRemoteStatus('Loading remotes...', 'muted');
  }
  const response = await api('/api/git/sync/remotes?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (repoPath !== currentRepoPath) {
    return;
  }
  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitRemoteStatus(message, 'error');
    if (!opts.silent) toast('Could not load remotes: ' + message, 'error');
    _syncGitRemoteControls();
    return;
  }

  _applyGitRemotePayload(
    response,
    opts.silent
      ? {}
      : {
          statusText: String(response.message || 'Remote list updated.'),
          statusTone: 'ok',
        }
  );
}

async function refreshGitRemotesNow() {
  await refreshGitRemotes({ silent: false, force: true });
}

async function _runGitRemoteAction(actionKey, endpoint, payload, opts = {}) {
  if (gitSyncBusyAction) return null;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    _clearGitRemoteView('Set a repository path first.');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return null;
  }

  gitSyncBusyAction = actionKey;
  _syncGitSyncButtonState();
  _setGitRemoteStatus(String(opts.running || 'Applying remote update...'), 'muted');
  const requestPayload = Object.assign({ repo_path: repoPath }, payload || {});
  const response = await postJson(endpoint, requestPayload);
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitRemoteStatus(message, 'error');
    toast(String(opts.failurePrefix || 'Remote update failed: ') + message, 'error');
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
    if (_isGitRemoteModalOpen()) {
      await refreshGitRemotes({ repoPath, silent: true, force: true });
    }
    return null;
  }

  if (response.remotes) {
    _applyGitRemotePayload(response.remotes, {
      statusText: String(response.message || opts.successFallback || 'Remote settings updated.'),
      statusTone: 'ok',
    });
  } else if (_isGitRemoteModalOpen()) {
    await refreshGitRemotes({ repoPath, silent: true, force: true });
  }
  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  } else {
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
  }

  toast(String(response.message || opts.successFallback || 'Remote update completed.'), 'success');
  return response;
}

async function gitRemoteValidateUrl() {
  const urlInput = document.getElementById('git-remote-url-input');
  const remoteUrl = String(urlInput ? urlInput.value : '').trim();
  if (!remoteUrl) {
    _setGitRemoteAddHelp('Enter a remote URL first.', 'warn');
    _syncGitRemoteControls();
    return;
  }

  _setGitRemoteAddHelp('Validating remote URL...', 'muted');
  try {
    const response = await postJson('/api/git/sync/remotes/validate', {
      remote_url: remoteUrl,
    });
    if (response.error) {
      const message = String(response.error || 'Remote URL is invalid.');
      _setGitRemoteAddHelp(message, 'error');
      toast('Remote URL validation failed: ' + message, 'error');
      return;
    }
    const transport = String(response.transport || '').trim().toUpperCase() || 'REMOTE';
    _setGitRemoteAddHelp(transport + ' URL is valid.', 'ok');
    toast('Remote URL is valid (' + transport + ').', 'success');
  } catch (err) {
    const message = err && err.message ? err.message : String(err);
    _setGitRemoteAddHelp(message, 'error');
    toast('Remote URL validation failed: ' + message, 'error');
  }
}

async function gitRemoteAdd() {
  const nameInput = document.getElementById('git-remote-name-input');
  const urlInput = document.getElementById('git-remote-url-input');
  const defaultCheckbox = document.getElementById('git-remote-add-default-check');
  const remoteName = String(nameInput ? nameInput.value : '').trim();
  const remoteUrl = String(urlInput ? urlInput.value : '').trim();
  const setDefault = !!(defaultCheckbox && defaultCheckbox.checked);

  if (!remoteName || !remoteUrl) {
    _setGitRemoteStatus('Remote name and URL are required.', 'warn');
    _syncGitRemoteControls();
    return;
  }

  const response = await _runGitRemoteAction(
    'git_remote_add',
    '/api/git/sync/remotes/add',
    {
      name: remoteName,
      remote_url: remoteUrl,
      set_default: setDefault,
    },
    {
      running: 'Adding remote...',
      successFallback: 'Remote added.',
      failurePrefix: 'Add remote failed: ',
    }
  );
  if (!response) return;

  if (nameInput) nameInput.value = '';
  if (urlInput) urlInput.value = '';
  if (defaultCheckbox) defaultCheckbox.checked = false;
  _setGitRemoteAddHelp('Use HTTPS or SSH URL formats only.', 'muted');
  _syncGitRemoteControls();
}

async function gitRemoteRemove(name) {
  const remoteName = String(name || '').trim();
  if (!remoteName) return;
  const proceed = confirm('Remove remote "' + remoteName + '"?');
  if (!proceed) return;

  await _runGitRemoteAction(
    'git_remote_remove',
    '/api/git/sync/remotes/remove',
    { name: remoteName },
    {
      running: 'Removing remote ' + remoteName + '...',
      successFallback: 'Remote removed.',
      failurePrefix: 'Remove remote failed: ',
    }
  );
}

async function gitRemoteSetDefault(name) {
  const remoteName = String(name || '').trim();
  if (!remoteName) return;

  await _runGitRemoteAction(
    'git_remote_set_default',
    '/api/git/sync/remotes/default',
    { name: remoteName },
    {
      running: 'Setting default remote to ' + remoteName + '...',
      successFallback: 'Default remote updated.',
      failurePrefix: 'Set default failed: ',
    }
  );
}

async function gitRemoteClearDefault() {
  await _runGitRemoteAction(
    'git_remote_clear_default',
    '/api/git/sync/remotes/default',
    { clear: true },
    {
      running: 'Clearing default remote...',
      successFallback: 'Default remote cleared.',
      failurePrefix: 'Clear default failed: ',
    }
  );
}

function _isGitSigningModalOpen() {
  const overlay = document.getElementById('git-signing-overlay');
  return !!(overlay && !overlay.classList.contains('hidden'));
}

function _setGitSigningRepoPathLabel(path) {
  const el = document.getElementById('git-signing-repo-path');
  if (!el) return;
  const repoPath = String(path || '').trim();
  el.textContent = repoPath || 'No repo selected';
  el.title = repoPath || 'No repository selected';
}

function _setGitSigningSummary(text) {
  const el = document.getElementById('git-signing-summary');
  if (!el) return;
  el.textContent = String(text || '');
}

function _setGitSigningStatus(text, tone = 'muted') {
  const el = document.getElementById('git-signing-status');
  if (!el) return;
  const toneValue = ['ok', 'warn', 'error', 'muted'].includes(tone) ? tone : 'muted';
  el.dataset.tone = toneValue;
  el.textContent = String(text || '');
}

function _renderGitSigningChecks(payload) {
  const el = document.getElementById('git-signing-checks');
  if (!el) return;
  const checks = Array.isArray(payload && payload.checks) ? payload.checks : [];
  if (!checks.length) {
    el.innerHTML = '<div class="state-card">No signing checks available.</div>';
    return;
  }
  el.innerHTML = checks.map(check => {
    const ok = !!(check && check.ok);
    const label = String(check && check.label || check && check.key || 'check').trim();
    const detail = String(check && check.detail || '').trim();
    return ''
      + '<div class="git-signing-check">'
      + '<div class="git-signing-check-title">'
      + '<span class="git-signing-badge ' + (ok ? 'ok' : 'fail') + '">' + (ok ? 'OK' : 'FIX') + '</span>'
      + '<span>' + esc(label) + '</span>'
      + '</div>'
      + '<div class="git-signing-check-detail">' + esc(detail || (ok ? 'Check passed.' : 'Check failed.')) + '</div>'
      + '</div>';
  }).join('');
}

function _syncGitSigningControls() {
  const hasRepo = !!_activeRepoPathForGitSync();
  const busy = !!gitSyncBusyAction;
  const disabled = busy || !hasRepo;
  const modeEl = document.getElementById('git-signing-mode');
  const keyEl = document.getElementById('git-signing-key');
  const clearKeyEl = document.getElementById('git-signing-clear-key');
  const commitEl = document.getElementById('git-signing-commit-sign');
  const tagEl = document.getElementById('git-signing-tag-sign');
  const guardEl = document.getElementById('git-signing-require-push-guard');
  const refreshBtn = document.getElementById('git-signing-refresh-btn');
  const validateBtn = document.getElementById('git-signing-validate-btn');
  const saveBtn = document.getElementById('git-signing-save-btn');

  const signingEnabled = !!((commitEl && commitEl.checked) || (tagEl && tagEl.checked));
  if (modeEl) modeEl.disabled = disabled;
  if (clearKeyEl) clearKeyEl.disabled = disabled;
  if (keyEl) keyEl.disabled = disabled || !!(clearKeyEl && clearKeyEl.checked);
  if (commitEl) commitEl.disabled = disabled;
  if (tagEl) tagEl.disabled = disabled;
  if (guardEl) {
    if (!signingEnabled) guardEl.checked = false;
    guardEl.disabled = disabled || !signingEnabled;
  }
  if (refreshBtn) refreshBtn.disabled = disabled;
  if (validateBtn) validateBtn.disabled = disabled;
  if (saveBtn) saveBtn.disabled = disabled;
}

function _gitSigningSettingsFromResponse(response) {
  if (!response || typeof response !== 'object') return null;
  if (response.settings && typeof response.settings === 'object') return response.settings;
  return response;
}

function _gitSigningDraftPayload() {
  const modeEl = document.getElementById('git-signing-mode');
  const keyEl = document.getElementById('git-signing-key');
  const clearKeyEl = document.getElementById('git-signing-clear-key');
  const commitEl = document.getElementById('git-signing-commit-sign');
  const tagEl = document.getElementById('git-signing-tag-sign');
  const guardEl = document.getElementById('git-signing-require-push-guard');
  return {
    mode: String(modeEl ? modeEl.value : 'gpg').trim() || 'gpg',
    signing_key: String(keyEl ? keyEl.value : '').trim(),
    clear_signing_key: !!(clearKeyEl && clearKeyEl.checked),
    commit_sign: !!(commitEl && commitEl.checked),
    tag_sign: !!(tagEl && tagEl.checked),
    require_push_guard: !!(guardEl && guardEl.checked),
  };
}

function _applyGitSigningPayload(payload, opts = {}) {
  if (!payload || typeof payload !== 'object') return;
  gitSigningState = payload;
  _setGitSigningRepoPathLabel(payload.repo_path || _activeRepoPathForGitSync());

  const modeEl = document.getElementById('git-signing-mode');
  const keyEl = document.getElementById('git-signing-key');
  const clearKeyEl = document.getElementById('git-signing-clear-key');
  const commitEl = document.getElementById('git-signing-commit-sign');
  const tagEl = document.getElementById('git-signing-tag-sign');
  const guardEl = document.getElementById('git-signing-require-push-guard');

  if (modeEl) modeEl.value = String(payload.mode || 'gpg').trim() === 'ssh' ? 'ssh' : 'gpg';
  if (keyEl) keyEl.value = String(payload.signing_key || '');
  if (clearKeyEl) clearKeyEl.checked = false;
  if (commitEl) commitEl.checked = !!payload.commit_sign;
  if (tagEl) tagEl.checked = !!payload.tag_sign;
  if (guardEl) guardEl.checked = !!payload.require_push_guard;

  const enabled = !!payload.enabled;
  const valid = !!payload.valid;
  const modeLabel = String(payload.mode || 'gpg').toUpperCase();
  const issueCount = Array.isArray(payload.issues) ? payload.issues.length : 0;
  if (!enabled) {
    _setGitSigningSummary('Signing is currently disabled for commits and tags.');
  } else if (valid) {
    _setGitSigningSummary('Signing enabled (' + modeLabel + ') and validation passed.');
  } else {
    _setGitSigningSummary(
      'Signing enabled (' + modeLabel + ') but validation found ' + issueCount + ' issue(s).'
    );
  }

  _renderGitSigningChecks(payload);
  if (opts.statusText) {
    _setGitSigningStatus(opts.statusText, opts.statusTone || 'muted');
  }
  if (payload.sync) {
    gitSyncState = payload.sync;
    _renderGitSyncState(payload.sync);
  }
  _syncGitSigningControls();
}

function _clearGitSigningView(message = 'No repository selected.') {
  gitSigningState = null;
  _setGitSigningRepoPathLabel('');
  _setGitSigningSummary('No signing settings loaded.');
  _renderGitSigningChecks({ checks: [] });
  _setGitSigningStatus(message, 'muted');
  _syncGitSigningControls();
}

async function showGitSigningModal() {
  _openOverlay('git-signing-overlay', '#git-signing-mode');
  const repoPath = _activeRepoPathForGitSync();
  _setGitSigningRepoPathLabel(repoPath);
  if (!repoPath) {
    _clearGitSigningView('Set a repository path first.');
    return;
  }
  await refreshGitSigningSettings({ repoPath, silent: true, force: true });
}

function hideGitSigningModal() {
  _closeOverlay('git-signing-overlay');
}

async function refreshGitSigningSettings(opts = {}) {
  const repoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (!repoPath) {
    _clearGitSigningView('Set a repository path first.');
    return;
  }
  _setGitSigningRepoPathLabel(repoPath);
  if (gitSyncBusyAction && !opts.force) {
    _syncGitSigningControls();
    return;
  }

  if (!opts.silent) _setGitSigningStatus('Loading signing settings...', 'muted');
  const response = await api('/api/git/signing?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (repoPath !== currentRepoPath) return;

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSigningStatus(message, 'error');
    if (!opts.silent) toast('Could not load signing settings: ' + message, 'error');
    _syncGitSigningControls();
    return;
  }

  const settings = _gitSigningSettingsFromResponse(response);
  _applyGitSigningPayload(
    settings,
    opts.silent
      ? {}
      : {
          statusText: String(settings && settings.message || 'Signing settings loaded.'),
          statusTone: 'ok',
        }
  );
}

async function refreshGitSigningSettingsNow() {
  await refreshGitSigningSettings({ silent: false, force: true });
}

async function validateGitSigningSettings() {
  if (gitSyncBusyAction) return;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    _clearGitSigningView('Set a repository path first.');
    return;
  }

  gitSyncBusyAction = 'git_signing_validate';
  _syncGitSyncButtonState();
  _setGitSigningStatus('Validating signing settings...', 'muted');
  const response = await postJson(
    '/api/git/signing/validate',
    Object.assign({ repo_path: repoPath }, _gitSigningDraftPayload())
  );
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSigningStatus(message, 'error');
    toast('Signing validation failed: ' + message, 'error');
    return;
  }

  const settings = _gitSigningSettingsFromResponse(response);
  _applyGitSigningPayload(settings, {
    statusText: String(response.message || 'Signing validation complete.'),
    statusTone: settings && settings.valid ? 'ok' : 'warn',
  });
  toast(String(response.message || 'Signing validation complete.'), settings && settings.valid ? 'success' : 'info');
}

async function saveGitSigningSettings() {
  if (gitSyncBusyAction) return;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    _clearGitSigningView('Set a repository path first.');
    return;
  }

  gitSyncBusyAction = 'git_signing_save';
  _syncGitSyncButtonState();
  _setGitSigningStatus('Saving signing settings...', 'muted');
  const response = await postJson(
    '/api/git/signing',
    Object.assign({ repo_path: repoPath }, _gitSigningDraftPayload())
  );
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitSigningStatus(message, 'error');
    toast('Could not save signing settings: ' + message, 'error');
    return;
  }

  const settings = _gitSigningSettingsFromResponse(response);
  _applyGitSigningPayload(settings, {
    statusText: String(response.message || 'Signing settings saved.'),
    statusTone: settings && settings.valid ? 'ok' : 'warn',
  });
  toast(String(response.message || 'Signing settings saved.'), settings && settings.valid ? 'success' : 'info');
}

function _isGitCommitModalOpen() {
  const overlay = document.getElementById('git-commit-overlay');
  return !!(overlay && !overlay.classList.contains('hidden'));
}

function _setGitCommitRepoPathLabel(path) {
  const repoEl = document.getElementById('git-commit-repo-path');
  if (!repoEl) return;
  const repoPath = String(path || '').trim();
  repoEl.textContent = repoPath || 'No repo selected';
  repoEl.title = repoPath || 'No repository selected';
}

function _setGitCommitStatus(text, tone = 'muted') {
  const el = document.getElementById('git-commit-status');
  if (!el) return;
  const toneValue = ['ok', 'warn', 'error', 'muted'].includes(tone) ? tone : 'muted';
  el.dataset.tone = toneValue;
  el.textContent = String(text || '');
}

function _formatGitCommitTimestamp(rawValue) {
  const value = String(rawValue || '').trim();
  if (!value) return 'n/a';
  const ts = Date.parse(value);
  if (!Number.isFinite(ts)) return value;
  return new Date(ts).toLocaleString();
}

function _renderGitCommitLastSummary(lastCommit) {
  const el = document.getElementById('git-commit-last-summary');
  if (!el) return;
  if (!lastCommit || !lastCommit.available) {
    el.textContent = 'No commits yet.';
    return;
  }
  const shortHash = String(lastCommit.short_hash || '').trim();
  const fullHash = String(lastCommit.hash || '').trim();
  const author = String(lastCommit.author_name || '').trim() || 'Unknown author';
  const authoredAt = _formatGitCommitTimestamp(lastCommit.authored_at);
  const subject = String(lastCommit.subject || '').trim() || '(no subject)';
  const hashLabel = shortHash || fullHash || 'n/a';
  const lines = [
    'Hash: ' + hashLabel,
    'Author: ' + author,
    'Time: ' + authoredAt,
    'Subject: ' + subject,
  ];
  el.textContent = lines.join('\n');
  if (fullHash) {
    el.title = 'Full hash: ' + fullHash;
  }
}

function _renderGitCommitFileRows(files) {
  const tbody = document.getElementById('git-commit-files-body');
  if (!tbody) return;
  const rows = Array.isArray(files) ? files : [];
  if (!rows.length) {
    tbody.innerHTML = '<tr><td colspan="3" style="color:var(--text2)">No changed files in this repository.</td></tr>';
    return;
  }

  const busy = !!gitSyncBusyAction;
  tbody.innerHTML = rows.map(entry => {
    const path = String(entry && entry.path || '').trim();
    if (!path) return '';
    const canStage = !!(entry && entry.can_stage);
    const canUnstage = !!(entry && entry.can_unstage);
    const encodedPath = encodeURIComponent(path);

    const badges = [];
    if (entry && entry.staged) badges.push('<span class="git-commit-state-badge staged">staged</span>');
    if (entry && entry.unstaged) badges.push('<span class="git-commit-state-badge unstaged">unstaged</span>');
    if (entry && entry.untracked) badges.push('<span class="git-commit-state-badge untracked">untracked</span>');
    if (!badges.length) badges.push('<span class="git-commit-state-badge">clean</span>');

    const stageDisabled = busy || !canStage;
    const unstageDisabled = busy || !canUnstage;
    return '<tr>'
      + '<td class="path">' + esc(path) + '</td>'
      + '<td><div class="git-commit-state-badges">' + badges.join('') + '</div></td>'
      + '<td><div class="git-commit-file-actions">'
      + '<button class="btn" type="button" data-kind="stage" data-enabled="' + (canStage ? '1' : '0') + '" onclick="gitCommitStagePath(decodeURIComponent(\'' + encodedPath + '\'))"'
      + (stageDisabled ? ' disabled' : '') + '>Stage</button>'
      + '<button class="btn" type="button" data-kind="unstage" data-enabled="' + (canUnstage ? '1' : '0') + '" onclick="gitCommitUnstagePath(decodeURIComponent(\'' + encodedPath + '\'))"'
      + (unstageDisabled ? ' disabled' : '') + '>Unstage</button>'
      + '</div></td>'
      + '</tr>';
  }).join('');
}

function _syncGitCommitControls() {
  const busy = !!gitSyncBusyAction;
  const hasRepo = !!_activeRepoPathForGitSync();
  const disabled = busy || !hasRepo;
  const workflow = gitCommitWorkflowState && typeof gitCommitWorkflowState === 'object'
    ? gitCommitWorkflowState
    : null;
  const counts = workflow && workflow.counts && typeof workflow.counts === 'object'
    ? workflow.counts
    : {};
  const stagedCount = Number(counts && counts.staged || 0);
  const stageablePaths = Array.isArray(workflow && workflow.stageable_paths) ? workflow.stageable_paths : [];
  const unstageablePaths = Array.isArray(workflow && workflow.unstageable_paths) ? workflow.unstageable_paths : [];
  const messageEl = document.getElementById('git-commit-message');
  const commitMessage = String(messageEl ? messageEl.value : '').trim();

  const refreshBtn = document.getElementById('git-commit-refresh-btn');
  if (refreshBtn) refreshBtn.disabled = disabled;
  const stageAllBtn = document.getElementById('git-commit-stage-all-btn');
  if (stageAllBtn) stageAllBtn.disabled = disabled || stageablePaths.length <= 0;
  const unstageAllBtn = document.getElementById('git-commit-unstage-all-btn');
  if (unstageAllBtn) unstageAllBtn.disabled = disabled || unstageablePaths.length <= 0;
  document.querySelectorAll('#git-commit-files-body button[data-enabled]').forEach(btn => {
    const canRun = String(btn.getAttribute('data-enabled') || '') === '1';
    btn.disabled = disabled || !canRun;
  });
  if (messageEl) messageEl.disabled = !hasRepo || busy;
  const createBtn = document.getElementById('git-commit-create-btn');
  if (createBtn) createBtn.disabled = disabled || stagedCount <= 0 || !commitMessage;
}

function _applyGitCommitWorkflowResponse(payload, opts = {}) {
  if (!payload || typeof payload !== 'object') return;
  gitCommitWorkflowState = payload;
  _setGitCommitRepoPathLabel(payload.repo_path || _activeRepoPathForGitSync());
  _renderGitCommitFileRows(payload.files || []);
  _renderGitCommitLastSummary(payload.last_commit || null);
  const counts = payload && payload.counts && typeof payload.counts === 'object'
    ? payload.counts
    : {};
  const staged = Number(counts.staged || 0);
  const unstaged = Number(counts.unstaged || 0);
  const untracked = Number(counts.untracked || 0);
  const total = Number(counts.total_changed || (staged + unstaged + untracked) || 0);
  const summaryEl = document.getElementById('git-commit-change-summary');
  if (summaryEl) {
    summaryEl.textContent = 'Changed files: ' + total + ' | staged ' + staged + ', unstaged ' + unstaged + ', untracked ' + untracked;
  }
  if (payload.sync) {
    gitSyncState = payload.sync;
    _renderGitSyncState(payload.sync);
  }
  if (opts.statusText) {
    _setGitCommitStatus(opts.statusText, opts.statusTone || 'muted');
  }
  _syncGitCommitControls();
}

function _clearGitCommitWorkflowView(message = 'No repository selected.') {
  gitCommitWorkflowState = null;
  _setGitCommitRepoPathLabel('');
  const summaryEl = document.getElementById('git-commit-change-summary');
  if (summaryEl) summaryEl.textContent = 'No changes loaded.';
  _renderGitCommitFileRows([]);
  _renderGitCommitLastSummary(null);
  _setGitCommitStatus(message, 'muted');
  _syncGitCommitControls();
}

async function showGitCommitModal() {
  _openOverlay('git-commit-overlay', '#git-commit-message');
  const repoPath = _activeRepoPathForGitSync();
  _setGitCommitRepoPathLabel(repoPath);
  if (!repoPath) {
    _clearGitCommitWorkflowView('Set a repository path first.');
    return;
  }
  await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
}

function hideGitCommitModal() {
  _closeOverlay('git-commit-overlay');
}

async function refreshGitCommitWorkflow(opts = {}) {
  const repoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (!repoPath) {
    _clearGitCommitWorkflowView('Set a repository path first.');
    return;
  }
  _setGitCommitRepoPathLabel(repoPath);
  if (gitSyncBusyAction && !opts.force) {
    _syncGitCommitControls();
    return;
  }

  if (!opts.silent) {
    _setGitCommitStatus('Loading commit workflow...', 'muted');
  }
  const response = await api('/api/git/sync/commit/workflow?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(opts.repoPath || _activeRepoPathForGitSync()).trim();
  if (repoPath !== currentRepoPath) {
    return;
  }
  if (response.error) {
    gitCommitWorkflowState = null;
    const message = String(response.error || 'Unknown error');
    _setGitCommitStatus(message, 'error');
    if (!opts.silent) toast('Could not load commit workflow: ' + message, 'error');
    _syncGitCommitControls();
    return;
  }

  _applyGitCommitWorkflowResponse(
    response,
    opts.silent
      ? {}
      : {
          statusText: String(response.message || 'Commit workflow updated.'),
          statusTone: 'ok',
        }
  );
}

async function refreshGitCommitWorkflowNow() {
  await refreshGitCommitWorkflow({ silent: false, force: true });
}

async function _runGitCommitWorkflowAction(actionKey, endpoint, payload, opts = {}) {
  if (gitSyncBusyAction) return null;
  const repoPath = _activeRepoPathForGitSync();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    _clearGitCommitWorkflowView('Set a repository path first.');
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return null;
  }

  const runningText = String(opts.running || 'Applying commit workflow action...');
  gitSyncBusyAction = actionKey;
  _syncGitSyncButtonState();
  _setGitCommitStatus(runningText, 'muted');

  const requestPayload = Object.assign({ repo_path: repoPath }, payload || {});
  const response = await postJson(endpoint, requestPayload);
  gitSyncBusyAction = '';
  _syncGitSyncButtonState();

  if (response.error) {
    const message = String(response.error || 'Unknown error');
    _setGitCommitStatus(message, 'error');
    toast(String(opts.failurePrefix || 'Commit workflow action failed: ') + message, 'error');
    const recoverySteps = Array.isArray(response.recovery_steps) ? response.recovery_steps : [];
    if (recoverySteps.length) {
      toast('Recovery: ' + recoverySteps.join(' | '), 'info');
    }
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
    if (_isGitCommitModalOpen()) {
      await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
    }
    return null;
  }

  if (response.workflow) {
    _applyGitCommitWorkflowResponse(response.workflow, {
      statusText: String(response.message || opts.successFallback || 'Commit workflow updated.'),
      statusTone: 'ok',
    });
  } else if (_isGitCommitModalOpen()) {
    await refreshGitCommitWorkflow({ repoPath, silent: true, force: true });
  }
  if (response.sync) {
    gitSyncState = response.sync;
    _renderGitSyncState(response.sync);
  } else {
    await refreshGitSyncStatus({ repoPath, silent: true, force: true });
  }

  toast(String(response.message || opts.successFallback || 'Commit workflow action completed.'), 'success');
  return response;
}

async function gitCommitStagePath(path) {
  const filePath = String(path || '').trim();
  if (!filePath) return;
  await _runGitCommitWorkflowAction(
    'git_commit_stage_path',
    '/api/git/sync/commit/stage',
    { paths: [filePath] },
    {
      running: 'Staging ' + filePath + '...',
      successFallback: 'File staged.',
      failurePrefix: 'Stage failed: ',
    }
  );
}

async function gitCommitUnstagePath(path) {
  const filePath = String(path || '').trim();
  if (!filePath) return;
  await _runGitCommitWorkflowAction(
    'git_commit_unstage_path',
    '/api/git/sync/commit/unstage',
    { paths: [filePath] },
    {
      running: 'Unstaging ' + filePath + '...',
      successFallback: 'File unstaged.',
      failurePrefix: 'Unstage failed: ',
    }
  );
}

async function gitCommitStageAll() {
  await _runGitCommitWorkflowAction(
    'git_commit_stage_all',
    '/api/git/sync/commit/stage',
    { all: true },
    {
      running: 'Staging all pending changes...',
      successFallback: 'All pending changes staged.',
      failurePrefix: 'Stage all failed: ',
    }
  );
}

async function gitCommitUnstageAll() {
  await _runGitCommitWorkflowAction(
    'git_commit_unstage_all',
    '/api/git/sync/commit/unstage',
    { all: true },
    {
      running: 'Unstaging all staged changes...',
      successFallback: 'All staged changes unstaged.',
      failurePrefix: 'Unstage all failed: ',
    }
  );
}

async function gitCommitCreate() {
  const messageEl = document.getElementById('git-commit-message');
  const message = String(messageEl ? messageEl.value : '').trim();
  if (!message) {
    toast('Enter a commit message first.', 'warn');
    _syncGitCommitControls();
    return;
  }
  const response = await _runGitCommitWorkflowAction(
    'git_commit_create',
    '/api/git/sync/commit/create',
    { message },
    {
      running: 'Creating commit...',
      successFallback: 'Commit created.',
      failurePrefix: 'Commit failed: ',
    }
  );
  if (!response) return;

  if (messageEl) messageEl.value = '';
  const commit = response.commit && typeof response.commit === 'object' ? response.commit : null;
  const hashLabel = String((commit && (commit.short_hash || commit.hash)) || '').trim();
  if (hashLabel) {
    _setGitCommitStatus('Commit created: ' + hashLabel, 'ok');
  } else {
    _setGitCommitStatus('Commit created.', 'ok');
  }
  _syncGitCommitControls();
}

function syncTodoWishlistRepoFromMain() {
  const repo = _activeRepoPath();
  const input = document.getElementById('todo-wishlist-repo');
  if (input) input.value = repo;
  return repo;
}

function _renderTodoWishlistContextFilesList() {
  const el = document.getElementById('todo-wishlist-context-files-list');
  if (!el) return;
  if (!todoWishlistContextFiles.length) {
    el.textContent = 'No context files selected.';
    return;
  }
  const labels = todoWishlistContextFiles.map(row => {
    const name = String(row && row.name || '').trim() || 'context.txt';
    const content = String(row && row.content || '');
    return name + ' (' + content.length + ' chars)';
  });
  el.textContent = labels.join(' | ');
}

async function onTodoWishlistContextFilesChanged(inputEl) {
  const files = Array.from((inputEl && inputEl.files) ? inputEl.files : []);
  todoWishlistContextFiles = [];
  if (!files.length) {
    _renderTodoWishlistContextFilesList();
    _setTodoWishlistStatus('Cleared context files.', 'muted');
    return;
  }

  const maxFiles = 6;
  const maxCharsPerFile = 6000;
  const maxTotalChars = 24000;
  const accepted = [];
  const warnings = [];
  let totalChars = 0;

  for (const file of files) {
    if (accepted.length >= maxFiles) {
      warnings.push('Only the first ' + maxFiles + ' files are used.');
      break;
    }
    let text = '';
    try {
      text = String(await file.text());
    } catch (_err) {
      warnings.push('Could not read file: ' + file.name);
      continue;
    }
    text = text.replace(/\r\n/g, '\n').trim();
    if (!text) {
      warnings.push('Skipped empty file: ' + file.name);
      continue;
    }
    if (text.length > maxCharsPerFile) {
      text = text.slice(0, maxCharsPerFile);
      warnings.push('Trimmed large file: ' + file.name);
    }
    const remaining = maxTotalChars - totalChars;
    if (remaining <= 0) {
      warnings.push('Reached total context size limit.');
      break;
    }
    if (text.length > remaining) {
      text = text.slice(0, remaining);
      warnings.push('Trimmed context to fit total size limit.');
    }
    totalChars += text.length;
    accepted.push({
      name: String(file.name || 'context.txt').trim() || 'context.txt',
      content: text,
    });
  }

  todoWishlistContextFiles = accepted;
  _renderTodoWishlistContextFilesList();
  if (warnings.length) {
    _setTodoWishlistStatus(warnings.join(' '), 'warn');
  } else {
    _setTodoWishlistStatus('Loaded ' + accepted.length + ' context file(s).', 'ok');
  }
}

function _setTodoWishlistStatus(text, tone = 'muted') {
  const el = document.getElementById('todo-wishlist-suggest-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

async function showTodoWishlistModal() {
  syncTodoWishlistRepoFromMain();
  const area = document.getElementById('todo-wishlist-content');
  if (area) area.value = '';
  const filesEl = document.getElementById('todo-wishlist-context-files');
  if (filesEl) filesEl.value = '';
  todoWishlistContextFiles = [];
  _renderTodoWishlistContextFilesList();
  lastTodoWishlistSuggestion = '';
  _setTodoWishlistStatus('');
  _openOverlay('todo-wishlist-overlay', '#todo-wishlist-repo');
  await loadTodoWishlist();
}

function hideTodoWishlistModal() {
  _closeOverlay('todo-wishlist-overlay');
}

async function loadTodoWishlist() {
  const repo = String(document.getElementById('todo-wishlist-repo').value || '').trim();
  if (!repo) {
    _setTodoWishlistStatus('Set a repository path first.', 'warn');
    return;
  }
  _setTodoWishlistStatus('Loading to-do/wishlist...', 'muted');
  try {
    const resp = await api('/api/owner/todo-wishlist?repo_path=' + encodeURIComponent(repo));
    if (resp.error) {
      _setTodoWishlistStatus(resp.error, 'error');
      return;
    }
    const area = document.getElementById('todo-wishlist-content');
    if (area) area.value = String(resp.content || '').trim();
    _setTodoWishlistStatus(resp.exists ? 'Loaded existing to-do/wishlist file.' : 'Loaded starter template.', 'ok');
  } catch (e) {
    _setTodoWishlistStatus('Could not load to-do/wishlist.', 'error');
  }
}

async function saveTodoWishlist() {
  const repo = String(document.getElementById('todo-wishlist-repo').value || '').trim();
  const content = String(document.getElementById('todo-wishlist-content').value || '').trim();
  if (!repo) {
    _setTodoWishlistStatus('Set a repository path first.', 'warn');
    return false;
  }
  try {
    const resp = await postJson('/api/owner/todo-wishlist/save', {
      repo_path: repo,
      content: content,
    });
    if (resp.error) {
      _setTodoWishlistStatus(resp.error, 'error');
      return false;
    }
    _setTodoWishlistStatus('Saved to-do/wishlist.', 'ok');
    toast('To-do/wishlist saved.', 'success');
    return true;
  } catch (e) {
    _setTodoWishlistStatus('Could not save to-do/wishlist.', 'error');
    return false;
  }
}

async function suggestTodoWishlist() {
  const repo = String(document.getElementById('todo-wishlist-repo').value || '').trim();
  if (!repo) {
    _setTodoWishlistStatus('Set a repository path first.', 'warn');
    return;
  }
  const existing = String(document.getElementById('todo-wishlist-content').value || '').trim();
  const ownerContext = String(document.getElementById('todo-wishlist-context').value || '').trim();
  const model = String(document.getElementById('todo-wishlist-model').value || 'gpt-5.2').trim() || 'gpt-5.2';
  _setTodoWishlistStatus('Generating suggestions...', 'muted');
  try {
    const resp = await postJson('/api/owner/todo-wishlist/suggest', {
      repo_path: repo,
      existing_markdown: existing,
      owner_context: ownerContext,
      context_files: todoWishlistContextFiles,
      model: model,
    });
    if (resp.error) {
      _setTodoWishlistStatus(resp.error, 'error');
      return;
    }
    lastTodoWishlistSuggestion = String(resp.content || '').trim();
    if (!lastTodoWishlistSuggestion) {
      _setTodoWishlistStatus('AI returned an empty suggestion.', 'warn');
      return;
    }
    document.getElementById('todo-wishlist-content').value = lastTodoWishlistSuggestion;
    const warning = String(resp.warning || '').trim();
    if (warning) {
      _setTodoWishlistStatus(warning, 'warn');
      toast(warning, 'info');
    } else {
      _setTodoWishlistStatus('AI suggestion applied to the editor.', 'ok');
    }
  } catch (e) {
    _setTodoWishlistStatus('AI suggestion failed.', 'error');
  }
}

function appendTodoWishlistSuggestion() {
  const area = document.getElementById('todo-wishlist-content');
  const suggestion = String(lastTodoWishlistSuggestion || '').trim();
  if (!area || !suggestion) {
    _setTodoWishlistStatus('No suggestion to append yet. Click "Suggest with AI" first.', 'warn');
    return;
  }
  const existing = String(area.value || '').trim();
  area.value = existing ? (existing + '\n\n' + suggestion) : suggestion;
  _setTodoWishlistStatus('Appended latest suggestion to the editor.', 'ok');
}

async function saveAndStartTodoWishlistAutopilot() {
  const ok = await saveTodoWishlist();
  if (!ok) return;
  hideTodoWishlistModal();
  await startTodoWishlistAutopilot();
}

async function startTodoWishlistAutopilot() {
  const repoFromModal = String(document.getElementById('todo-wishlist-repo') ? document.getElementById('todo-wishlist-repo').value : '').trim();
  const repo = repoFromModal || _activeRepoPath();
  if (!repo) {
    toast('Set a repository path first.', 'error');
    return;
  }
  document.getElementById('repo-path').value = repo;
  config.repo_path = repo;
  validateRepo();
  applyMode('easy');
  selectRecipe('todo_wishlist_autopilot');
  switchTab('chain');
  await startChain();
}

/* -- New Project ------------------------------------------------ */
/* -- Feature Dreams workspace -- */
let lastFeatureDreamsSuggestion = '';

function syncFeatureDreamsRepoFromMain() {
  const repo = _activeRepoPath();
  const input = document.getElementById('feature-dreams-repo');
  if (input) input.value = repo;
  return repo;
}

function _setFeatureDreamsStatus(text, tone = 'muted') {
  const el = document.getElementById('feature-dreams-suggest-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

async function showFeatureDreamsModal() {
  syncFeatureDreamsRepoFromMain();
  const area = document.getElementById('feature-dreams-content');
  if (area) area.value = '';
  lastFeatureDreamsSuggestion = '';
  _setFeatureDreamsStatus('');
  _openOverlay('feature-dreams-overlay', '#feature-dreams-repo');
  await loadFeatureDreams();
}

function hideFeatureDreamsModal() {
  _closeOverlay('feature-dreams-overlay');
}

async function loadFeatureDreams() {
  const repo = String(document.getElementById('feature-dreams-repo').value || '').trim();
  if (!repo) {
    _setFeatureDreamsStatus('Set a repository path first.', 'warn');
    return;
  }
  _setFeatureDreamsStatus('Loading feature dreams...', 'muted');
  try {
    const resp = await api('/api/owner/feature-dreams?repo_path=' + encodeURIComponent(repo));
    if (resp.error) {
      _setFeatureDreamsStatus(resp.error, 'error');
      return;
    }
    const area = document.getElementById('feature-dreams-content');
    if (area) area.value = String(resp.content || '').trim();
    _setFeatureDreamsStatus(resp.exists ? 'Loaded existing feature dreams file.' : 'Loaded starter template.', 'ok');
  } catch (e) {
    _setFeatureDreamsStatus('Could not load feature dreams.', 'error');
  }
}

async function saveFeatureDreams() {
  const repo = String(document.getElementById('feature-dreams-repo').value || '').trim();
  const content = String(document.getElementById('feature-dreams-content').value || '').trim();
  if (!repo) {
    _setFeatureDreamsStatus('Set a repository path first.', 'warn');
    return false;
  }
  try {
    const resp = await postJson('/api/owner/feature-dreams/save', {
      repo_path: repo,
      content: content,
    });
    if (resp.error) {
      _setFeatureDreamsStatus(resp.error, 'error');
      return false;
    }
    _setFeatureDreamsStatus('Saved feature dreams.', 'ok');
    toast('Feature dreams saved.', 'success');
    return true;
  } catch (e) {
    _setFeatureDreamsStatus('Could not save feature dreams.', 'error');
    return false;
  }
}

async function suggestFeatureDreams() {
  const repo = String(document.getElementById('feature-dreams-repo').value || '').trim();
  if (!repo) {
    _setFeatureDreamsStatus('Set a repository path first.', 'warn');
    return;
  }
  const existing = String(document.getElementById('feature-dreams-content').value || '').trim();
  const ownerContext = String(document.getElementById('feature-dreams-context').value || '').trim();
  const model = String(document.getElementById('feature-dreams-model').value || 'gpt-5.2').trim() || 'gpt-5.2';
  _setFeatureDreamsStatus('Generating suggestions...', 'muted');
  try {
    const resp = await postJson('/api/owner/feature-dreams/suggest', {
      repo_path: repo,
      existing_markdown: existing,
      owner_context: ownerContext,
      model: model,
    });
    if (resp.error) {
      _setFeatureDreamsStatus(resp.error, 'error');
      return;
    }
    lastFeatureDreamsSuggestion = String(resp.content || '').trim();
    if (!lastFeatureDreamsSuggestion) {
      _setFeatureDreamsStatus('AI returned an empty suggestion.', 'warn');
      return;
    }
    document.getElementById('feature-dreams-content').value = lastFeatureDreamsSuggestion;
    const warning = String(resp.warning || '').trim();
    if (warning) {
      _setFeatureDreamsStatus(warning, 'warn');
      toast(warning, 'info');
    } else {
      _setFeatureDreamsStatus('AI suggestion applied to the editor.', 'ok');
    }
  } catch (e) {
    _setFeatureDreamsStatus('AI suggestion failed.', 'error');
  }
}

function appendFeatureDreamsSuggestion() {
  const area = document.getElementById('feature-dreams-content');
  const suggestion = String(lastFeatureDreamsSuggestion || '').trim();
  if (!area || !suggestion) {
    _setFeatureDreamsStatus('No suggestion to append yet. Click "Suggest with AI" first.', 'warn');
    return;
  }
  const existing = String(area.value || '').trim();
  area.value = existing ? (existing + '\n\n' + suggestion) : suggestion;
  _setFeatureDreamsStatus('Appended latest suggestion to the editor.', 'ok');
}

async function saveAndStartFeatureDreamAutopilot() {
  const ok = await saveFeatureDreams();
  if (!ok) return;
  hideFeatureDreamsModal();
  await startFeatureDreamAutopilot();
}

async function startFeatureDreamAutopilot() {
  const repoFromModal = String(document.getElementById('feature-dreams-repo') ? document.getElementById('feature-dreams-repo').value : '').trim();
  const repo = repoFromModal || _activeRepoPath();
  if (!repo) {
    toast('Set a repository path first.', 'error');
    return;
  }
  document.getElementById('repo-path').value = repo;
  config.repo_path = repo;
  validateRepo();
  applyMode('easy');
  selectRecipe('feature_dream_autopilot');
  switchTab('chain');
  await startChain();
}

function _firstUncheckedChecklistItem(markdown) {
  const match = String(markdown || '').match(/^\s*[-*]\s+\[\s\]\s+(.+?)\s*$/m);
  return match ? String(match[1] || '').replace(/\s+/g, ' ').trim() : '';
}

function _implementNextDreamPrompt(itemText) {
  const target = String(itemText || '').trim();
  let prompt =
    "Read `.codex_manager/owner/FEATURE_DREAMS.md` and implement the first unchecked feature item (`- [ ] ...`) end-to-end. "
    + "After implementation, mark it done as `- [x] ...` and add a short completion note.\n\n"
    + "If `.codex_manager/owner/FEATURE_DREAMS.md` does not exist, create it first with concrete feature items and then implement the first unchecked item.\n\n"
    + "Run exactly one implementation pass in this step. Do not continue to additional unchecked items.\n\n"
    + "If there are no unchecked feature items remaining, output exactly `[TERMINATE_STEP]` on its own line and do not make code changes.";
  if (target) {
    prompt += "\n\nCurrent first unchecked item to target:\n- [ ] " + target;
  }
  return prompt;
}

async function implementNextDreamedFeature() {
  const repo = _activeRepoPath();
  if (!repo) {
    toast('Set a repository path first.', 'error');
    return;
  }
  if (chainRunning) {
    toast('A chain run is already active.', 'info');
    return;
  }

  let featureDreams;
  try {
    featureDreams = await api('/api/owner/feature-dreams?repo_path=' + encodeURIComponent(repo));
  } catch (e) {
    toast('Could not load feature dreams.', 'error');
    return;
  }

  if (featureDreams && featureDreams.error) {
    toast(String(featureDreams.error), 'error');
    return;
  }
  if (!featureDreams || !featureDreams.has_open_items) {
    toast('No unchecked feature dreams found.', 'info');
    return;
  }

  const firstOpenItem = _firstUncheckedChecklistItem(featureDreams.content || '');
  document.getElementById('repo-path').value = repo;
  config.repo_path = repo;
  validateRepo();

  config.unlimited = false;
  config.max_loops = 1;
  config.stop_on_convergence = false;
  config.parallel_execution = false;
  config.mode = 'apply';
  config.steps = [
    {
      id: Math.random().toString(36).substring(2, 10),
      name: 'Implement Next Dreamed Feature',
      job_type: 'implementation',
      prompt_mode: 'custom',
      custom_prompt: _implementNextDreamPrompt(firstOpenItem),
      on_failure: 'skip',
      max_retries: 1,
      loop_count: 1,
      enabled: true,
      agent: 'codex',
    },
  ];
  selectedStepId = config.steps[0].id;

  document.querySelectorAll('.recipe-card').forEach(c => {
    c.classList.remove('selected');
    c.setAttribute('aria-pressed', 'false');
  });
  document.getElementById('unlimited').checked = false;
  document.getElementById('max-loops').value = '1';
  document.getElementById('stop-convergence').checked = false;
  document.getElementById('parallel-exec').checked = false;
  if (document.getElementById('mode-toggle')) {
    document.querySelectorAll('#mode-toggle button').forEach(b => {
      b.classList.toggle('active', b.dataset.mode === 'apply');
    });
  }
  toggleUnlimited();
  renderSteps();
  renderStepDetails();
  switchTab('chain');
  await startChain();
}

/* -- General Request workspace -- */
function syncGeneralRequestRepoFromMain() {
  const repo = _activeRepoPath();
  const input = document.getElementById('general-request-repo');
  if (input) input.value = repo;
  return repo;
}

function _setGeneralRequestStatus(text, tone = 'muted') {
  const el = document.getElementById('general-request-status');
  if (!el) return;
  el.textContent = String(text || '');
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

function _formatGeneralRequestTimestamp(rawValue) {
  const value = String(rawValue || '').trim();
  if (!value) return 'n/a';
  const ts = Date.parse(value);
  if (!Number.isFinite(ts)) return value;
  return new Date(ts).toLocaleString();
}

function _renderGeneralRequestHistory(entries) {
  const host = document.getElementById('general-request-history');
  if (!host) return;
  const rows = Array.isArray(entries) ? entries : [];
  if (!rows.length) {
    host.innerHTML = '<div class="state-card">No history yet.</div>';
    return;
  }
  host.innerHTML = rows.map((row) => {
    const status = String(row && row.status || 'considered').trim().toLowerCase();
    const requestText = String(row && row.request || '').trim();
    const notes = String(row && row.notes || '').trim();
    const output = String(row && row.output || '');
    const timestamp = _formatGeneralRequestTimestamp(row && row.timestamp);
    const source = String(row && row.source || '').trim();
    const model = String(row && row.model || '').trim();
    const statusTone = status === 'implemented' ? 'var(--success)' : (status === 'refused' ? 'var(--warning)' : 'var(--text2)');
    return '<div class="general-request-history-item">'
      + '<h4 style="color:' + statusTone + '">' + esc(status.toUpperCase()) + '</h4>'
      + '<div class="meta">' + esc(timestamp)
      + (source ? ('  source: ' + esc(source)) : '')
      + (model ? ('  model: ' + esc(model)) : '')
      + '</div>'
      + '<div><strong>Request</strong></div>'
      + '<pre>' + esc(requestText) + '</pre>'
      + '<div><strong>Notes</strong></div>'
      + '<pre>' + esc(notes || '(none)') + '</pre>'
      + '<div><strong>Exact AI Output</strong></div>'
      + '<pre>' + esc(output) + '</pre>'
      + '</div>';
  }).join('');
}

async function loadGeneralRequestHistory() {
  const repo = String(document.getElementById('general-request-repo').value || '').trim();
  if (!repo) {
    _renderGeneralRequestHistory([]);
    _setGeneralRequestStatus('Set a repository path first.', 'warn');
    return;
  }
  _setGeneralRequestStatus('Loading history...', 'muted');
  try {
    const resp = await api('/api/owner/general-request/history?repo_path=' + encodeURIComponent(repo) + '&limit=50');
    if (resp.error) {
      _setGeneralRequestStatus(resp.error, 'error');
      return;
    }
    _renderGeneralRequestHistory(resp.entries || []);
    _setGeneralRequestStatus('History loaded.', 'ok');
  } catch (_err) {
    _setGeneralRequestStatus('Could not load history.', 'error');
  }
}

async function showGeneralRequestModal() {
  syncGeneralRequestRepoFromMain();
  _setGeneralRequestStatus('', 'muted');
  const outEl = document.getElementById('general-request-output');
  if (outEl) outEl.value = '';
  _openOverlay('general-request-overlay', '#general-request-repo');
  await loadGeneralRequestHistory();
}

function hideGeneralRequestModal() {
  _closeOverlay('general-request-overlay');
}

async function considerGeneralRequest() {
  const repo = String(document.getElementById('general-request-repo').value || '').trim();
  const requestText = String(document.getElementById('general-request-content').value || '').trim();
  const ownerContext = String(document.getElementById('general-request-context').value || '').trim();
  const model = String(document.getElementById('general-request-model').value || 'gpt-5.2').trim() || 'gpt-5.2';
  if (!repo) {
    _setGeneralRequestStatus('Set a repository path first.', 'warn');
    return;
  }
  if (!requestText) {
    _setGeneralRequestStatus('Write a general request first.', 'warn');
    return;
  }
  _setGeneralRequestStatus('Considering request...', 'muted');
  const outputEl = document.getElementById('general-request-output');
  try {
    const resp = await postJson('/api/owner/general-request/process', {
      repo_path: repo,
      request_text: requestText,
      owner_context: ownerContext,
      model: model,
    });
    if (resp.error) {
      _setGeneralRequestStatus(resp.error, 'error');
      return;
    }
    if (outputEl) outputEl.value = String(resp.output || resp.response || '').trim();
    document.getElementById('general-request-content').value = '';
    const status = String(resp.status || 'considered').toLowerCase();
    const notes = String(resp.notes || '').trim();
    const tone = status === 'refused' ? 'warn' : 'ok';
    _setGeneralRequestStatus(status.toUpperCase() + ': ' + notes, tone);
    await loadGeneralRequestHistory();
  } catch (_err) {
    _setGeneralRequestStatus('Could not process request.', 'error');
  }
}

function _buildGeneralRequestImplementationPrompt(requestText) {
  const ownerRequest = String(requestText || '').trim();
  return (
    "Owner request:\n"
    + ownerRequest
    + "\n\nExecute one focused implementation pass for this request.\n"
    + "- If the request is valid and feasible, implement it directly in this repository with high-signal edits.\n"
    + "- If the request is unsafe, unclear, or not feasible in this run, do not make code changes and explain why.\n"
    + "- Keep scope tight and finish in one pass.\n\n"
    + "At the end of your response, include exactly these lines:\n"
    + "GENERAL_REQUEST_STATUS: implemented|considered|refused\n"
    + "GENERAL_REQUEST_NOTES: <one short line>\n"
  );
}

function _extractGeneralRequestMarker(outputText, key) {
  const re = new RegExp('^\\s*' + key + '\\s*:\\s*(.+?)\\s*$', 'im');
  const match = String(outputText || '').match(re);
  return match ? String(match[1] || '').trim() : '';
}

async function _latestChainOutputForRepo(repoPath, sinceEpochMs = 0) {
  const outputs = await api('/api/chain/outputs?repo_path=' + encodeURIComponent(repoPath));
  if (outputs.error || !Array.isArray(outputs.files) || !outputs.files.length) {
    return { name: '', content: '' };
  }
  const sorted = outputs.files.slice().sort((a, b) => Number(b.modified_epoch || 0) - Number(a.modified_epoch || 0));
  let selected = null;
  if (sinceEpochMs > 0) {
    selected = sorted.find(file => (Number(file && file.modified_epoch || 0) * 1000) >= (sinceEpochMs - 5000)) || null;
  }
  if (!selected) selected = sorted[0];
  if (!selected || !selected.name) return { name: '', content: '' };
  const detail = await api('/api/chain/outputs/' + encodeURIComponent(selected.name) + '?repo_path=' + encodeURIComponent(repoPath));
  if (detail.error) return { name: String(selected.name || ''), content: '' };
  return {
    name: String(selected.name || ''),
    content: String(detail.content || ''),
  };
}

async function implementGeneralRequestViaChain() {
  const repo = String(document.getElementById('general-request-repo').value || '').trim() || _activeRepoPath();
  const requestText = String(document.getElementById('general-request-content').value || '').trim();
  if (!repo) {
    _setGeneralRequestStatus('Set a repository path first.', 'warn');
    return;
  }
  if (!requestText) {
    _setGeneralRequestStatus('Write a general request first.', 'warn');
    return;
  }
  if (chainRunning) {
    _setGeneralRequestStatus('A chain run is already active.', 'warn');
    return;
  }

  document.getElementById('repo-path').value = repo;
  config.repo_path = repo;
  validateRepo();
  config.unlimited = false;
  config.max_loops = 1;
  config.stop_on_convergence = false;
  config.parallel_execution = false;
  config.steps = [
    {
      id: Math.random().toString(36).substring(2, 10),
      name: 'General Request',
      job_type: 'implementation',
      prompt_mode: 'custom',
      custom_prompt: _buildGeneralRequestImplementationPrompt(requestText),
      on_failure: 'skip',
      max_retries: 1,
      loop_count: 1,
      enabled: true,
      agent: 'codex',
    },
  ];
  selectedStepId = config.steps[0].id;
  document.querySelectorAll('.recipe-card').forEach(c => {
    c.classList.remove('selected');
    c.setAttribute('aria-pressed', 'false');
  });
  document.getElementById('unlimited').checked = false;
  document.getElementById('max-loops').value = '1';
  document.getElementById('stop-convergence').checked = false;
  document.getElementById('parallel-exec').checked = false;
  toggleUnlimited();
  renderSteps();
  renderStepDetails();

  pendingGeneralRequestRun = {
    repo_path: repo,
    request_text: requestText,
    started_epoch_ms: Date.now(),
    model: 'gpt-5.3-codex',
  };
  _setGeneralRequestStatus('Implementation run started. Waiting for completion...', 'muted');
  switchTab('chain');
  await startChain();
  if (!chainRunning) {
    pendingGeneralRequestRun = null;
    _setGeneralRequestStatus('Could not start implementation run.', 'error');
  }
}

async function _finalizePendingGeneralRequestRun(state) {
  if (_generalRequestFinalizeInFlight || !pendingGeneralRequestRun) return;
  const pending = pendingGeneralRequestRun;
  pendingGeneralRequestRun = null;
  _generalRequestFinalizeInFlight = true;
  try {
    const output = await _latestChainOutputForRepo(pending.repo_path, pending.started_epoch_ms || 0);
    const outputText = String(output && output.content || '');
    const lastResult = Array.isArray(chainResultsCache) && chainResultsCache.length
      ? chainResultsCache[chainResultsCache.length - 1]
      : null;
    let status = _extractGeneralRequestMarker(outputText, 'GENERAL_REQUEST_STATUS').toLowerCase();
    if (!['implemented', 'considered', 'refused'].includes(status)) {
      if (lastResult && lastResult.success && Number(lastResult.files_changed || 0) > 0) {
        status = 'implemented';
      } else if (lastResult && lastResult.success) {
        status = 'considered';
      } else {
        status = 'refused';
      }
    }
    let notes = _extractGeneralRequestMarker(outputText, 'GENERAL_REQUEST_NOTES');
    if (!notes) {
      const stopReason = String(state && state.stop_reason || '').trim();
      if (status === 'implemented') {
        notes = 'Implementation run completed successfully.';
      } else if (status === 'refused') {
        notes = stopReason ? ('Run ended with stop reason: ' + stopReason) : 'Request was not implemented in this run.';
      } else {
        notes = 'Request was considered, but no concrete implementation was applied.';
      }
    }

    const saveResp = await postJson('/api/owner/general-request/history/add', {
      repo_path: pending.repo_path,
      request_text: pending.request_text,
      status: status,
      notes: notes,
      output: outputText,
      source: 'chain',
      model: pending.model || '',
    });
    if (saveResp.error) {
      toast('Could not save general-request history: ' + saveResp.error, 'error');
    }

    const requestEl = document.getElementById('general-request-content');
    if (requestEl) requestEl.value = '';
    const outputEl = document.getElementById('general-request-output');
    if (outputEl) outputEl.value = outputText;
    const tone = status === 'implemented' ? 'ok' : (status === 'refused' ? 'warn' : 'muted');
    _setGeneralRequestStatus(status.toUpperCase() + ': ' + notes, tone);
    await loadGeneralRequestHistory();
  } finally {
    _generalRequestFinalizeInFlight = false;
  }
}

function showNewProjectModal() {
  document.getElementById('np-result').style.display = 'none';
  document.getElementById('np-create-btn').disabled = false;
  toggleFoundationOptions();
  toggleLicensingOptions();
  _openOverlay('new-project-overlay', '#np-parent');
}

function hideNewProjectModal() {
  _closeOverlay('new-project-overlay');
}

function _setCloneRepoStatus(text, tone = 'muted') {
  const el = document.getElementById('clone-repo-status');
  if (!el) return;
  el.textContent = text;
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

function _setCloneBranchHelp(text, tone = 'muted') {
  const el = document.getElementById('clone-branch-help');
  if (!el) return;
  el.textContent = text;
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

function _populateCloneBranchOptions(branches, defaultBranch = '') {
  const selectEl = document.getElementById('clone-default-branch');
  if (!selectEl) return;

  const safeBranches = Array.isArray(branches)
    ? branches
      .map(item => String(item || '').trim())
      .filter(Boolean)
    : [];

  const selectedDefault = String(defaultBranch || '').trim();
  const options = [
    {
      value: CLONE_DEFAULT_BRANCH_SENTINEL,
      label: selectedDefault
        ? 'Use remote default branch (' + selectedDefault + ')'
        : 'Use remote default branch',
    },
  ];

  safeBranches.forEach(branch => {
    options.push({ value: branch, label: branch });
  });

  selectEl.innerHTML = options
    .map(option => '<option value="' + esc(option.value) + '">' + esc(option.label) + '</option>')
    .join('');

  if (selectedDefault && safeBranches.includes(selectedDefault)) {
    selectEl.value = selectedDefault;
  } else {
    selectEl.value = CLONE_DEFAULT_BRANCH_SENTINEL;
  }
}

function showCloneRepoModal() {
  const statusEl = document.getElementById('clone-repo-status');
  if (statusEl) statusEl.textContent = '';
  const cloneBtn = document.getElementById('clone-repo-btn');
  if (cloneBtn) cloneBtn.disabled = false;
  _setCloneBranchHelp('Load branch names from the remote (optional).', 'muted');
  _openOverlay('clone-repo-overlay', '#clone-remote-url');
}

function hideCloneRepoModal() {
  _closeOverlay('clone-repo-overlay');
}

async function loadCloneRemoteBranches() {
  const remoteUrl = document.getElementById('clone-remote-url').value.trim();
  if (!remoteUrl) {
    toast('Enter a remote URL first', 'error');
    return;
  }

  _setCloneBranchHelp('Loading remote branches...', 'muted');
  try {
    const resp = await postJson('/api/project/clone/branches', {
      remote_url: remoteUrl,
    });
    if (resp.error) {
      _setCloneBranchHelp(resp.error, 'error');
      toast('Could not load remote branches: ' + resp.error, 'error');
      return;
    }
    const branches = Array.isArray(resp.branches) ? resp.branches : [];
    const defaultBranch = String(resp.default_branch || '').trim();
    _populateCloneBranchOptions(branches, defaultBranch);

    if (defaultBranch) {
      _setCloneBranchHelp(
        'Loaded ' + branches.length + ' branches. Remote default: ' + defaultBranch + '.',
        'ok',
      );
    } else if (branches.length) {
      _setCloneBranchHelp('Loaded ' + branches.length + ' branches.', 'ok');
    } else {
      _setCloneBranchHelp('No remote branches were returned.', 'warn');
    }
  } catch (e) {
    const message = e && e.message ? e.message : String(e);
    _setCloneBranchHelp(message, 'error');
    toast('Could not load remote branches: ' + message, 'error');
  }
}

async function cloneRemoteRepo() {
  const remoteUrl = document.getElementById('clone-remote-url').value.trim();
  const destinationDir = document.getElementById('clone-destination-dir').value.trim();
  const projectName = document.getElementById('clone-project-name').value.trim();
  const branchSelect = document.getElementById('clone-default-branch');
  const selectedBranch = String(branchSelect ? branchSelect.value : '').trim() || CLONE_DEFAULT_BRANCH_SENTINEL;

  if (!remoteUrl) {
    toast('Enter a remote URL', 'error');
    return;
  }
  if (!destinationDir) {
    toast('Enter a destination directory', 'error');
    return;
  }

  const cloneBtn = document.getElementById('clone-repo-btn');
  if (cloneBtn) cloneBtn.disabled = true;
  _setCloneRepoStatus('Cloning repository...', 'muted');

  try {
    const resp = await postJson('/api/project/clone', {
      remote_url: remoteUrl,
      destination_dir: destinationDir,
      project_name: projectName,
      default_branch: selectedBranch,
    });

    if (resp.error) {
      _setCloneRepoStatus(resp.error, 'error');
      toast('Clone failed: ' + resp.error, 'error');
      if (cloneBtn) cloneBtn.disabled = false;
      return;
    }

    document.getElementById('repo-path').value = resp.path;
    config.repo_path = resp.path;
    validateRepo();

    hideCloneRepoModal();
    toast('Repository cloned at: ' + resp.path, 'success');
    if (resp.checked_out_branch) {
      toast('Checked out branch: ' + String(resp.checked_out_branch), 'info');
    }
    loadOwnerIdeas();
  } catch (e) {
    const message = e && e.message ? e.message : String(e);
    _setCloneRepoStatus(message, 'error');
    toast('Clone failed: ' + message, 'error');
    if (cloneBtn) cloneBtn.disabled = false;
  }
}

function toggleFoundationOptions() {
  const enabled = document.getElementById('np-foundation-enabled').checked;
  const panel = document.getElementById('np-foundation-options');
  panel.classList.toggle('hidden', !enabled);
}

function toggleLicensingOptions() {
  const enabled = document.getElementById('np-licensing-enabled').checked;
  const panel = document.getElementById('np-licensing-options');
  panel.classList.toggle('hidden', !enabled);
  toggleLicensingLegalSignoff();
}

function toggleLicensingLegalSignoff() {
  const requiredEl = document.getElementById('np-licensing-legal-review-required');
  const signoffEl = document.getElementById('np-licensing-legal-signoff');
  const reviewerEl = document.getElementById('np-licensing-legal-reviewer');
  const notesEl = document.getElementById('np-licensing-legal-notes');
  if (!requiredEl || !signoffEl || !reviewerEl || !notesEl) return;
  const required = !!requiredEl.checked;
  signoffEl.disabled = !required;
  reviewerEl.disabled = !required;
  notesEl.disabled = !required;
  if (!required) signoffEl.checked = false;
}

function _selectedFoundationAssistants() {
  return Array.from(document.querySelectorAll('.np-foundation-assistant:checked'))
    .map(el => String(el.value || '').trim().toLowerCase())
    .filter(Boolean);
}

function _setFoundationStatus(text, tone = 'muted') {
  const el = document.getElementById('np-foundation-status');
  if (!el) return;
  el.textContent = text;
  if (tone === 'ok') {
    el.style.color = 'var(--success)';
  } else if (tone === 'warn') {
    el.style.color = 'var(--warning)';
  } else if (tone === 'error') {
    el.style.color = 'var(--danger)';
  } else {
    el.style.color = 'var(--text2)';
  }
}

async function improveFoundationalPrompt() {
  const projectName = document.getElementById('np-name').value.trim() || 'Project';
  const promptEl = document.getElementById('np-foundation-prompt');
  const prompt = promptEl.value.trim();
  const assistants = _selectedFoundationAssistants();
  if (!prompt) {
    toast('Enter a foundational prompt first', 'error');
    return;
  }

  _setFoundationStatus('Improving prompt...', 'muted');
  try {
    const resp = await postJson('/api/project/foundation/improve', {
      prompt,
      project_name: projectName,
      assistants,
    });
    if (resp.error) {
      _setFoundationStatus(resp.error, 'error');
      toast(resp.error, 'error');
      return;
    }
    const improved = String(resp.recommended_prompt || '').trim();
    if (!improved) {
      _setFoundationStatus('No improved prompt returned.', 'warn');
      return;
    }
    promptEl.value = improved;
    if (resp.warning) {
      _setFoundationStatus(String(resp.warning), 'warn');
      toast(String(resp.warning), 'info');
    } else {
      _setFoundationStatus('Prompt improved and applied.', 'ok');
      toast('Foundational prompt improved', 'success');
    }
  } catch (e) {
    const message = 'Prompt improvement failed: ' + (e && e.message ? e.message : String(e));
    _setFoundationStatus(message, 'error');
    toast(message, 'error');
  }
}

async function createProject() {
  const parentDir = document.getElementById('np-parent').value.trim();
  const projectName = document.getElementById('np-name').value.trim();
  const description = document.getElementById('np-desc').value.trim();
  const gitName = document.getElementById('np-git-name').value.trim();
  const gitEmail = document.getElementById('np-git-email').value.trim();
  const addReadme = document.getElementById('np-readme').checked;
  const addGitignore = document.getElementById('np-gitignore').checked;
  const branch = document.getElementById('np-branch').value.trim() || 'main';
  const remoteUrl = document.getElementById('np-remote').value.trim();
  const foundationEnabled = document.getElementById('np-foundation-enabled').checked;
  const foundationalPrompt = document.getElementById('np-foundation-prompt').value.trim();
  const foundationAssistants = _selectedFoundationAssistants();
  const foundationGenerateDocs = document.getElementById('np-foundation-generate-docs').checked;
  const foundationBootstrapOnce = document.getElementById('np-foundation-bootstrap-once').checked;
  const foundationBootstrapAutorun = document.getElementById('np-foundation-bootstrap-autorun').checked;
  const licensingEnabled = document.getElementById('np-licensing-enabled').checked;
  const licensingStrategy = document.getElementById('np-licensing-strategy').value;
  const licensingCommercialTiers = document.getElementById('np-licensing-commercial').checked;
  const licensingOwnerContactEmail = document.getElementById('np-licensing-email').value.trim();
  const licensingLegalReviewRequired = document.getElementById('np-licensing-legal-review-required').checked;
  const licensingLegalSignoffApproved = document.getElementById('np-licensing-legal-signoff').checked;
  const licensingLegalReviewer = document.getElementById('np-licensing-legal-reviewer').value.trim();
  const licensingLegalNotes = document.getElementById('np-licensing-legal-notes').value.trim();

  if (!parentDir) { toast('Enter a parent directory', 'error'); return; }
  if (!projectName) { toast('Enter a project name', 'error'); return; }
  if (!gitName) { toast('Enter a git author name', 'error'); return; }
  if (!gitEmail) { toast('Enter a git author email', 'error'); return; }
  if (foundationEnabled && !foundationalPrompt) {
    toast('Foundational prompt is required when foundational setup is enabled', 'error');
    return;
  }

  document.getElementById('np-create-btn').disabled = true;
  const resultEl = document.getElementById('np-result');
  resultEl.style.display = 'none';

  try {
    const resp = await postJson('/api/project/create', {
      parent_dir: parentDir,
      project_name: projectName,
      description: description,
      git_name: gitName,
      git_email: gitEmail,
      add_readme: addReadme,
      add_gitignore: addGitignore,
      initial_branch: branch,
      remote_url: remoteUrl,
      foundation_enabled: foundationEnabled,
      foundational_prompt: foundationalPrompt,
      foundation_assistants: foundationAssistants,
      foundation_generate_docs: foundationGenerateDocs,
      foundation_bootstrap_once: foundationBootstrapOnce,
      foundation_bootstrap_autorun: foundationBootstrapAutorun,
      licensing_enabled: licensingEnabled,
      licensing_strategy: licensingStrategy,
      licensing_include_commercial_tiers: licensingCommercialTiers,
      licensing_owner_contact_email: licensingOwnerContactEmail,
      licensing_legal_review_required: licensingLegalReviewRequired,
      licensing_legal_signoff_approved: licensingLegalSignoffApproved,
      licensing_legal_reviewer: licensingLegalReviewer,
      licensing_legal_notes: licensingLegalNotes,
    });

    if (resp.error) {
      toast(resp.error, 'error');
      document.getElementById('np-create-btn').disabled = false;
      return;
    }

    // Populate the repo path in the main UI
    document.getElementById('repo-path').value = resp.path;
    config.repo_path = resp.path;
    validateRepo();

    // Close modal immediately and show toast
    hideNewProjectModal();
    if (resp.foundation_enabled && Array.isArray(resp.foundation_files) && resp.foundation_files.length) {
      const bootstrap = resp.foundation_bootstrap_status || {};
      const bootstrapStatus = String(bootstrap.status || '').trim().toLowerCase();
      if (bootstrapStatus === 'running') {
        toast('Project created with foundation artifacts and bootstrap chain started.', 'success');
      } else if (bootstrapStatus === 'queued') {
        toast('Project created. Bootstrap request queued because executor is busy.', 'info');
      } else if (bootstrapStatus === 'pending') {
        toast('Project created with foundation artifacts. Bootstrap request is pending manual run.', 'success');
      } else {
        toast('Project created with foundational artifacts at: ' + resp.path, 'success');
      }
    } else {
      toast('Project created at: ' + resp.path, 'success');
    }
    if (resp.licensing_enabled && Array.isArray(resp.licensing_files) && resp.licensing_files.length) {
      toast('Licensing/commercial docs generated for strategy: ' + String(resp.licensing_strategy || 'oss_only'), 'info');
      const legalStatus = String(resp.licensing_legal_review_status || '').trim().toLowerCase();
      if (legalStatus === 'pending') {
        toast('Legal review checkpoint is pending before publishing licensing/pricing docs.', 'warn');
      } else if (legalStatus === 'approved') {
        toast('Legal review checkpoint recorded as approved.', 'success');
      } else if (legalStatus === 'not_required') {
        toast('Legal review checkpoint was marked optional for this project.', 'info');
      }
    }
    loadOwnerIdeas();

  } catch (e) {
    toast('Failed to create project: ' + e.message, 'error');
    document.getElementById('np-create-btn').disabled = false;
  }
}

/* -- API helper ------------------------------------------------- */
function setBackendOnlineState(isOnline, detail = '') {
  const wasOnline = backendOnline;
  backendOnline = !!isOnline;
  if (backendOnline) {
    backendLastError = '';
  } else if (detail) {
    backendLastError = detail;
  }

  const banner = document.getElementById('backend-status-banner');
  if (banner) {
    if (backendOnline) {
      banner.style.display = 'none';
      banner.textContent = 'Backend connection healthy.';
    } else {
      banner.style.display = '';
      if (pendingServerRestart) {
        banner.textContent = 'Server restarting to apply updates. Waiting to reconnect...';
      } else if (backendLastError) {
        banner.textContent = 'Backend unavailable: ' + backendLastError;
      } else {
        banner.textContent = 'Backend connection lost. Waiting to reconnect.';
      }
    }
  }
  if (!backendOnline) {
    const watchdogBanner = document.getElementById('watchdog-alert-banner');
    if (watchdogBanner) watchdogBanner.style.display = 'none';
  } else if (!wasOnline) {
    pollWatchdogAlerts({ silent: true });
  }

  if (backendOnline && pendingServerRestart) {
    pendingServerRestart = null;
    selfRestartNoticeCheckpoint = '';
    toast('Server restart complete. Reloading UI...', 'info');
    window.location.reload();
  }
}

async function pollBackendHealth() {
  try {
    const resp = await fetch('/api/health', { cache: 'no-store' });
    if (!resp.ok) {
      throw new Error('Health check failed (' + resp.status + ' ' + resp.statusText + ')');
    }
    await resp.json();
    setBackendOnlineState(true);
  } catch (err) {
    const message = (err && err.message) ? err.message : 'network error';
    setBackendOnlineState(false, message);
  }
}

function startBackendHealthPolling() {
  if (backendHealthTimer) clearInterval(backendHealthTimer);
  backendHealthTimer = setInterval(pollBackendHealth, 2500);
  pollBackendHealth();
}

function _watchdogDigest(alerts) {
  if (!Array.isArray(alerts) || !alerts.length) return '';
  return alerts
    .map(a => [a.severity, a.title, a.detail, a.action].map(v => String(v || '')).join('|'))
    .join('||');
}

function _watchdogMigrationsFromAlerts(alerts) {
  const rows = [];
  if (!Array.isArray(alerts)) return rows;
  alerts.forEach(alert => {
    const direct = Array.isArray(alert && alert.migrations) ? alert.migrations : [];
    const nested = (
      alert
      && alert.playbook
      && Array.isArray(alert.playbook.migrations)
    ) ? alert.playbook.migrations : [];
    direct.concat(nested).forEach(row => {
      if (!row || typeof row !== 'object') return;
      const provider = String(row.provider || '').trim().toLowerCase();
      const fromModel = String(row.from_model || row.from || '').trim();
      const toModel = String(row.to_model || row.to || '').trim();
      if (!provider || !fromModel || !toModel || fromModel === toModel) return;
      const key = provider + '|' + fromModel + '|' + toModel;
      if (!rows.some(item => (item.key === key))) {
        rows.push({ key, provider, from_model: fromModel, to_model: toModel });
      }
    });
  });
  return rows;
}

function renderWatchdogAlerts(payload, opts = {}) {
  const banner = document.getElementById('watchdog-alert-banner');
  const content = document.getElementById('watchdog-alert-content');
  const applyBtn = document.getElementById('watchdog-apply-migrations-btn');
  if (!banner || !content) return;

  const hasAlerts = !!(payload && payload.has_alerts);
  const alerts = Array.isArray(payload && payload.alerts) ? payload.alerts : [];
  const muted = Date.now() < watchdogAlertsMutedUntil;
  if (!backendOnline || muted || !hasAlerts || !alerts.length) {
    banner.style.display = 'none';
    content.textContent = '';
    watchdogMigrationSuggestions = [];
    if (applyBtn) applyBtn.style.display = 'none';
    if (!hasAlerts && !muted) {
      watchdogAlertDigest = '';
    }
    return;
  }

  const warnCount = alerts.filter(a => String(a && a.severity || '').toLowerCase() === 'warn').length;
  banner.classList.toggle('error', warnCount > 0);
  banner.classList.toggle('warning', warnCount === 0);

  const lines = alerts.slice(0, 6).map((alert, idx) => {
    const sev = String(alert && alert.severity || 'info').toUpperCase();
    const title = esc(alert && alert.title || ('Alert ' + (idx + 1)));
    const detail = esc(alert && alert.detail || '');
    const action = esc(alert && alert.action || '');
    return '[' + sev + '] ' + title
      + (detail ? ('\n  ' + detail) : '')
      + (action ? ('\n  Action: ' + action) : '');
  });
  if (alerts.length > 6) {
    lines.push('... and ' + (alerts.length - 6) + ' more alert(s).');
  }
  watchdogMigrationSuggestions = _watchdogMigrationsFromAlerts(alerts);
  if (watchdogMigrationSuggestions.length) {
    lines.push(
      'Migration suggestions available: '
      + watchdogMigrationSuggestions.length
      + ' (use "Apply migration suggestions").'
    );
  }
  if (applyBtn) {
    applyBtn.style.display = watchdogMigrationSuggestions.length ? '' : 'none';
  }
  const generatedAt = String(payload && payload.last_generated_at || '').trim();
  if (generatedAt) {
    lines.push('Snapshot: ' + generatedAt);
  }
  content.textContent = lines.join('\n');
  banner.style.display = '';

  const digest = _watchdogDigest(alerts);
  if (opts.announce && digest && digest !== watchdogAlertDigest) {
    const level = warnCount > 0 ? 'error' : 'info';
    toast('Model watchdog reported ' + alerts.length + ' alert(s).', level);
  }
  watchdogAlertDigest = digest;
}

function applyWatchdogMigrationsFromBanner() {
  const suggestions = Array.isArray(watchdogMigrationSuggestions)
    ? watchdogMigrationSuggestions
    : [];
  if (!suggestions.length) {
    toast('No migration suggestions are available right now.', 'info');
    return;
  }

  let applied = 0;
  let skipped = 0;
  suggestions.forEach(row => {
    const provider = String(row.provider || '').trim().toLowerCase();
    const fromModel = String(row.from_model || '').trim();
    const toModel = String(row.to_model || '').trim();
    if (!provider || !fromModel || !toModel || fromModel === toModel) {
      skipped += 1;
      return;
    }
    let changed = false;

    if (provider === 'openai') {
      if (String(pipeConfig.deep_research_openai_model || '').trim() === fromModel) {
        pipeConfig.deep_research_openai_model = toModel;
        changed = true;
      }
    } else if (provider === 'google') {
      if (String(pipeConfig.deep_research_google_model || '').trim() === fromModel) {
        pipeConfig.deep_research_google_model = toModel;
        changed = true;
      }
    }

    if (String(config.brain_model || '').trim() === fromModel) {
      config.brain_model = toModel;
      changed = true;
    }
    if (String(pipeConfig.brain_model || '').trim() === fromModel) {
      pipeConfig.brain_model = toModel;
      changed = true;
    }

    if (changed) applied += 1;
    else skipped += 1;
  });

  normalizeCapabilitySettings(pipeConfig);
  syncPipelineCapabilityControlsFromConfig();
  const chainBrainEl = document.getElementById('brain-model');
  if (chainBrainEl && String(config.brain_model || '').trim()) {
    chainBrainEl.value = config.brain_model;
  }
  const pipeBrainEl = document.getElementById('pipe-brain-model');
  if (pipeBrainEl && String(pipeConfig.brain_model || '').trim()) {
    pipeBrainEl.value = pipeConfig.brain_model;
  }

  if (applied > 0) {
    toast(
      'Applied ' + applied + ' model migration suggestion(s).'
      + (skipped > 0 ? (' Skipped ' + skipped + ' with no matching current model.') : ''),
      'success'
    );
  } else {
    toast('No current settings matched the suggested migrations.', 'info');
  }
}

async function pollWatchdogAlerts(opts = {}) {
  if (!backendOnline) return;
  try {
    const resp = await fetch('/api/system/model-watchdog/alerts', { cache: 'no-store' });
    if (!resp.ok) {
      throw new Error('Watchdog alerts failed (' + resp.status + ' ' + resp.statusText + ')');
    }
    const payload = await resp.json();
    renderWatchdogAlerts(payload, { announce: !!opts.announce });
  } catch (err) {
    if (!opts.silent) {
      console.warn('Could not load watchdog alerts', err);
    }
  }
}

function startWatchdogAlertPolling() {
  if (watchdogAlertsTimer) clearInterval(watchdogAlertsTimer);
  watchdogAlertsTimer = setInterval(() => {
    pollWatchdogAlerts({ silent: true });
  }, 60000);
  pollWatchdogAlerts({ silent: true });
}

function muteWatchdogAlerts(hours) {
  const parsed = Number(hours);
  const durationHours = Number.isFinite(parsed) && parsed > 0 ? parsed : 1;
  watchdogAlertsMutedUntil = Date.now() + durationHours * 60 * 60 * 1000;
  const banner = document.getElementById('watchdog-alert-banner');
  const applyBtn = document.getElementById('watchdog-apply-migrations-btn');
  if (banner) banner.style.display = 'none';
  if (applyBtn) applyBtn.style.display = 'none';
  toast('Watchdog alerts muted for ' + durationHours + ' hour(s).', 'info');
}

async function runWatchdogNowFromBanner() {
  try {
    const resp = await postJson('/api/system/model-watchdog/run', { force: true });
    if (resp.error) {
      toast(resp.error, 'error');
      return;
    }
    toast('Watchdog run complete. Refreshing alerts...', 'info');
    await pollWatchdogAlerts({ announce: true });
  } catch (err) {
    const message = (err && err.message) ? err.message : String(err);
    toast('Could not run watchdog: ' + message, 'error');
  }
}

async function requestServerRestart(checkpointPath, opts = {}) {
  const path = String(checkpointPath || '').trim();
  if (!path) {
    toast('Cannot restart: missing checkpoint path.', 'error');
    return false;
  }
  if (pendingServerRestart && pendingServerRestart.checkpoint_path === path) {
    return true;
  }

  const payload = {
    pipeline_resume_checkpoint: path,
    auto: !!opts.auto,
  };
  const restartReason = String(opts.reason || '').trim();
  const restartSource = String(opts.source || '').trim();
  if (restartReason) payload.restart_reason = restartReason;
  if (restartSource) payload.restart_source = restartSource;

  const resp = await postJson('/api/system/restart', payload);
  if (resp.error) {
    toast('Server restart failed: ' + resp.error, 'error');
    return false;
  }

  pendingServerRestart = {
    checkpoint_path: path,
    requested_at: Date.now(),
    auto: !!opts.auto,
  };
  setBackendOnlineState(false, 'Restart requested');
  if (!opts.auto) {
    toast('Restart requested. Waiting for backend to come back...', 'info');
  }
  return true;
}

async function api(url, opts) {
  try {
    const r = await fetch(url, opts);
    setBackendOnlineState(true);
    const raw = await r.text();
    let data = {};
    if (raw) {
      try {
        data = JSON.parse(raw);
      } catch (_) {
        data = { error: 'Server returned malformed JSON.' };
      }
    }
    if (!r.ok) {
      if (!data || typeof data !== 'object') data = {};
      if (!data.error) data.error = 'Request failed (' + r.status + ' ' + r.statusText + ')';
    }
    return data;
  } catch (e) {
    const message = (e && e.message) ? e.message : String(e);
    setBackendOnlineState(false, message);
    return { error: 'Network error: ' + (e && e.message ? e.message : String(e)) };
  }
}

async function postJson(url, body) {
  return api(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(body),
  });
}

/* -- Mode Toggle ------------------------------------------------ */
function setMode(mode) {
  config.mode = mode;
  document.querySelectorAll('#mode-toggle button').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
}

function syncChainGitPreflightOptions() {
  const enabledEl = document.getElementById('chain-git-preflight-enabled');
  const stashEl = document.getElementById('chain-git-preflight-auto-stash');
  const pullEl = document.getElementById('chain-git-preflight-auto-pull');
  const enabled = !!(enabledEl && enabledEl.checked);
  config.git_preflight_enabled = enabled;
  config.git_preflight_auto_stash = !!(enabled && stashEl && stashEl.checked);
  config.git_preflight_auto_pull = !!(enabled && pullEl && pullEl.checked);
}

function toggleChainGitPreflight() {
  const enabledEl = document.getElementById('chain-git-preflight-enabled');
  const optionsEl = document.getElementById('chain-git-preflight-options');
  const stashEl = document.getElementById('chain-git-preflight-auto-stash');
  const pullEl = document.getElementById('chain-git-preflight-auto-pull');
  const enabled = !!(enabledEl && enabledEl.checked);
  if (optionsEl) optionsEl.classList.toggle('hidden', !enabled);
  if (!enabled) {
    if (stashEl) stashEl.checked = false;
    if (pullEl) pullEl.checked = false;
  }
  syncChainGitPreflightOptions();
}

function _normalizedTimeoutSeconds(rawValue, fallbackSeconds) {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed) || parsed <= 0) return 0;
  const fallback = Number.isFinite(Number(fallbackSeconds)) ? Number(fallbackSeconds) : 600;
  return Math.max(30, Math.round(parsed || fallback));
}

function syncChainTimeoutControlsFromConfig() {
  const enabled = (Number(config.timeout_per_step) || 0) > 0;
  const input = document.getElementById('timeout-step');
  const checkbox = document.getElementById('timeout-step-enabled');
  const note = document.getElementById('timeout-step-note');
  checkbox.checked = enabled;
  if (enabled) {
    input.value = _normalizedTimeoutSeconds(config.timeout_per_step, 600);
  } else if (!_normalizedTimeoutSeconds(input.value, 600)) {
    input.value = 600;
  }
  input.disabled = !enabled;
  input.style.opacity = enabled ? '1' : '0.45';
  note.textContent = enabled
    ? 'Active: run stops only after this many idle seconds.'
    : 'Unlimited (no inactivity timeout).';
  renderActivityHeartbeats();
}

function syncPipeTimeoutControlsFromConfig() {
  const enabled = (Number(pipeConfig.timeout_per_phase) || 0) > 0;
  const input = document.getElementById('pipe-timeout');
  const checkbox = document.getElementById('pipe-timeout-enabled');
  const note = document.getElementById('pipe-timeout-note');
  checkbox.checked = enabled;
  if (enabled) {
    input.value = _normalizedTimeoutSeconds(pipeConfig.timeout_per_phase, 600);
  } else if (!_normalizedTimeoutSeconds(input.value, 600)) {
    input.value = 600;
  }
  input.disabled = !enabled;
  input.style.opacity = enabled ? '1' : '0.45';
  note.textContent = enabled
    ? 'Active: run stops only after this many idle seconds.'
    : 'Unlimited (no inactivity timeout).';
  renderActivityHeartbeats();
}

function onChainTimeoutToggle() {
  const enabled = document.getElementById('timeout-step-enabled').checked;
  const input = document.getElementById('timeout-step');
  if (enabled && _normalizedTimeoutSeconds(input.value, 600) <= 0) input.value = 600;
  config.timeout_per_step = enabled ? _normalizedTimeoutSeconds(input.value, 600) : 0;
  syncChainTimeoutControlsFromConfig();
}

function onPipeTimeoutToggle() {
  const enabled = document.getElementById('pipe-timeout-enabled').checked;
  const input = document.getElementById('pipe-timeout');
  if (enabled && _normalizedTimeoutSeconds(input.value, 600) <= 0) input.value = 600;
  pipeConfig.timeout_per_phase = enabled ? _normalizedTimeoutSeconds(input.value, 600) : 0;
  syncPipeTimeoutControlsFromConfig();
}

function readChainTimeoutFromUi() {
  const enabled = document.getElementById('timeout-step-enabled').checked;
  const input = document.getElementById('timeout-step');
  return enabled ? _normalizedTimeoutSeconds(input.value, 600) : 0;
}

function readPipeTimeoutFromUi() {
  const enabled = document.getElementById('pipe-timeout-enabled').checked;
  const input = document.getElementById('pipe-timeout');
  return enabled ? _normalizedTimeoutSeconds(input.value, 600) : 0;
}

function _formatElapsedSeconds(totalSeconds) {
  const sec = Math.max(0, Math.floor(totalSeconds || 0));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  if (m <= 0) return s + 's';
  return m + 'm ' + s + 's';
}

const _SPINNER_FRAMES = ['|', '/', '-', '\\'];
function _spinnerFrame() {
  return _SPINNER_FRAMES[Math.floor(Date.now() / 250) % _SPINNER_FRAMES.length];
}

function _renderLastLogHint(elId, state) {
  const el = document.getElementById(elId);
  if (!el) return;
  const msg = (state.last_log_message || '').toString().trim();
  const level = (state.last_log_level || '').toString().toUpperCase();
  if (!msg) {
    el.textContent = 'Last log: none yet';
    return;
  }
  el.textContent = 'Last log' + (level ? ' [' + level + ']' : '') + ': ' + msg;
}

function _activityColor(idleSeconds, timeoutSeconds) {
  if (timeoutSeconds <= 0) return 'var(--text2)';
  if (idleSeconds >= timeoutSeconds * 0.8) return 'var(--danger)';
  if (idleSeconds >= timeoutSeconds * 0.5) return 'var(--warning)';
  return 'var(--success)';
}

function _renderActivityHeartbeat(elId, running, paused, lastActivityMs, timeoutSeconds) {
  const el = document.getElementById(elId);
  if (!el) return;

  if (!lastActivityMs) {
    if (running && !paused) {
      el.textContent = 'Activity: waiting for first output...';
      el.style.color = 'var(--text2)';
    } else if (running && paused) {
      el.textContent = 'Activity: paused (no output yet)';
      el.style.color = 'var(--warning)';
    } else {
      el.textContent = 'Activity: idle';
      el.style.color = 'var(--text2)';
    }
    return;
  }

  const idleSeconds = Math.max(0, Math.floor((Date.now() - lastActivityMs) / 1000));
  const at = new Date(lastActivityMs).toLocaleTimeString();

  if (!running) {
    el.textContent = 'Last output: ' + idleSeconds + 's ago at ' + at;
    el.style.color = 'var(--text2)';
    return;
  }

  if (paused) {
    el.textContent = 'Paused - last output ' + idleSeconds + 's ago at ' + at;
    el.style.color = 'var(--warning)';
    return;
  }

  if (timeoutSeconds > 0) {
    el.textContent =
      'Output activity: ' + idleSeconds + 's idle (timeout ' + timeoutSeconds + 's inactivity, last at ' + at + ')';
  } else {
    el.textContent = 'Output activity: ' + idleSeconds + 's idle (timeout disabled, last at ' + at + ')';
  }
  el.style.color = _activityColor(idleSeconds, timeoutSeconds);
}

function renderActivityHeartbeats() {
  _renderActivityHeartbeat(
    'activity-heartbeat',
    chainRunning,
    chainPaused,
    chainLastActivityMs,
    Number(config.timeout_per_step) || 0,
  );
  _renderActivityHeartbeat(
    'pipe-activity-heartbeat',
    pipeRunning,
    pipePaused,
    pipeLastActivityMs,
    Number(pipeConfig.timeout_per_phase) || 0,
  );
}

function markChainActivity() {
  chainLastActivityMs = Date.now();
  renderActivityHeartbeats();
}

function markPipeActivity() {
  pipeLastActivityMs = Date.now();
  renderActivityHeartbeats();
}

/* -- Unlimited Toggle ------------------------------------------- */
function toggleUnlimited() {
  const on = document.getElementById('unlimited').checked;
  config.unlimited = on;
  document.getElementById('threshold-group').style.display = on ? '' : 'none';

  // Max Loops - ignored in unlimited
  const loopsInput = document.getElementById('max-loops');
  const loopsNote = document.getElementById('max-loops-note');
  loopsInput.disabled = on;
  loopsInput.style.opacity = on ? '0.4' : '1';
  loopsNote.textContent = on ? '(ignored - unlimited)' : '';

  // Max Time - still enforced as a safety cap
  const timeInput = document.getElementById('max-time');
  const timeNote = document.getElementById('max-time-note');
  timeNote.textContent = on ? '(safety cap - still enforced)' : '';

  // Token Budget - still enforced as a safety cap
  const tokensNote = document.getElementById('max-tokens-note');
  tokensNote.textContent = on ? '(safety cap - still enforced)' : '';

  // Convergence - forced on in unlimited mode
  const convCheck = document.getElementById('stop-convergence');
  const convNote = document.getElementById('convergence-note');
  if (on) {
    convCheck.checked = true;
    convCheck.disabled = true;
    convCheck.style.opacity = '0.6';
    convNote.textContent = '(always on in unlimited)';
    config.stop_on_convergence = true;
  } else {
    convCheck.disabled = false;
    convCheck.style.opacity = '1';
    convNote.textContent = '';
  }
}

function toggleBrain() {
  const on = document.getElementById('brain-enabled').checked;
  config.brain_enabled = on;
  document.getElementById('brain-options').style.display = on ? '' : 'none';
  if (on) {
    config.brain_model = document.getElementById('brain-model').value;
  }
}

/* -- Ollama / Local Only --------------------------------------- */

let _ollamaModels = [];      // cached from server
let _ollamaRunning = false;

async function fetchOllamaModels() {
  try {
    const data = await api('/api/ollama/models');
    _ollamaRunning = data.running;
    _ollamaModels = data.models || [];
    // Populate dynamic <optgroup> slots
    populateOllamaOptions('chain-ollama-models', _ollamaModels);
    populateOllamaOptions('pipe-ollama-models', _ollamaModels);
  } catch (e) {
    console.warn('Could not fetch Ollama models', e);
  }
}

function populateOllamaOptions(groupId, models) {
  const group = document.getElementById(groupId);
  if (!group) return;
  if (!models.length) {
    group.innerHTML = '<option disabled>No Ollama models installed</option>';
    return;
  }
  group.innerHTML = models.map(m => {
    const sizeInfo = m.size_gb ? ' (' + m.size_gb + ' GB)' : '';
    const paramInfo = m.parameter_size ? ' - ' + m.parameter_size : '';
    return '<option value="' + m.ollama_id + '">Ollama - ' + m.display + paramInfo + sizeInfo + '</option>';
  }).join('');
}

function updateOllamaStatus(prefix) {
  const wrap = document.getElementById(prefix + 'ollama-status');
  const icon = document.getElementById(prefix + 'ollama-status-icon');
  const text = document.getElementById(prefix + 'ollama-status-text');
  if (!wrap) return;
  wrap.style.display = '';
  if (_ollamaRunning && _ollamaModels.length) {
    icon.textContent = '\u2705';
    text.textContent = 'Ollama running - ' + _ollamaModels.length + ' model' + (_ollamaModels.length !== 1 ? 's' : '') + ' available';
    text.style.color = '#4caf50';
  } else if (_ollamaRunning) {
    icon.textContent = '\u26a0\ufe0f';
    text.textContent = 'Ollama running but no models installed. Run: ollama pull gemma3:27b';
    text.style.color = 'var(--warning)';
  } else {
    icon.textContent = '\u274c';
    text.textContent = 'Ollama not running. Start with: ollama serve';
    text.style.color = 'var(--danger)';
  }
}

function toggleLocalOnly() {
  const on = document.getElementById('local-only').checked;
  config.local_only = on;
  fetchOllamaModels().then(() => {
    updateOllamaStatus('');
    const select = document.getElementById('brain-model');
    // Disable/enable cloud model option groups
    select.querySelectorAll('.cloud-model-group').forEach(g => {
      g.style.display = on ? 'none' : '';
      // Disable options inside hidden groups so they can't be submitted
      g.querySelectorAll('option').forEach(o => o.disabled = on);
    });
    if (on && _ollamaModels.length) {
      select.value = _ollamaModels[0].ollama_id;
      config.brain_model = select.value;
    }
  });
}

function togglePipeLocalOnly() {
  const on = document.getElementById('pipe-local-only').checked;
  pipeConfig.local_only = on;
  fetchOllamaModels().then(() => {
    updateOllamaStatus('pipe-');
    const select = document.getElementById('pipe-brain-model');
    select.querySelectorAll('.cloud-model-group').forEach(g => {
      g.style.display = on ? 'none' : '';
      g.querySelectorAll('option').forEach(o => o.disabled = on);
    });
    if (on && _ollamaModels.length) {
      select.value = _ollamaModels[0].ollama_id;
      pipeConfig.brain_model = select.value;
    }
  });
}

/* -- Repo Validation -------------------------------------------- */
let diagRefreshTimer = { chain: null, pipeline: null };
let diagRequestSeq = { chain: 0, pipeline: 0 };
let diagActionRunState = { chain: {}, pipeline: {} };
let diagInFlight = { chain: false, pipeline: false };
let diagLastSuccessAt = { chain: 0, pipeline: 0 };
const DIAG_REFRESH_DEBOUNCE_MS = 500;
const DIAG_SILENT_MIN_INTERVAL_MS = 15000;
const DIAG_CATEGORY_LABEL = {
  repository: 'Repository',
  codex: 'Codex',
  claude_code: 'Claude',
  agents: 'Agents',
};

function _collectChainAgentsForDiagnostics() {
  const enabled = (config.steps || []).filter(s => s.enabled !== false);
  if (!enabled.length) return ['codex'];
  const agents = enabled.map(s => (s.agent === 'auto' ? 'codex' : (s.agent || 'codex')));
  return Array.from(new Set(agents));
}

function _collectPipelineAgentsForDiagnostics() {
  const phaseEls = Array.from(document.querySelectorAll('#phase-list .phase-item'));
  if (phaseEls.length) {
    const active = [];
    phaseEls.forEach(el => {
      const enabledEl = el.querySelector('[data-phase-enabled]');
      if (!enabledEl || !enabledEl.checked) return;
      const agentSel = el.querySelector('[data-phase-agent]');
      active.push(agentSel ? (agentSel.value || 'codex') : (pipeConfig.agent || 'codex'));
    });
    if (active.length) return Array.from(new Set(active));
  }
  return [pipeConfig.agent || 'codex'];
}

function _diagnosticPayload(target) {
  if (target === 'pipeline') {
    return {
      repo_path: document.getElementById('pipe-repo-path').value.trim(),
      codex_binary: document.getElementById('pipe-codex-bin').value.trim() || 'codex',
      claude_binary: document.getElementById('pipe-claude-bin').value.trim() || 'claude',
      agents: _collectPipelineAgentsForDiagnostics(),
    };
  }
  return {
    repo_path: document.getElementById('repo-path').value.trim(),
    codex_binary: document.getElementById('codex-bin').value.trim() || 'codex',
    claude_binary: document.getElementById('claude-bin').value.trim() || 'claude',
    agents: _collectChainAgentsForDiagnostics(),
  };
}

function _diagStatusIcon(status) {
  if (status === 'pass') return '\u2705';
  if (status === 'warn') return '\u26a0\ufe0f';
  return '\u274c';
}

function renderDiagnostics(target, payload) {
  const summaryEl = document.getElementById(target === 'pipeline' ? 'diag-summary-pipeline' : 'diag-summary-chain');
  const listEl = document.getElementById(target === 'pipeline' ? 'diag-list-pipeline' : 'diag-list-chain');
  const actionsEl = document.getElementById(target === 'pipeline' ? 'diag-actions-pipeline' : 'diag-actions-chain');
  if (!summaryEl || !listEl || !actionsEl) return;

  const summary = payload && payload.summary ? payload.summary : { pass: 0, warn: 0, fail: 0 };
  const pass = summary.pass || 0;
  const warn = summary.warn || 0;
  const fail = summary.fail || 0;
  if (fail > 0) {
    summaryEl.textContent = 'Action required: ' + fail + ' failing checks, ' + warn + ' warnings.';
  } else if (warn > 0) {
    summaryEl.textContent = 'Ready with warnings: ' + pass + ' passing checks, ' + warn + ' warnings.';
  } else {
    summaryEl.textContent = 'Ready: all ' + pass + ' checks passed.';
  }

  const checks = Array.isArray(payload && payload.checks) ? payload.checks : [];
  if (!checks.length) {
    listEl.innerHTML = '<div class="diag-item"><div class="diag-detail">No diagnostics available.</div></div>';
  } else {
    listEl.innerHTML = checks.map(c => {
      const status = c.status || 'warn';
      const cls = 'diag-item diag-' + status;
      const category = DIAG_CATEGORY_LABEL[c.category] || c.category || 'Check';
      const label = (c.label || 'Check');
      const detail = c.detail || '';
      const hint = c.hint || '';
      return '<div class="' + cls + '">'
        + '<div class="diag-main">'
        +   '<span class="diag-icon">' + _diagStatusIcon(status) + '</span>'
        +   '<span class="diag-title">' + escHtml(category + ': ' + label) + '</span>'
        + '</div>'
        + '<div class="diag-detail">' + escHtml(detail) + '</div>'
        + (hint ? ('<div class="diag-hint">Fix: ' + escHtml(hint) + '</div>') : '')
        + '</div>';
    }).join('');
  }

  const actions = Array.isArray(payload && payload.next_actions) ? payload.next_actions : [];
  if (!actions.length) {
    actionsEl.innerHTML = '';
  } else {
    actionsEl.innerHTML = '<div class="diag-actions-title">Next actions</div>'
      + actions.map((action, idx) => {
        const severity = (action.severity || 'required').toLowerCase();
        const cls = severity === 'required' ? 'diag-action-required' : 'diag-action-recommended';
        const badge = severity === 'required' ? 'Required' : 'Recommended';
        const title = action.title || 'Action';
        const detail = action.detail || '';
        const command = action.command || '';
        const key = action.key || '';
        const canRun = !!action.can_run;
        const runState = (diagActionRunState[target] || {})[key] || null;
        const runClass = runState
          ? (runState.ok ? 'ok' : 'fail')
          : '';
        const runText = runState
          ? ('Last run: ' + (runState.ok ? 'ok' : 'failed') + ' (exit ' + String(runState.exit_code) + ')')
          : '';
        return '<div class="diag-action ' + cls + '">'
          + '<div class="diag-action-head">'
          +   '<span class="diag-action-rank">' + String(idx + 1) + '.</span>'
          +   '<span class="diag-action-title">[' + escHtml(badge) + '] ' + escHtml(title) + '</span>'
          + '</div>'
          + (detail ? ('<div class="diag-action-detail">' + escHtml(detail) + '</div>') : '')
          + (command ? ('<div class="diag-action-command">Command: ' + escHtml(command) + '</div>') : '')
          + (command
            ? ('<div class="diag-action-controls">'
              + '<button class="btn" type="button" data-command="' + escAttr(command) + '" onclick="copyDiagnosticsCommand(this)">Copy</button>'
              + (canRun
                ? ('<button class="btn btn-primary" type="button" data-target="' + escAttr(target) + '" data-action-key="' + escAttr(key) + '" onclick="runDiagnosticsAction(this)">Run</button>')
                : '')
              + '</div>')
            : '')
          + (runText ? ('<div class="diag-action-run-state ' + runClass + '">' + escHtml(runText) + '</div>') : '')
          + '</div>';
      }).join('');
  }
}

async function copyDiagnosticsCommand(btn) {
  const command = (btn && btn.dataset && btn.dataset.command) ? btn.dataset.command : '';
  if (!command) {
    toast('No command is available for this action.', 'error');
    return;
  }
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(command);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = command;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      textarea.remove();
    }
    toast('Copied diagnostics command.', 'success');
  } catch (e) {
    toast('Could not copy command to clipboard.', 'error');
  }
}

async function runDiagnosticsAction(btn) {
  const target = (btn && btn.dataset && btn.dataset.target) ? btn.dataset.target : 'chain';
  const actionKey = (btn && btn.dataset && btn.dataset.actionKey) ? btn.dataset.actionKey : '';
  if (!actionKey) {
    toast('Missing diagnostics action key.', 'error');
    return;
  }
  const original = btn.textContent || 'Run';
  btn.disabled = true;
  btn.textContent = 'Running...';
  try {
    const payload = _diagnosticPayload(target);
    payload.action_key = actionKey;
    const result = await postJson('/api/diagnostics/actions/run', payload);
    if (result && result.error) {
      throw new Error(result.error);
    }
    if (!diagActionRunState[target]) {
      diagActionRunState[target] = {};
    }
    diagActionRunState[target][actionKey] = {
      ok: !!(result && result.ok),
      exit_code: Number(result && result.exit_code ? result.exit_code : 0),
    };
    if (result && result.ok) {
      const successMsg = String((result && result.message) || 'Diagnostics action completed.');
      toast(successMsg, 'success');
    } else {
      const err = (result && result.stderr) ? result.stderr.split('\n')[0] : '';
      toast(
        'Diagnostics action failed (exit ' + String((result && result.exit_code) || '?') + ')'
          + (err ? ': ' + err : '.'),
        'error'
      );
    }
    await refreshDiagnostics(target, { silent: true, force: true });
  } catch (e) {
    toast((e && e.message) || 'Failed to run diagnostics action.', 'error');
  } finally {
    btn.disabled = false;
    btn.textContent = original;
  }
}

function scheduleDiagnosticsRefresh(target, opts = {}) {
  const options = opts || {};
  const delay = Number.isFinite(Number(options.delayMs))
    ? Math.max(0, Number(options.delayMs))
    : DIAG_REFRESH_DEBOUNCE_MS;
  const silent = options.silent !== false;
  const force = !!options.force;
  if (diagRefreshTimer[target]) clearTimeout(diagRefreshTimer[target]);
  diagRefreshTimer[target] = setTimeout(
    () => refreshDiagnostics(target, { silent, force }),
    delay
  );
}

async function refreshDiagnostics(target, opts) {
  const options = opts || {};
  const silent = !!options.silent;
  const force = !!options.force || !silent;
  const summaryEl = document.getElementById(target === 'pipeline' ? 'diag-summary-pipeline' : 'diag-summary-chain');
  const listEl = document.getElementById(target === 'pipeline' ? 'diag-list-pipeline' : 'diag-list-chain');
  if (!summaryEl || !listEl) return;
  if (silent && !force) {
    const ageMs = Date.now() - Number(diagLastSuccessAt[target] || 0);
    if (ageMs >= 0 && ageMs < DIAG_SILENT_MIN_INTERVAL_MS) return;
  }
  if (diagInFlight[target]) {
    if (force) {
      scheduleDiagnosticsRefresh(target, { delayMs: 350, silent, force: true });
    }
    return;
  }

  diagInFlight[target] = true;
  const reqId = (diagRequestSeq[target] || 0) + 1;
  diagRequestSeq[target] = reqId;
  if (!silent) {
    summaryEl.textContent = 'Running diagnostics...';
  }

  try {
    const payload = _diagnosticPayload(target);
    const data = await postJson('/api/diagnostics', payload);
    if (data && data.error) throw new Error(data.error);
    if (diagRequestSeq[target] !== reqId) return;
    renderDiagnostics(target, data || {});
    diagLastSuccessAt[target] = Date.now();
  } catch (e) {
    if (diagRequestSeq[target] !== reqId) return;
    summaryEl.textContent = 'Diagnostics request failed.';
    listEl.innerHTML = '<div class="diag-item diag-fail"><div class="diag-detail">Could not load diagnostics. ' + esc((e && e.message) || 'Check server logs.') + '</div></div>';
  } finally {
    diagInFlight[target] = false;
  }
}

let repoTimeout;
function maybeAutoEnableVectorMemory(target, payload) {
  if (!payload || !payload.vector_memory_detected) return;
  const repoPath = String(payload.path || '').trim();
  if (!repoPath) return;

  let enabledNow = false;
  if (target === 'pipeline') {
    if (!pipeConfig.vector_memory_enabled) {
      pipeConfig.vector_memory_enabled = true;
      syncPipelineCapabilityControlsFromConfig();
      enabledNow = true;
    }
  } else {
    if (!config.vector_memory_enabled) {
      config.vector_memory_enabled = true;
      syncChainCapabilityControlsFromConfig();
      enabledNow = true;
    }
  }

  if (enabledNow && _autoVectorMemoryNotified[target] !== repoPath) {
    toast('Detected existing vector memory for this repository and enabled it automatically.', 'info');
    _autoVectorMemoryNotified[target] = repoPath;
  }
}

function validateRepo() {
  clearTimeout(repoTimeout);
  const path = document.getElementById('repo-path').value.trim();
  config.repo_path = path;
  scheduleDiagnosticsRefresh('chain');
  scheduleGitSyncRefresh({ delayMs: 300, silent: true });
  if (!path) {
    document.getElementById('repo-status').textContent = '';
    refreshChainOutputs(false);
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }
  refreshChainOutputs(false);
  repoTimeout = setTimeout(async () => {
    try {
      const r = await postJson('/api/validate-repo', {path});
      if (path !== document.getElementById('repo-path').value.trim()) return;
      const el = document.getElementById('repo-status');
      if (r.is_git)       { el.textContent = '\u2705'; el.title = 'Valid git repo'; }
      else if (r.exists)  { el.textContent = '\u26a0\ufe0f'; el.title = 'Directory exists but not a git repo'; }
      else                { el.textContent = '\u274c'; el.title = 'Path not found'; }
      maybeAutoEnableVectorMemory('chain', r);
      scheduleGitSyncRefresh({ delayMs: 0, silent: true });
    } catch(e) { /* ignore */ }
  }, 400);
}

/* -- Steps ------------------------------------------------------ */
function addStep() {
  const defaultType = 'feature_discovery';
  const p = presets.find(x => x.key === defaultType);
  const step = {
    id: Math.random().toString(36).substring(2, 10),
    name: p ? p.name : 'New Step',
    job_type: defaultType,
    prompt_mode: 'preset',
    custom_prompt: '',
    on_failure: 'skip',
    max_retries: 1,
    loop_count: 1,
    enabled: true,
    agent: 'codex',
  };
  config.steps.push(step);
  selectedStepId = step.id;
  renderSteps();
  renderStepDetails();
}

function removeStep(id) {
  config.steps = config.steps.filter(s => s.id !== id);
  if (selectedStepId === id) selectedStepId = config.steps.length ? config.steps[0].id : null;
  renderSteps();
  renderStepDetails();
}

function moveStep(id, dir) {
  const idx = config.steps.findIndex(s => s.id === id);
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= config.steps.length) return;
  [config.steps[idx], config.steps[newIdx]] = [config.steps[newIdx], config.steps[idx]];
  renderSteps();
}

function selectStep(id) {
  selectedStepId = id;
  renderSteps();
  renderStepDetails();
}

function toggleStepEnabled(id) {
  const s = config.steps.find(x => x.id === id);
  if (s) s.enabled = !s.enabled;
  renderSteps();
  renderStepDetails();
}

function getPresetIcon(jobType) {
  const p = presets.find(x => x.key === jobType);
  return p ? p.icon : '\ud83c\udfaf';
}

function getPresetPrompt(jobType, mode) {
  return fetch('/api/presets/' + jobType)
    .then(r => r.json())
    .then(data => {
      if (mode === 'ai_decides') return data.ai_prompt || data.prompt || '';
      return data.prompt || '';
    })
    .catch(() => '');
}

/* -- Render: Step List ------------------------------------------ */
function renderSteps() {
  const list = document.getElementById('step-list');
  document.getElementById('step-count').textContent = '(' + config.steps.length + ')';
  const collisionDetails = getStepOutputCollisionDetails(config.steps);
  const duplicateIds = duplicateStepIdSet(collisionDetails);

  if (!config.steps.length) {
    list.innerHTML = '<div class="state-card">No steps yet. Click <strong>+ Add Step</strong> to begin.</div>';
    renderStepCollisionAlert([]);
    document.getElementById('step-details-wrap').style.display = 'none';
    scheduleDiagnosticsRefresh('chain');
    return;
  }

  list.innerHTML = config.steps.map((step, i) => {
    const sel  = step.id === selectedStepId ? 'selected' : '';
    const dis  = !step.enabled ? 'disabled-step' : '';
    const dup  = duplicateIds.has(step.id) ? 'duplicate-step' : '';
    const dupMark = duplicateIds.has(step.id)
      ? '<span class="step-dup-mark" title="Duplicate output filename - rename this step">&#10060;</span>'
      : '<span class="step-dup-mark"></span>';
    return '<div class="step-item ' + sel + ' ' + dis + ' ' + dup + '"'
      + ' role="button" tabindex="0" aria-pressed="' + (step.id === selectedStepId ? 'true' : 'false') + '"'
      + ' onclick="selectStep(\'' + step.id + '\')"'
      + ' onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();selectStep(\'' + step.id + '\')}">'
      + '<span class="step-num">' + (i+1) + '</span>'
      + '<span class="step-icon">' + getPresetIcon(step.job_type) + '</span>'
      + '<span class="step-name">' + esc(step.name || step.job_type) + (step.loop_count > 1 ? ' <span style="font-size:10px;color:var(--accent);font-weight:600">\u00d7' + step.loop_count + '</span>' : '') + '</span>'
      + dupMark
      + '<span class="step-actions">'
      +   '<button title="Toggle" onclick="toggleStepEnabled(\'' + step.id + '\');event.stopPropagation()">' + (step.enabled ? '\u25cf' : '\u25cb') + '</button>'
      +   '<button title="Move up" onclick="moveStep(\'' + step.id + '\',-1);event.stopPropagation()">\u25b2</button>'
      +   '<button title="Move down" onclick="moveStep(\'' + step.id + '\',1);event.stopPropagation()">\u25bc</button>'
      +   '<button title="Remove" onclick="removeStep(\'' + step.id + '\');event.stopPropagation()">\u2715</button>'
      + '</span>'
    + '</div>';
  }).join('');
  renderStepCollisionAlert(collisionDetails);
  scheduleDiagnosticsRefresh('chain');
}

/* -- Render: Step Details --------------------------------------- */
async function renderStepDetails() {
  const wrap = document.getElementById('step-details-wrap');
  const el = document.getElementById('step-details');
  if (!selectedStepId) { wrap.style.display = 'none'; return; }
  const step = config.steps.find(s => s.id === selectedStepId);
  if (!step) { wrap.style.display = 'none'; return; }
  wrap.style.display = '';

  const stepCollision = getStepOutputCollisionDetails(config.steps)
    .find(c => (c.steps || []).some(s => s.id === step.id));
  let stepNameWarning = '';
  if (stepCollision) {
    const conflicting = (stepCollision.steps || [])
      .filter(s => s.id !== step.id)
      .map(s => s.name || 'step')
      .join(', ');
    stepNameWarning =
      '<div class="step-name-warning">'
      + '<strong>&#10060; This step name conflicts with another step.</strong><br>'
      + 'Output file collision: <code>' + esc(stepCollision.file) + '</code><br>'
      + 'Also used by: ' + esc(conflicting || 'another step') + '<br>'
      + 'Fix by renaming this step to a unique name.'
      + '</div>';
  }

  // Build options for job type
  let typeOpts = presets.map(p =>
    '<option value="' + p.key + '"' + (p.key === step.job_type ? ' selected' : '') + '>'
    + p.icon + ' ' + p.name + '</option>'
  ).join('');
  typeOpts += '<option value="custom"' + (step.job_type === 'custom' ? ' selected' : '') + '>\ud83c\udfaf Custom</option>';

  // Get prompt text
  let promptText = step.custom_prompt;
  const isCustom = step.prompt_mode === 'custom' || step.job_type === 'custom';
  if (!isCustom && step.job_type !== 'custom') {
    try {
      promptText = await getPresetPrompt(step.job_type, step.prompt_mode);
    } catch(e) {}
  }

  el.innerHTML = ''
    + '<div class="detail-header">'
    +   '<span class="detail-title">' + getPresetIcon(step.job_type) + ' ' + esc(step.name) + '</span>'
    +   '<label style="margin:0;cursor:pointer"><input type="checkbox"' + (step.enabled ? ' checked' : '') + ' onchange="toggleStepEnabled(\'' + step.id + '\')"> Enabled</label>'
    + '</div>'
    + stepNameWarning
    // Job Type
    + '<div class="form-row"><label>Job Type</label>'
    +   '<select onchange="onJobTypeChange(this.value)">' + typeOpts + '</select>'
    + '</div>'
    // Name
    + '<div class="form-row"><label>Step Name <span class="help-icon" title="The step name becomes the output filename (e.g. &quot;Dream Up Ideas&quot; -> .codex_manager/outputs/Dream-Up-Ideas.md). Later steps can read this file. Use clear names so steps can reference each other.">?</span></label>'
    +   '<input type="text" value="' + esc(step.name) + '" onchange="updateStep(\'name\',this.value)" placeholder="e.g. Dream Up Ideas -> .codex_manager/outputs/Dream-Up-Ideas.md">'
    + '</div>'
    // Prompt Mode
    + '<div class="form-row"><label>Prompt Mode</label>'
    +   '<div class="radio-group">'
    +     '<label><input type="radio" name="pm" value="preset"'     + (step.prompt_mode==='preset'?' checked':'')     + ' onchange="updateStep(\'prompt_mode\',\'preset\');renderStepDetails()"> Preset</label>'
    +     '<label><input type="radio" name="pm" value="ai_decides"' + (step.prompt_mode==='ai_decides'?' checked':'') + ' onchange="updateStep(\'prompt_mode\',\'ai_decides\');renderStepDetails()"> AI Decides</label>'
    +     '<label><input type="radio" name="pm" value="custom"'     + (step.prompt_mode==='custom'?' checked':'')     + ' onchange="updateStep(\'prompt_mode\',\'custom\');renderStepDetails()"> Custom</label>'
    +   '</div>'
    + '</div>'
    // Prompt Preview
    + '<div class="form-row prompt-preview"><label>Prompt</label>'
    +   '<textarea id="prompt-textarea" rows="5"' + (isCustom ? '' : ' readonly') + ' onchange="updateStep(\'custom_prompt\',this.value)">' + esc(promptText) + '</textarea>'
    +   (isCustom ? '' : '<span class="readonly-badge">read-only</span>')
    + '</div>'
    // On Failure
    + '<div class="form-row-inline">'
    +   '<div class="form-row"><label>On Failure</label>'
    +     '<select onchange="updateStep(\'on_failure\',this.value);renderStepDetails()">'
    +       '<option value="skip"'  + (step.on_failure==='skip'?' selected':'')  + '>Skip to next</option>'
    +       '<option value="retry"' + (step.on_failure==='retry'?' selected':'') + '>Retry</option>'
    +       '<option value="abort"' + (step.on_failure==='abort'?' selected':'') + '>Abort chain</option>'
    +     '</select>'
    +   '</div>'
    +   (step.on_failure === 'retry'
      ? '<div class="form-row"><label>Max Retries</label><input type="number" value="' + step.max_retries + '" min="1" max="10" onchange="updateStep(\'max_retries\',parseInt(this.value))"></div>'
      : '<div class="form-row"></div>')
    + '</div>'
    // Step loop count
    + '<div class="form-row"><label>Repeat This Step</label>'
    +   '<div style="display:flex;align-items:center;gap:8px">'
    +     '<input type="number" value="' + (step.loop_count || 1) + '" min="1" max="100" style="width:70px" onchange="updateStep(\'loop_count\',parseInt(this.value)||1)">'
    +     '<span style="font-size:12px;color:var(--text2)">' + ((step.loop_count || 1) > 1 ? 'times before advancing to next step' : 'time (run once)') + '</span>'
    +   '</div>'
    + '</div>'
    // Agent selection (Expert only)
    + '<div class="form-row medium-hide" style="margin-top:10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px">'
    +   '<label style="margin-bottom:4px">Agent</label>'
    +   '<select onchange="updateStep(\'agent\',this.value)">'
    +     '<option value="codex"'      + (step.agent==='codex'?' selected':'')      + '>\ud83d\udfe2 Codex (OpenAI)</option>'
    +     '<option value="claude_code"' + (step.agent==='claude_code'?' selected':'') + '>\ud83d\udfe3 Claude Code (Anthropic)</option>'
    +     '<option value="auto"'        + (step.agent==='auto'?' selected':'')        + '>\u2728 Auto (Brain decides)</option>'
    +   '</select>'
    +   '<p style="font-size:11px;color:var(--text2);margin-top:4px">'
    +     (step.agent === 'codex' ? 'OpenAI Codex CLI - best for code generation and refactoring' : step.agent === 'claude_code' ? 'Anthropic Claude Code - strong at analysis, testing, and complex reasoning' : 'Let the AI Brain choose the best agent for this step')
    +   '</p>'
    + '</div>';
}

function onJobTypeChange(val) {
  const step = config.steps.find(s => s.id === selectedStepId);
  if (!step) return;
  step.job_type = val;
  if (val !== 'custom') {
    const p = presets.find(x => x.key === val);
    if (p) step.name = p.name;
    if (step.prompt_mode === 'custom') step.prompt_mode = 'preset';
  } else {
    step.name = step.name || 'Custom Step';
    step.prompt_mode = 'custom';
  }
  renderSteps();
  renderStepDetails();
}

function updateStep(field, value) {
  const step = config.steps.find(s => s.id === selectedStepId);
  if (step) step[field] = value;
  if (field === 'name') {
    renderSteps();
    renderStepDetails();
  }
  if (field === 'agent') scheduleDiagnosticsRefresh('chain');
}

/* -- Execution Control ------------------------------------------ */
async function startChain(options = {}) {
  const opts = options || {};
  // Sync config from UI inputs
  config.repo_path             = document.getElementById('repo-path').value.trim();
  config.unlimited             = document.getElementById('unlimited').checked;
  config.improvement_threshold = parseFloat(document.getElementById('threshold-slider').value) || 1.0;
  config.max_loops             = parseInt(document.getElementById('max-loops').value) || 3;
  config.max_time_minutes      = parseInt(document.getElementById('max-time').value) || 120;
  config.max_total_tokens      = parseInt(document.getElementById('max-tokens').value) || 2000000;
  config.strict_token_budget   = document.getElementById('strict-token-budget').checked;
  config.stop_on_convergence   = document.getElementById('stop-convergence').checked;
  config.test_cmd              = document.getElementById('test-cmd').value.trim();
  config.codex_binary          = document.getElementById('codex-bin').value.trim();
  config.codex_reasoning_effort = document.getElementById('codex-reasoning-effort').value;
  config.codex_sandbox_mode    = document.getElementById('codex-sandbox-mode').value;
  config.codex_approval_policy = document.getElementById('codex-approval-policy').value;
  config.codex_bypass_approvals_and_sandbox = document.getElementById('codex-bypass-approvals').checked;
  config.claude_binary         = document.getElementById('claude-bin').value.trim();
  config.timeout_per_step      = readChainTimeoutFromUi();
  config.parallel_execution    = document.getElementById('parallel-exec').checked;
  config.brain_enabled         = document.getElementById('brain-enabled').checked;
  config.brain_model           = document.getElementById('brain-model').value;
  config.local_only            = document.getElementById('local-only').checked;
  config.allow_path_creation   = document.getElementById('chain-allow-path-creation').checked;
  config.dependency_install_policy = document.getElementById('chain-dependency-install-policy').value;
  config.image_generation_enabled = document.getElementById('chain-image-generation-enabled').checked;
  config.image_provider        = document.getElementById('chain-image-provider').value;
  config.image_model           = document.getElementById('chain-image-model').value.trim();
  config.vector_memory_enabled = document.getElementById('chain-vector-memory-enabled').checked;
  config.vector_memory_backend = document.getElementById('chain-vector-memory-backend').value;
  config.vector_memory_collection = document.getElementById('chain-vector-memory-collection').value.trim();
  config.vector_memory_top_k = parseInt(document.getElementById('chain-vector-memory-top-k').value, 10) || 8;
  config.git_preflight_enabled = document.getElementById('chain-git-preflight-enabled').checked;
  config.git_preflight_auto_stash = document.getElementById('chain-git-preflight-auto-stash').checked;
  config.git_preflight_auto_pull = document.getElementById('chain-git-preflight-auto-pull').checked;
  if (!config.git_preflight_enabled) {
    config.git_preflight_auto_stash = false;
    config.git_preflight_auto_pull = false;
  }
  toggleChainGitPreflight();
  normalizeCodexPermissions(config);
  normalizeCapabilitySettings(config);
  syncChainPermissionControlsFromConfig();
  syncChainCapabilityControlsFromConfig();
  syncChainTimeoutControlsFromConfig();

  if (!config.repo_path) { toast('Set a repository path first', 'error'); return; }
  if (!config.steps.length) { toast('Add at least one step', 'error'); return; }
  const collisionDetails = getStepOutputCollisionDetails(config.steps);
  if (collisionDetails.length) {
    renderSteps();
    const detail = collisionDetails
      .map(c => c.file + ' (' + (c.steps || []).map(s => s.name).join(', ') + ')')
      .join('; ');
    toast('Duplicate step names detected. Rename steps marked with X to make output files unique. Conflicts: ' + detail, 'error');
    return;
  }
  const chainUsesCodex = config.steps.some(s => s.enabled && (s.agent || 'auto') !== 'claude_code');
  let selectedProfile = _permissionProfileFromConfig(config);
  if (!opts.skipRunPlan) {
    const runPlan = await openRunPlanModal('chain');
    if (!applyRunPlanChoice(runPlan)) return;
    selectedProfile = runPlan.profile || selectedProfile;
  } else {
    selectedProfile = _permissionProfileFromConfig(config);
  }
  if ((selectedProfile || 'safe') === 'readonly' && chainUsesCodex) {
    toast('Read-Only Inspect selected: Codex can analyze but cannot write files in this run.', 'info');
  }
  if (!requestDangerConfirmationIfNeeded(config)) return;

  // Resolve custom prompts for non-custom steps (so backend has the text)
  for (const step of config.steps) {
    if (step.prompt_mode !== 'custom' && step.job_type !== 'custom') {
      try {
        step.custom_prompt = await getPresetPrompt(step.job_type, step.prompt_mode);
      } catch(e) {}
    }
  }

  // Clear previous results
  chainLogEntries = [];
  chainResultsCache = [];
  chainResultsCount = 0;
  _chainResultsRenderSignature = '';
  chainLastActivityMs = 0;
  chainRunning = true;
  chainPaused = false;
  const stopAfterStep = document.getElementById('stop-after-step');
  if (stopAfterStep) stopAfterStep.checked = false;
  renderActivityHeartbeats();
  document.getElementById('progress-last-log').textContent = 'Last log: waiting for first message...';
  renderStopGuidance('chain-stop-guidance', null, false);
  document.getElementById('log-viewer').innerHTML = '<div class="log-empty state-card loading">Connecting to live log stream...</div>';
  document.getElementById('results-body').innerHTML = '<tr><td colspan="9"><div class="state-card loading">Waiting for step results...</div></td></tr>';
  setLogContentState(document.getElementById('chain-output-content'), 'Waiting for step output files...', 'loading');
  document.getElementById('chain-output-select').innerHTML = '<option value="">No output files yet</option>';
  document.getElementById('chain-output-dir').textContent = '';
  _lastOutputRefreshStepCount = -1;

  const resp = await postJson('/api/chain/start', config);
  if (resp.error) {
    chainRunning = false;
    chainPaused = false;
    renderActivityHeartbeats();
    document.getElementById('log-viewer').innerHTML = '<div class="log-empty state-card error">Could not start chain. Check diagnostics and configuration.</div>';
    document.getElementById('results-body').innerHTML = '<tr><td colspan="9"><div class="state-card">No execution results yet. Run a chain to populate this table.</div></td></tr>';
    toast(resp.error, 'error');
    return;
  }

  setControlsRunning(true);
  connectSSE();
  startPolling();
  refreshChainOutputs(false);
  if ((config.mode || 'dry-run') === 'dry-run') {
    toast('SAFE MODE ACTIVE: Dry Run is enabled. Changes are evaluated and then reverted.', 'info');
  }
  const gitPreflight = (resp && typeof resp.git_preflight === 'object') ? resp.git_preflight : null;
  if (gitPreflight) {
    const actions = Array.isArray(gitPreflight.actions) ? gitPreflight.actions : [];
    const warnings = Array.isArray(gitPreflight.warnings) ? gitPreflight.warnings : [];
    if (actions.length) {
      toast('Git pre-flight: ' + actions.join(' | '), 'info');
    }
    if (warnings.length) {
      toast('Git pre-flight warnings: ' + warnings.join(' | '), 'warn');
    }
  }
  toast('Chain started', 'success');
}

async function stopChain() {
  const r = await postJson('/api/chain/stop');
  if (r.error) {
    toast(r.error, 'error');
    return;
  }
  toast('Stop requested', 'info');
}

async function toggleStopAfterStep(enabled) {
  const checkbox = document.getElementById('stop-after-step');
  if (!chainRunning) {
    if (checkbox) checkbox.checked = false;
    return;
  }

  const r = await postJson('/api/chain/stop-after-step', { enabled: !!enabled });
  if (r.error) {
    if (checkbox) checkbox.checked = !enabled;
    toast(r.error, 'error');
    return;
  }

  const armed = !!r.stop_after_current_step;
  if (checkbox) checkbox.checked = armed;
  toast(
    armed
      ? 'Chain will stop after the current step completes'
      : 'Chain will continue to the next step',
    'info',
  );
}

async function pauseChain() {
  const r = await postJson('/api/chain/pause');
  if (r.error) {
    toast(r.error, 'error');
    return;
  }
  document.getElementById('btn-pause').innerHTML = r.status === 'paused' ? '&#9654; Resume' : '&#9208; Pause';
}

function setControlsRunning(running) {
  document.getElementById('btn-feature-dream-next').disabled = running;
  document.getElementById('btn-start').disabled = running;
  document.getElementById('btn-pause').disabled = !running;
  document.getElementById('btn-stop').disabled  = !running;
  const stopAfterStep = document.getElementById('stop-after-step');
  if (stopAfterStep) {
    stopAfterStep.disabled = !running;
    if (!running) stopAfterStep.checked = false;
  }
}

/* -- SSE Connection --------------------------------------------- */
function connectSSE() {
  if (eventSource) eventSource.close();
  eventSource = new EventSource('/api/stream');
  eventSource.onmessage = (e) => {
    let data;
    try { data = JSON.parse(e.data); } catch { return; }
    if (data.type === 'heartbeat') return;
    addLogEntry(data);
  };
  eventSource.onerror = () => {
    // Will auto-reconnect
  };
}

function disconnectSSE() {
  if (eventSource) { eventSource.close(); eventSource = null; }
}

function normalizeLogMessage(msg) {
  let text = (msg || '').toString();
  // Strip OSC and CSI ANSI escape sequences.
  text = text.replace(/\u001b\][^\u0007]*(?:\u0007|\u001b\\)/g, '');
  text = text.replace(/\u001b\[[0-9;]*[A-Za-z]/g, '');
  // Drop remaining non-printable control chars that can visually corrupt the log.
  text = text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '');
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  text = text.replace(/\n{3,}/g, '\n\n');
  return text;
}

function isDebugLogEntry(entry) {
  const msg = normalizeLogMessage(entry.message || '');
  return msg.includes('[DEBUG]');
}

function shouldShowLogEntry(entry, isPipe) {
  const debugToggle = document.getElementById(isPipe ? 'pipe-show-debug-logs' : 'show-debug-logs');
  const showDebug = !!(debugToggle && debugToggle.checked);
  return showDebug || !isDebugLogEntry(entry);
}

function appendLogEntry(viewerId, entry) {
  const viewer = document.getElementById(viewerId);
  const empty = viewer.querySelector('.log-empty');
  if (empty) empty.remove();

  const div = document.createElement('div');
  div.className = 'log-entry log-' + (entry.level || 'info');
  div.innerHTML = ''
    + '<span class="log-time">' + esc(entry.time || '') + '</span>'
    + '<span class="log-msg">' + esc(normalizeLogMessage(entry.message || '')) + '</span>';
  viewer.appendChild(div);
  viewer.scrollTop = viewer.scrollHeight;
}

function renderChainLogViewer() {
  const viewer = document.getElementById('log-viewer');
  viewer.innerHTML = '';
  const filtered = chainLogEntries.filter(e => shouldShowLogEntry(e, false));
  if (!filtered.length) {
    viewer.innerHTML = '<div class="log-empty state-card">No log entries to show.</div>';
    return;
  }
  filtered.forEach(e => appendLogEntry('log-viewer', e));
}

function toggleDebugLogs() {
  renderChainLogViewer();
}

function addLogEntry(entry) {
  markChainActivity();
  chainLogEntries.push(entry);
  if (chainLogEntries.length > 4000) chainLogEntries.shift();
  if (!shouldShowLogEntry(entry, false)) return;
  appendLogEntry('log-viewer', entry);
}

/* -- Status Polling --------------------------------------------- */
function startPolling() {
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(pollStatus, 1500);
}

function stopPolling() {
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
}

async function pollStatus() {
  try {
    const s = await api('/api/chain/status?since_results=' + encodeURIComponent(chainResultsCount));
    if (s && s.error) {
      setBackendOnlineState(false, s.error);
      return;
    }
    updateProgress(s);
    const next = _consumeResultsPayload(s, chainResultsCache, chainResultsCount);
    chainResultsCache = next.results;
    chainResultsCount = next.total;
    updateResults(chainResultsCache);
    const done = s.total_steps_completed || 0;
    if (done !== _lastOutputRefreshStepCount) {
      _lastOutputRefreshStepCount = done;
      refreshChainOutputs(true);
    }

    if (!s.running) {
      await _finalizePendingGeneralRequestRun(s);
      setControlsRunning(false);
      stopPolling();
      disconnectSSE();
      refreshChainOutputs(true);
    }
  } catch(e) { /* ignore */ }
}

function updateProgress(s) {
  chainRunning = !!s.running;
  chainPaused = !!s.paused;
  const statusRepoPath = String(s.repo_path || '').trim();
  if (statusRepoPath && !config.repo_path) {
    config.repo_path = statusRepoPath;
    const repoInput = document.getElementById('repo-path');
    if (repoInput) repoInput.value = statusRepoPath;
    validateRepo();
  }
  const stopAfterCurrentStep = !!s.stop_after_current_step;
  const stopAfterCheckbox = document.getElementById('stop-after-step');
  if (stopAfterCheckbox) stopAfterCheckbox.checked = stopAfterCurrentStep;
  const stopGuidance = s.stop_guidance || null;
  if (s.last_log_epoch_ms) chainLastActivityMs = s.last_log_epoch_ms;
  renderActivityHeartbeats();
  _renderLastLogHint('progress-last-log', s);
  const configuredStepsFromConfig = config.steps.length;
  const configuredStepsFromStatus = Number.isFinite(Number(s.configured_steps_count))
    ? Number(s.configured_steps_count)
    : 0;
  const configuredSteps = configuredStepsFromConfig > 0
    ? configuredStepsFromConfig
    : Math.max(0, configuredStepsFromStatus);
  const enabledFromConfig = config.steps.filter(x => x.enabled).length;
  const enabledFromStatus = Number.isFinite(Number(s.enabled_steps_count))
    ? Number(s.enabled_steps_count)
    : 0;
  const enabledSteps = enabledFromConfig > 0 ? enabledFromConfig : Math.max(0, enabledFromStatus);
  const done = s.total_steps_completed || 0;
  const runUnlimited = typeof s.run_unlimited === 'boolean' ? s.run_unlimited : !!config.unlimited;
  const runMaxLoops = Number.isFinite(Number(s.run_max_loops)) && Number(s.run_max_loops) > 0
    ? Number(s.run_max_loops)
    : (parseInt(document.getElementById('max-loops').value) || config.max_loops || 1);
  const totalSteps = Math.max(1, configuredSteps || enabledSteps);

  let pct;
  if (runUnlimited) {
    // In unlimited mode the bar shows improvement remaining (100% = lots of room, approaching 0% = converging)
    pct = Math.min(100, Math.max(0, Math.round(s.improvement_pct || 100)));
  } else {
    const maxSteps = enabledSteps * runMaxLoops;
    pct = maxSteps > 0 ? Math.min(100, Math.round(done / maxSteps * 100)) : 0;
  }

  const progressFill = document.getElementById('progress-fill');
  progressFill.style.width = pct + '%';
  progressFill.classList.toggle('running', !!s.running && !s.paused);

  // Token count + improvement badge
  let tokenText = (s.total_tokens || 0).toLocaleString() + ' tokens';
  if (s.improvement_pct !== undefined && s.improvement_pct < 200 && done > 0) {
    tokenText += '  |  improvement: ' + (s.improvement_pct || 0).toFixed(1) + '%';
  }
  document.getElementById('progress-tokens').textContent = tokenText;

  let text = 'Ready';
  if (s.running && s.paused) {
    text = 'Paused';
  } else if (s.running) {
    const loopLabel = runUnlimited
      ? 'Loop ' + s.current_loop + ' / \u221e'
      : 'Loop ' + s.current_loop + ' / ' + runMaxLoops;
    const runningFor = s.current_step_started_at_epoch_ms
      ? Math.max(0, Math.floor((Date.now() - s.current_step_started_at_epoch_ms) / 1000))
      : 0;
    text = '[' + _spinnerFrame() + '] ' + loopLabel + ' \u2022 Step ' + (s.current_step + 1) + '/' + totalSteps;
    if (s.current_step_name) text += ' \u2022 ' + esc(s.current_step_name);
    if (stopAfterCurrentStep) text += ' \u2022 stopping after this step';
    if (runningFor > 0) text += ' \u2022 running ' + _formatElapsedSeconds(runningFor);
    if (!runUnlimited) text += ' \u2022 ' + pct + '%';
  } else if (s.stop_reason) {
    const label = stopGuidance && stopGuidance.label ? stopGuidance.label : s.stop_reason;
    text = 'Finished: ' + label + ' (' + (s.total_loops_completed || 0) + ' loops)';
  }
  document.getElementById('progress-text').textContent = text;
  renderStopGuidance('chain-stop-guidance', stopGuidance, s.running);
}

function _formatChangedLineCount(value, cls, sign) {
  const n = Number(value);
  if (!Number.isFinite(n)) {
    return '<span class="file-changes-binary">bin</span>';
  }
  return '<span class="' + cls + '">' + sign + n + '</span>';
}

function renderChangedFilesCell(changedFiles, filesChanged) {
  const files = Array.isArray(changedFiles) ? changedFiles : [];
  const total = Number(filesChanged || 0);
  if (!files.length) {
    if (total <= 0) {
      return '<span class="file-changes-empty">0</span>';
    }
    const label = total + ' file' + (total === 1 ? '' : 's');
    return '<span class="file-changes-empty" title="File details unavailable for this result">' + label + '</span>';
  }

  const labelCount = files.length;
  const summary = labelCount + ' file' + (labelCount === 1 ? '' : 's');
  const rows = files.map(f => {
    const path = esc(String((f && f.path) || '(unknown)'));
    return '<div class="file-changes-row">'
      + '<span class="file-changes-path" title="' + path + '">' + path + '</span>'
      + _formatChangedLineCount(f && f.insertions, 'file-changes-plus', '+')
      + _formatChangedLineCount(f && f.deletions, 'file-changes-minus', '-')
      + '</div>';
  }).join('');

  return '<details class="file-changes-details">'
    + '<summary class="file-changes-summary">' + summary + '</summary>'
    + '<div class="file-changes-list">' + rows + '</div>'
    + '</details>';
}

function _captureOpenChangedFileRows(tbodyId) {
  const tbody = document.getElementById(tbodyId);
  const openKeys = new Set();
  if (!tbody) return openKeys;
  tbody.querySelectorAll('details.file-changes-details[open]').forEach((details) => {
    const tr = details.closest('tr[data-change-key]');
    if (!tr || !tr.dataset) return;
    const key = tr.dataset.changeKey || '';
    if (key) openKeys.add(key);
  });
  return openKeys;
}

function _restoreOpenChangedFileRows(tbodyId, openKeys) {
  if (!openKeys || !openKeys.size) return;
  const tbody = document.getElementById(tbodyId);
  if (!tbody) return;
  tbody.querySelectorAll('details.file-changes-details').forEach((details) => {
    const tr = details.closest('tr[data-change-key]');
    if (!tr || !tr.dataset) return;
    const key = tr.dataset.changeKey || '';
    if (key && openKeys.has(key)) details.open = true;
  });
}

function _parseResultCount(value, fallback) {
  const n = Number(value);
  if (!Number.isFinite(n) || n < 0) return fallback;
  return Math.floor(n);
}

function _consumeResultsPayload(payload, cache, knownCount) {
  if (Array.isArray(payload.results)) {
    const full = payload.results;
    const total = _parseResultCount(payload.total_results, full.length);
    return { results: full, total: Math.max(full.length, total) };
  }

  if (!Array.isArray(payload.results_delta)) {
    return { results: cache, total: knownCount };
  }

  const delta = payload.results_delta;
  const total = _parseResultCount(payload.total_results, knownCount + delta.length);
  let next = cache;

  if (total === 0) {
    next = [];
  } else if (total < next.length) {
    next = next.slice(0, total);
  }

  if (delta.length) next = next.concat(delta);
  if (total < next.length) next = next.slice(0, total);

  return { results: next, total: Math.max(total, next.length) };
}

function _resultsSignature(results) {
  const len = Array.isArray(results) ? results.length : 0;
  if (!len) return '0';
  const last = results[len - 1] || {};
  const changedFiles = Array.isArray(last.changed_files) ? last.changed_files.length : 0;
  return [
    len,
    last.loop_number || 0,
    last.step_index || 0,
    last.cycle || 0,
    String(last.phase || ''),
    String(last.step_name || ''),
    String(last.test_outcome || ''),
    Number(last.files_changed || 0),
    Number(last.net_lines_changed || 0),
    Number(last.duration_seconds || 0),
    changedFiles,
  ].join('|');
}

function updateResults(results) {
  const signature = _resultsSignature(results);
  if (signature === _chainResultsRenderSignature) return;
  _chainResultsRenderSignature = signature;

  const tbody = document.getElementById('results-body');
  const openKeys = _captureOpenChangedFileRows('results-body');
  if (!results.length) {
    tbody.innerHTML = '<tr><td colspan="9"><div class="state-card">No execution results yet. Run a chain to populate this table.</div></td></tr>';
    return;
  }
  tbody.innerHTML = results.map((r, idx) => {
    const badge = r.test_outcome === 'passed' ? 'badge-pass'
                : r.test_outcome === 'failed' ? 'badge-fail'
                : r.test_outcome === 'skipped' ? 'badge-skip' : 'badge-error';
    const agentBadge = (r.agent_used || 'codex').includes('Claude') ? '\ud83d\udfe3' : '\ud83d\udfe2';
    const rowKey = 'chain:' + idx + ':' + (r.loop_number || 0) + ':' + (r.step_index || 0);
    return '<tr data-change-key="' + esc(rowKey) + '">'
      + '<td>' + r.loop_number + '</td>'
      + '<td>' + esc(r.step_name) + '</td>'
      + '<td style="font-size:12px">' + agentBadge + ' ' + esc(r.agent_used || 'Codex') + '</td>'
      + '<td><span class="badge ' + badge + '">' + r.test_outcome + '</span></td>'
      + '<td>' + r.files_changed + '</td>'
      + '<td class="file-changes-cell">' + renderChangedFilesCell(r.changed_files, r.files_changed) + '</td>'
      + '<td>' + (r.net_lines_changed >= 0 ? '+' : '') + r.net_lines_changed + '</td>'
      + '<td>' + r.duration_seconds + 's</td>'
      + '<td style="font-family:var(--mono);font-size:12px">' + (r.commit_sha || '\u2014') + '</td>'
    + '</tr>';
  }).join('');
  _restoreOpenChangedFileRows('results-body', openKeys);
}

function setLogContentState(el, text, state) {
  if (!el) return;
  const isLoading = state === 'loading';
  el.classList.toggle('is-loading', isLoading);
  el.setAttribute('aria-busy', isLoading ? 'true' : 'false');
  el.textContent = text;
}

async function refreshChainOutputs(keepSelection = true) {
  const sel = document.getElementById('chain-output-select');
  const content = document.getElementById('chain-output-content');
  const dirEl = document.getElementById('chain-output-dir');
  const prev = keepSelection ? (sel.value || '') : '';
  setLogContentState(content, 'Loading output files...', 'loading');

  if (!config.repo_path) {
    chainOutputFiles = [];
    sel.innerHTML = '<option value="">No output files yet</option>';
    setLogContentState(content, 'Set a repository path and run a chain to generate outputs.');
    dirEl.textContent = '';
    return;
  }

  try {
    const q = '/api/chain/outputs?repo_path=' + encodeURIComponent(config.repo_path);
    const data = await api(q);
    chainOutputFiles = Array.isArray(data.files) ? data.files : [];

    if (!chainOutputFiles.length) {
      sel.innerHTML = '<option value="">No output files yet</option>';
      setLogContentState(content, 'No step output files were found for this repository yet.');
      dirEl.textContent = data.output_dir ? ('Directory: ' + data.output_dir) : '';
      return;
    }

    sel.innerHTML = '<option value="">Select an output file...</option>' + chainOutputFiles.map(f => {
      const kb = Math.max(1, Math.round((f.size_bytes || 0) / 1024));
      return '<option value="' + esc(f.name) + '">' + esc(f.name) + ' (' + kb + ' KB)</option>';
    }).join('');

    dirEl.textContent = data.output_dir ? ('Directory: ' + data.output_dir) : '';
    const next = chainOutputFiles.find(f => f.name === prev) ? prev : chainOutputFiles[chainOutputFiles.length - 1].name;
    if (next) {
      sel.value = next;
      await viewChainOutput(next);
    }
  } catch (e) {
    setLogContentState(content, 'Could not load step outputs.');
  }
}

async function viewChainOutput(name) {
  const sel = document.getElementById('chain-output-select');
  const content = document.getElementById('chain-output-content');
  const filename = name || sel.value;
  if (!filename) {
    setLogContentState(content, 'Select an output file to view its contents.');
    return;
  }
  setLogContentState(content, 'Loading output file...', 'loading');
  try {
    const url = '/api/chain/outputs/' + encodeURIComponent(filename)
      + '?repo_path=' + encodeURIComponent(config.repo_path || '');
    const data = await api(url);
    if (data.error) {
      setLogContentState(content, data.error);
      return;
    }
    setLogContentState(content, data.content || '(empty file)');
  } catch (e) {
    setLogContentState(content, 'Could not read output file.');
  }
}

/* -- Config Save / Load ----------------------------------------- */
function renderOwnerIdeas(payload) {
  const area = document.getElementById('owner-board-content');
  const warningEl = document.getElementById('owner-board-warning');
  if (!area || !warningEl) return;

  const content = String(payload && payload.content || '').trim();
  const warning = String(payload && payload.warning || '').trim();
  const scan = payload && typeof payload.scan === 'object' && payload.scan !== null
    ? payload.scan
    : null;
  const details = [];
  if (warning) details.push(warning);
  if (scan) {
    const included = Number(scan.included_files || 0);
    const excluded = Number(scan.excluded_files || 0);
    const snippets = Number(scan.snippet_files || 0);
    const truncated = !!scan.scan_truncated;
    details.push(
      'Repo scan: '
      + included + ' included, '
      + excluded + ' excluded, '
      + snippets + ' snippet file(s)'
      + (truncated ? ', truncated for performance.' : '.')
    );
  }
  warningEl.textContent = details.join('\n');

  if (!content) {
    setLogContentState(area, 'No ideas yet. Generate ideas from the repository.');
    return;
  }
  setLogContentState(area, content);
}

async function loadOwnerIdeas() {
  const repoPath = (document.getElementById('repo-path').value || '').trim();
  const area = document.getElementById('owner-board-content');
  const warningEl = document.getElementById('owner-board-warning');
  if (!repoPath) {
    if (area) setLogContentState(area, 'Set Repository Path in Chain Builder first.');
    if (warningEl) warningEl.textContent = '';
    return;
  }
  if (area) setLogContentState(area, 'Loading repository ideas...', 'loading');
  try {
    const resp = await api('/api/owner/repo-ideas?repo_path=' + encodeURIComponent(repoPath));
    if (resp.error) {
      if (area) setLogContentState(area, resp.error);
      return;
    }
    renderOwnerIdeas(resp);
  } catch (e) {
    if (area) setLogContentState(area, 'Could not load repository ideas.');
  }
}

async function generateOwnerIdeasFromRepo() {
  const repoPath = (document.getElementById('repo-path').value || '').trim();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    return;
  }
  const model = String(document.getElementById('owner-ideas-model').value || 'gpt-5.2').trim() || 'gpt-5.2';
  const ownerContext = String(document.getElementById('owner-ideas-context').value || '').trim();
  const area = document.getElementById('owner-board-content');
  if (area) setLogContentState(area, 'Generating repository ideas...', 'loading');
  const payload = await postJson('/api/owner/repo-ideas/generate', {
    repo_path: repoPath,
    model: model,
    owner_context: ownerContext,
    existing_markdown: '',
  });
  if (payload.error) {
    toast(payload.error, 'error');
    return;
  }
  renderOwnerIdeas(payload);
  toast('Repository ideas generated.', 'success');
}

async function loadConfigList() {
  try {
    const configs = await api('/api/configs');
    const sel = document.getElementById('config-select');
    if (!Array.isArray(configs)) {
      sel.innerHTML = '<option value="">Load config...</option><option value="" disabled>Could not read config list</option>';
      toast('Could not load config list from /api/configs', 'error');
      return;
    }
    const options = configs.map(c => '<option value="' + esc(c.name) + '">' + esc(c.name) + '</option>').join('');
    if (!options) {
      sel.innerHTML = '<option value="">Load config...</option><option value="" disabled>No saved configs found</option>';
      return;
    }
    sel.innerHTML = '<option value="">Load config...</option>' + options;
    sel.onchange = async function() {
      if (!this.value) return;
      const data = await postJson('/api/configs/load', {name: this.value});
      if (data.error) { toast(data.error, 'error'); return; }
      applyConfig(data);
      toast('Loaded: ' + this.value, 'info');
      this.value = '';
    };
  } catch(e) {
    const sel = document.getElementById('config-select');
    if (sel) {
      sel.innerHTML = '<option value="">Load config...</option><option value="" disabled>Config list unavailable</option>';
    }
    toast('Config list unavailable. Check Brave Shields / network settings and try Refresh.', 'error');
  }
}

function applyConfig(data) {
  Object.assign(config, data);
  if (!Object.prototype.hasOwnProperty.call(data || {}, 'codex_reasoning_effort')) {
    config.codex_reasoning_effort = 'xhigh';
  }
  if (!Array.isArray(config.steps)) config.steps = [];
  resetPermissionProfileUiState('chain');
  normalizeCodexPermissions(config);
  normalizeCapabilitySettings(config);
  document.getElementById('repo-path').value = config.repo_path || '';
  document.getElementById('unlimited').checked = !!config.unlimited;
  document.getElementById('threshold-slider').value = config.improvement_threshold || 1.0;
  document.getElementById('threshold-val').textContent = (config.improvement_threshold || 1.0) + '%';
  document.getElementById('max-loops').value = config.max_loops || 3;
  document.getElementById('max-time').value = config.max_time_minutes || 120;
  document.getElementById('max-tokens').value = config.max_total_tokens || 2000000;
  document.getElementById('strict-token-budget').checked = !!config.strict_token_budget;
  document.getElementById('stop-convergence').checked = config.stop_on_convergence !== false;
  document.getElementById('test-cmd').value = config.test_cmd || '';
  document.getElementById('codex-bin').value = config.codex_binary || 'codex';
  syncChainPermissionControlsFromConfig();
  syncChainCapabilityControlsFromConfig();
  document.getElementById('claude-bin').value = config.claude_binary || 'claude';
  config.timeout_per_step = _normalizedTimeoutSeconds(config.timeout_per_step, 600);
  syncChainTimeoutControlsFromConfig();
  document.getElementById('parallel-exec').checked = !!config.parallel_execution;
  document.getElementById('brain-enabled').checked = !!config.brain_enabled;
  document.getElementById('brain-model').value = config.brain_model || 'gpt-5.2';
  document.getElementById('local-only').checked = !!config.local_only;
  document.getElementById('chain-git-preflight-enabled').checked = !!config.git_preflight_enabled;
  document.getElementById('chain-git-preflight-auto-stash').checked = !!config.git_preflight_auto_stash;
  document.getElementById('chain-git-preflight-auto-pull').checked = !!config.git_preflight_auto_pull;
  setMode(config.mode || 'dry-run');
  toggleChainGitPreflight();
  toggleUnlimited();
  toggleBrain();
  toggleLocalOnly();
  selectedStepId = config.steps.length ? config.steps[0].id : null;
  renderSteps();
  renderStepDetails();
  validateRepo();
  refreshChainOutputs(false);
  loadOwnerIdeas();
}

async function saveConfig() {
  const name = prompt('Config name:', config.name || 'My Chain');
  if (!name) return;
  config.name = name;
  // Sync from UI
  config.repo_path             = document.getElementById('repo-path').value.trim();
  config.unlimited             = document.getElementById('unlimited').checked;
  config.improvement_threshold = parseFloat(document.getElementById('threshold-slider').value) || 1.0;
  config.max_loops             = parseInt(document.getElementById('max-loops').value) || 3;
  config.max_time_minutes      = parseInt(document.getElementById('max-time').value) || 120;
  config.max_total_tokens      = parseInt(document.getElementById('max-tokens').value) || 2000000;
  config.strict_token_budget   = document.getElementById('strict-token-budget').checked;
  config.stop_on_convergence   = document.getElementById('stop-convergence').checked;
  config.test_cmd              = document.getElementById('test-cmd').value.trim();
  config.codex_binary          = document.getElementById('codex-bin').value.trim();
  config.codex_reasoning_effort = document.getElementById('codex-reasoning-effort').value;
  config.codex_sandbox_mode    = document.getElementById('codex-sandbox-mode').value;
  config.codex_approval_policy = document.getElementById('codex-approval-policy').value;
  config.codex_bypass_approvals_and_sandbox = document.getElementById('codex-bypass-approvals').checked;
  config.claude_binary         = document.getElementById('claude-bin').value.trim();
  config.timeout_per_step      = readChainTimeoutFromUi();
  config.parallel_execution    = document.getElementById('parallel-exec').checked;
  config.brain_enabled         = document.getElementById('brain-enabled').checked;
  config.brain_model           = document.getElementById('brain-model').value;
  config.local_only            = document.getElementById('local-only').checked;
  config.allow_path_creation   = document.getElementById('chain-allow-path-creation').checked;
  config.dependency_install_policy = document.getElementById('chain-dependency-install-policy').value;
  config.image_generation_enabled = document.getElementById('chain-image-generation-enabled').checked;
  config.image_provider        = document.getElementById('chain-image-provider').value;
  config.image_model           = document.getElementById('chain-image-model').value.trim();
  config.vector_memory_enabled = document.getElementById('chain-vector-memory-enabled').checked;
  config.vector_memory_backend = document.getElementById('chain-vector-memory-backend').value;
  config.vector_memory_collection = document.getElementById('chain-vector-memory-collection').value.trim();
  config.vector_memory_top_k = parseInt(document.getElementById('chain-vector-memory-top-k').value, 10) || 8;
  config.git_preflight_enabled = document.getElementById('chain-git-preflight-enabled').checked;
  config.git_preflight_auto_stash = document.getElementById('chain-git-preflight-auto-stash').checked;
  config.git_preflight_auto_pull = document.getElementById('chain-git-preflight-auto-pull').checked;
  if (!config.git_preflight_enabled) {
    config.git_preflight_auto_stash = false;
    config.git_preflight_auto_pull = false;
  }
  toggleChainGitPreflight();
  normalizeCodexPermissions(config);
  normalizeCapabilitySettings(config);
  syncChainPermissionControlsFromConfig();
  syncChainCapabilityControlsFromConfig();
  syncChainTimeoutControlsFromConfig();

  const r = await postJson('/api/configs/save', {name, config});
  if (r.error) { toast(r.error, 'error'); return; }
  toast('Saved: ' + name, 'success');
  loadConfigList();
}

/* -- Utilities -------------------------------------------------- */
function resetExecutionPanelsToDefaults() {
  chainLogEntries = [];
  pipeLogEntries = [];
  chainResultsCache = [];
  pipeResultsCache = [];
  chainResultsCount = 0;
  pipeResultsCount = 0;
  _chainResultsRenderSignature = '';
  _pipeResultsRenderSignature = '';
  chainLastActivityMs = 0;
  pipeLastActivityMs = 0;
  chainRunning = false;
  chainPaused = false;
  pipeRunning = false;
  pipePaused = false;
  chainOutputFiles = [];
  _lastOutputRefreshStepCount = -1;
  pendingServerRestart = null;
  selfRestartNoticeCheckpoint = '';

  setControlsRunning(false);
  setPipeControlsRunning(false);
  document.getElementById('btn-pause').innerHTML = '&#9208; Pause';
  document.getElementById('pipe-btn-pause').innerHTML = '&#9208; Pause';

  document.getElementById('progress-text').textContent = 'Ready';
  document.getElementById('progress-tokens').textContent = '0 tokens';
  document.getElementById('progress-fill').style.width = '0%';
  document.getElementById('progress-fill').classList.remove('running');
  document.getElementById('progress-last-log').textContent = 'Last log: none yet';
  renderStopGuidance('chain-stop-guidance', null, false);
  document.getElementById('log-viewer').innerHTML = '<div class="log-empty state-card">Waiting to start...</div>';
  document.getElementById('results-body').innerHTML = '<tr><td colspan="9"><div class="state-card">No execution results yet. Run a chain to populate this table.</div></td></tr>';
  document.getElementById('show-debug-logs').checked = false;

  document.getElementById('pipe-progress-text').textContent = 'Ready';
  document.getElementById('pipe-progress-tokens').textContent = '0 tokens';
  document.getElementById('pipe-progress-fill').style.width = '0%';
  document.getElementById('pipe-progress-fill').classList.remove('running');
  document.getElementById('pipe-progress-last-log').textContent = 'Last log: none yet';
  renderStopGuidance('pipe-stop-guidance', null, false);
  document.getElementById('pipe-log-viewer').innerHTML = '<div class="log-empty state-card">Configure phases and click Start Pipeline...</div>';
  document.getElementById('pipe-results-body').innerHTML = '<tr><td colspan="8"><div class="state-card">No pipeline results yet. Start a pipeline run to populate this table.</div></td></tr>';
  document.getElementById('pipe-run-compare-summary').textContent = 'Compare recent finished runs to identify the most effective configuration.';
  document.getElementById('pipe-run-compare-body').innerHTML = '<tr><td colspan="10"><div class="state-card">Set Repository Path to load recent run comparisons.</div></td></tr>';
  document.getElementById('pipe-show-debug-logs').checked = false;

  setLogContentState(document.getElementById('log-file-content'), 'Select a log file above to view its contents.');
  document.querySelectorAll('#log-file-tabs button').forEach((btn, idx) => {
    btn.classList.toggle('active', idx === 0);
  });

  const cuaStatus = document.getElementById('pipe-cua-status');
  cuaStatus.textContent = '';
  cuaStatus.style.color = 'var(--text2)';

  renderActivityHeartbeats();
  setBackendOnlineState(true);
}

function resetNewProjectForm() {
  document.getElementById('np-parent').value = '';
  document.getElementById('np-name').value = '';
  document.getElementById('np-desc').value = '';
  document.getElementById('np-git-name').value = '';
  document.getElementById('np-git-email').value = '';
  document.getElementById('np-readme').checked = true;
  document.getElementById('np-gitignore').checked = true;
  document.getElementById('np-branch').value = 'main';
  document.getElementById('np-remote').value = '';
  document.getElementById('np-foundation-enabled').checked = false;
  document.getElementById('np-foundation-prompt').value = '';
  document.getElementById('np-foundation-generate-docs').checked = true;
  document.getElementById('np-foundation-bootstrap-once').checked = true;
  document.getElementById('np-foundation-bootstrap-autorun').checked = true;
  document.getElementById('np-licensing-enabled').checked = false;
  document.getElementById('np-licensing-strategy').value = 'oss_only';
  document.getElementById('np-licensing-commercial').checked = true;
  document.getElementById('np-licensing-email').value = '';
  document.getElementById('np-licensing-legal-review-required').checked = true;
  document.getElementById('np-licensing-legal-signoff').checked = false;
  document.getElementById('np-licensing-legal-reviewer').value = '';
  document.getElementById('np-licensing-legal-notes').value = '';
  document.querySelectorAll('.np-foundation-assistant').forEach((el) => {
    el.checked = el.value === 'codex';
  });
  _setFoundationStatus(
    'Choose assistants and click "Improve..." to refine prompt structure.',
    'muted',
  );
  toggleFoundationOptions();
  toggleLicensingOptions();
  toggleLicensingLegalSignoff();
  document.getElementById('np-result').style.display = 'none';
  document.getElementById('np-create-btn').disabled = false;
  document.querySelectorAll('#new-project-overlay details').forEach(el => { el.open = false; });
  hideNewProjectModal();
}

function resetCloneRepoForm() {
  document.getElementById('clone-remote-url').value = '';
  document.getElementById('clone-destination-dir').value = '';
  document.getElementById('clone-project-name').value = '';
  _populateCloneBranchOptions([], '');
  _setCloneBranchHelp('Load branch names from the remote (optional).', 'muted');
  _setCloneRepoStatus('', 'muted');
  const cloneBtn = document.getElementById('clone-repo-btn');
  if (cloneBtn) cloneBtn.disabled = false;
  hideCloneRepoModal();
}

function resetGitRemoteForm() {
  const nameInput = document.getElementById('git-remote-name-input');
  const urlInput = document.getElementById('git-remote-url-input');
  const defaultCheckbox = document.getElementById('git-remote-add-default-check');
  if (nameInput) nameInput.value = '';
  if (urlInput) urlInput.value = '';
  if (defaultCheckbox) defaultCheckbox.checked = false;
  _setGitRemoteAddHelp('Use HTTPS or SSH URL formats only.', 'muted');
  _clearGitRemoteView('No repository selected.');
  hideGitRemoteModal();
}

function resetGitSigningForm() {
  const modeEl = document.getElementById('git-signing-mode');
  const keyEl = document.getElementById('git-signing-key');
  const clearKeyEl = document.getElementById('git-signing-clear-key');
  const commitEl = document.getElementById('git-signing-commit-sign');
  const tagEl = document.getElementById('git-signing-tag-sign');
  const guardEl = document.getElementById('git-signing-require-push-guard');
  if (modeEl) modeEl.value = 'gpg';
  if (keyEl) keyEl.value = '';
  if (clearKeyEl) clearKeyEl.checked = false;
  if (commitEl) commitEl.checked = false;
  if (tagEl) tagEl.checked = false;
  if (guardEl) guardEl.checked = false;
  _clearGitSigningView('No repository selected.');
  hideGitSigningModal();
}

function resetTodoWishlistForm() {
  const repo = _activeRepoPath();
  document.getElementById('todo-wishlist-repo').value = repo;
  document.getElementById('todo-wishlist-content').value = '';
  document.getElementById('todo-wishlist-context').value = '';
  document.getElementById('todo-wishlist-model').value = 'gpt-5.2';
  const filesEl = document.getElementById('todo-wishlist-context-files');
  if (filesEl) filesEl.value = '';
  todoWishlistContextFiles = [];
  _renderTodoWishlistContextFilesList();
  lastTodoWishlistSuggestion = '';
  _setTodoWishlistStatus('', 'muted');
  hideTodoWishlistModal();
}

function resetFeatureDreamsForm() {
  const repo = _activeRepoPath();
  document.getElementById('feature-dreams-repo').value = repo;
  document.getElementById('feature-dreams-content').value = '';
  document.getElementById('feature-dreams-context').value = '';
  document.getElementById('feature-dreams-model').value = 'gpt-5.2';
  lastFeatureDreamsSuggestion = '';
  _setFeatureDreamsStatus('', 'muted');
  hideFeatureDreamsModal();
}

function resetGeneralRequestForm() {
  const repo = _activeRepoPath();
  const repoEl = document.getElementById('general-request-repo');
  if (repoEl) repoEl.value = repo;
  const contentEl = document.getElementById('general-request-content');
  if (contentEl) contentEl.value = '';
  const contextEl = document.getElementById('general-request-context');
  if (contextEl) contextEl.value = '';
  const modelEl = document.getElementById('general-request-model');
  if (modelEl) modelEl.value = 'gpt-5.2';
  const outEl = document.getElementById('general-request-output');
  if (outEl) outEl.value = '';
  pendingGeneralRequestRun = null;
  _setGeneralRequestStatus('', 'muted');
  _renderGeneralRequestHistory([]);
  hideGeneralRequestModal();
}

async function clearEverything() {
  const running = chainRunning || chainPaused || pipeRunning || pipePaused;
  const proceed = confirm(
    running
      ? 'A chain or pipeline is currently running. Stop it and reset all settings/UI to startup defaults? Saved configurations will be preserved.'
      : 'Reset all settings and UI state to startup defaults? Saved configurations will be preserved.'
  );
  if (!proceed) return;

  if (running) {
    try { await postJson('/api/chain/stop'); } catch(e) {}
    try { await postJson('/api/pipeline/stop'); } catch(e) {}
  }

  stopPolling();
  disconnectSSE();
  if (pipelinePollTimer) { clearInterval(pipelinePollTimer); pipelinePollTimer = null; }
  if (pipelineSSE) { pipelineSSE.close(); pipelineSSE = null; }

  Object.assign(config, cloneState(DEFAULT_CHAIN_CONFIG));
  Object.assign(pipeConfig, cloneState(DEFAULT_PIPE_CONFIG));
  selectedStepId = null;
  if (typeof _phasePromptOverrides !== 'undefined') {
    Object.keys(_phasePromptOverrides).forEach(key => { delete _phasePromptOverrides[key]; });
  }

  if (typeof localStorage !== 'undefined') {
    // Only reset known UI/session flags. Preserve any saved config keys.
    localStorage.removeItem('cm_mode');
    localStorage.removeItem('cm_onboarded');
  }

  currentMode = 'easy';
  document.querySelectorAll('.recipe-card').forEach(card => {
    card.classList.remove('selected');
    card.setAttribute('aria-pressed', 'false');
  });
  document.querySelectorAll('#chain-panel details, #pipeline-config details').forEach(el => { el.open = false; });

  applyConfig(cloneState(DEFAULT_CHAIN_CONFIG));
  applyPipeConfigToUi();
  applyMode('easy');

  resetExecutionPanelsToDefaults();
  resetNewProjectForm();
  resetCloneRepoForm();
  resetGitRemoteForm();
  resetGitSigningForm();
  resetTodoWishlistForm();
  resetFeatureDreamsForm();
  resetGeneralRequestForm();
  closeRunPlanModal({ action: 'cancel' });
  closePermissionsHelpModal();
  closeReadOnlyWarningModal('cancel');
  closeDocsModal();
  browseClose();
  switchTab('chain');
  loadConfigList();
  renderPipelinePhases();

  _openOverlay('onboarding-overlay', '.onboarding-card .btn-primary');
  toast('Reset complete: settings restored. Saved configurations were not deleted.', 'success');
}

function esc(s) {
  if (!s) return '';
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

function escAttr(s) {
  return esc(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function renderStopGuidance(elementId, guidance, running) {
  const el = document.getElementById(elementId);
  if (!el) return;

  if (running || !guidance || !guidance.label) {
    el.className = 'stop-guidance hidden';
    el.innerHTML = '';
    return;
  }

  const severity = ['info', 'warn', 'error'].includes(guidance.severity)
    ? guidance.severity
    : 'info';
  const summary = guidance.summary
    ? '<div class="stop-guidance-summary">' + esc(guidance.summary) + '</div>'
    : '';
  const steps = Array.isArray(guidance.next_steps) ? guidance.next_steps : [];
  const stepsHtml = steps.length
    ? '<ol class="stop-guidance-steps">' + steps.map(step => '<li>' + esc(step) + '</li>').join('') + '</ol>'
    : '';

  el.className = 'stop-guidance stop-guidance-' + severity;
  el.innerHTML = ''
    + '<div class="stop-guidance-title">Why it stopped: ' + esc(guidance.label) + '</div>'
    + summary
    + stepsHtml;
}

function _ensureToastStack() {
  let stack = document.getElementById('toast-stack');
  if (!stack) {
    stack = document.createElement('div');
    stack.id = 'toast-stack';
    stack.setAttribute('aria-live', 'polite');
    stack.setAttribute('aria-atomic', 'false');
    document.body.appendChild(stack);
  }
  return stack;
}

function toast(msg, type) {
  const stack = _ensureToastStack();
  const el = document.createElement('div');
  const tone = ['success', 'error', 'info'].includes(type) ? type : 'info';
  el.className = 'toast toast-' + tone;
  el.setAttribute('role', tone === 'error' ? 'alert' : 'status');
  el.setAttribute('aria-live', tone === 'error' ? 'assertive' : 'polite');
  const body = document.createElement('div');
  body.className = 'toast-body';
  body.textContent = msg;
  const closeBtn = document.createElement('button');
  closeBtn.type = 'button';
  closeBtn.className = 'toast-close';
  closeBtn.setAttribute('aria-label', 'Dismiss notification');
  closeBtn.textContent = '';
  el.appendChild(body);
  el.appendChild(closeBtn);
  const announcer = document.getElementById('sr-announcer');
  if (announcer) {
    announcer.textContent = '';
    setTimeout(() => { announcer.textContent = msg; }, 10);
  }
  stack.appendChild(el);
  const timeoutMs = tone === 'error' ? 7000 : 3600;
  let closed = false;
  const dismiss = () => {
    if (closed) return;
    closed = true;
    el.classList.add('toast-exit');
    setTimeout(() => {
      el.remove();
      if (stack.childElementCount === 0) stack.remove();
    }, 220);
  };
  closeBtn.addEventListener('click', dismiss);
  setTimeout(dismiss, timeoutMs);
}

/*  */
/* TAB SWITCHING                                                    */
/*  */

function switchTab(tabId) {
  document.querySelectorAll('#main-tabs button').forEach(b => {
    const active = b.dataset.tab === tabId;
    b.classList.toggle('active', active);
    b.setAttribute('aria-selected', active ? 'true' : 'false');
    b.setAttribute('tabindex', active ? '0' : '-1');
  });
  document.querySelectorAll('.tab-content').forEach(el => {
    const active = el.id === tabId + '-view';
    el.classList.toggle('active', active);
    el.hidden = !active;
  });
  if (tabId === 'pipeline' && !pipelinePhases.length) {
    loadPipelinePhases();
  }
  if (tabId === 'pipeline') {
    const repoPath = String(document.getElementById('pipe-repo-path').value || '').trim();
    if (repoPath) {
      schedulePipelineResumeRefresh(repoPath, { delayMs: 0, silent: true });
      refreshPipelineRunComparison({ repoPath, silent: true });
    } else {
      pipelineResumeState = null;
      renderPipelineResumeCard();
      refreshPipelineRunComparison({ repoPath: '', silent: true });
    }
  }
  scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
}

/*  */
/* PIPELINE                                                         */
/*  */

const PHASE_ICONS = {
  ideation: '\uD83D\uDCA1',
  prioritization: '\uD83D\uDCCA',
  implementation: '\uD83D\uDD28',
  testing: '\uD83E\uDDEA',
  debugging: '\uD83D\uDC1B',
  commit: '\uD83D\uDCBE',
  deep_research: '\uD83D\uDD0D',
  apply_upgrades_and_restart: '\uD83D\uDD04',
  progress_review: '\uD83D\uDCCB',
  visual_test: '\uD83D\uDC41\uFE0F',
  theorize: '\uD83E\uDD14',
  experiment: '\u2697\uFE0F',
  skeptic: '\uD83E\uDDEA',
  analyze: '\uD83D\uDD2C',
};

let pipelinePhases = [];
let pipelineSSE = null;
let pipelinePollTimer = null;
let pipelineResumeRefreshTimer = null;
let pipelineResumeState = null;

const pipeConfig = {
  repo_path: '',
  mode: 'dry-run',
  max_cycles: 3,
  unlimited: false,
  improvement_threshold: 1.0,
  agent: 'codex',
  science_enabled: false,
  cua_enabled: false,
  cua_provider: 'openai',
  cua_target_url: '',
  cua_task: '',
  brain_enabled: false,
  brain_model: 'gpt-5.2',
  phases: [],
  // Stop conditions (consistent with chain builder)
  max_time_minutes: 240,
  max_total_tokens: 5000000,
  strict_token_budget: false,
  stop_on_convergence: true,
  // Advanced settings (consistent with chain builder)
  smoke_test_cmd: '',
  test_cmd: '',
  codex_binary: 'codex',
  codex_reasoning_effort: 'xhigh',
  claude_binary: 'claude',
  codex_sandbox_mode: 'workspace-write',
  codex_approval_policy: 'never',
  codex_bypass_approvals_and_sandbox: false,
  codex_danger_confirmation: '',
  allow_path_creation: true,
  dependency_install_policy: 'project_only',
  image_generation_enabled: false,
  image_provider: 'openai',
  image_model: 'gpt-image-1',
  vector_memory_enabled: false,
  vector_memory_backend: 'chroma',
  vector_memory_collection: '',
  vector_memory_top_k: 8,
  deep_research_enabled: false,
  deep_research_providers: 'both',
  deep_research_max_age_hours: 168,
  deep_research_dedupe: true,
  deep_research_native_enabled: false,
  deep_research_retry_attempts: 2,
  deep_research_daily_quota: 8,
  deep_research_max_provider_tokens: 12000,
  deep_research_budget_usd: 5.0,
  deep_research_openai_model: 'gpt-5.2',
  deep_research_google_model: 'gemini-3-pro-preview',
  self_improvement_enabled: false,
  self_improvement_auto_restart: false,
  git_preflight_enabled: false,
  git_preflight_auto_stash: false,
  git_preflight_auto_pull: false,
  pr_aware_enabled: false,
  pr_feature_branch: '',
  pr_remote: '',
  pr_base_branch: '',
  pr_auto_push: true,
  pr_sync_description: true,
  timeout_per_phase: 0,
  // Git settings
  auto_commit: true,
  commit_frequency: 'per_phase',
  // Local-only mode
  local_only: false,
};
const DEFAULT_PIPE_CONFIG = cloneState(pipeConfig);

function applyPipeConfigToUi() {
  if (!Array.isArray(pipeConfig.phases)) pipeConfig.phases = [];
  resetPermissionProfileUiState('pipeline');
  normalizeCodexPermissions(pipeConfig);
  normalizeCapabilitySettings(pipeConfig);

  document.getElementById('pipe-repo-path').value = pipeConfig.repo_path || '';
  document.getElementById('pipe-unlimited').checked = !!pipeConfig.unlimited;
  document.getElementById('pipe-threshold-slider').value = pipeConfig.improvement_threshold || 1.0;
  document.getElementById('pipe-threshold-val').textContent = (pipeConfig.improvement_threshold || 1.0) + '%';
  document.getElementById('pipe-cycles').value = pipeConfig.max_cycles || 3;
  document.getElementById('pipe-max-time').value = pipeConfig.max_time_minutes || 240;
  document.getElementById('pipe-max-tokens').value = pipeConfig.max_total_tokens || 5000000;
  document.getElementById('pipe-strict-token-budget').checked = !!pipeConfig.strict_token_budget;
  document.getElementById('pipe-stop-convergence').checked = pipeConfig.stop_on_convergence !== false;
  document.getElementById('pipe-agent').value = pipeConfig.agent || 'codex';
  document.getElementById('pipe-science').checked = !!pipeConfig.science_enabled;
  document.getElementById('pipe-cua').checked = !!pipeConfig.cua_enabled;
  document.getElementById('pipe-cua-provider').value = pipeConfig.cua_provider || 'openai';
  document.getElementById('pipe-cua-url').value = pipeConfig.cua_target_url || '';
  document.getElementById('pipe-cua-task').value = pipeConfig.cua_task || '';
  const cuaStatus = document.getElementById('pipe-cua-status');
  cuaStatus.textContent = '';
  cuaStatus.style.color = 'var(--text2)';
  document.getElementById('pipe-brain').checked = !!pipeConfig.brain_enabled;
  document.getElementById('pipe-brain-model').value = pipeConfig.brain_model || 'gpt-5.2';
  document.getElementById('pipe-local-only').checked = !!pipeConfig.local_only;
  document.getElementById('pipe-auto-commit').checked = pipeConfig.auto_commit !== false;
  document.getElementById('pipe-commit-freq').value = pipeConfig.commit_frequency || 'per_phase';
  document.getElementById('pipe-smoke-test-cmd').value = pipeConfig.smoke_test_cmd || '';
  document.getElementById('pipe-test-cmd').value = pipeConfig.test_cmd || '';
  document.getElementById('pipe-codex-bin').value = pipeConfig.codex_binary || 'codex';
  document.getElementById('pipe-claude-bin').value = pipeConfig.claude_binary || 'claude';
  document.getElementById('pipe-git-preflight-enabled').checked = !!pipeConfig.git_preflight_enabled;
  document.getElementById('pipe-git-preflight-auto-stash').checked = !!pipeConfig.git_preflight_auto_stash;
  document.getElementById('pipe-git-preflight-auto-pull').checked = !!pipeConfig.git_preflight_auto_pull;
  document.getElementById('pipe-pr-aware-enabled').checked = !!pipeConfig.pr_aware_enabled;
  document.getElementById('pipe-pr-feature-branch').value = pipeConfig.pr_feature_branch || '';
  document.getElementById('pipe-pr-remote').value = pipeConfig.pr_remote || '';
  document.getElementById('pipe-pr-base-branch').value = pipeConfig.pr_base_branch || '';
  document.getElementById('pipe-pr-auto-push').checked = pipeConfig.pr_auto_push !== false;
  document.getElementById('pipe-pr-sync-description').checked = pipeConfig.pr_sync_description !== false;
  pipeConfig.timeout_per_phase = _normalizedTimeoutSeconds(pipeConfig.timeout_per_phase, 600);
  syncPipelinePermissionControlsFromConfig();
  syncPipelineCapabilityControlsFromConfig();
  syncPipeTimeoutControlsFromConfig();
  setPipeMode(pipeConfig.mode || 'dry-run');
  togglePipeGitPreflight();
  togglePipePrAware();
  togglePipeUnlimited();
  togglePipeScience();
  togglePipeCUA();
  togglePipeBrain();
  togglePipeVectorMemory(false);
  togglePipeDeepResearch(false);
  togglePipeSelfImprovement();
  togglePipeLocalOnly();
  validatePipeRepo();
}

async function loadPipelinePhases() {
  try {
    pipelinePhases = await api('/api/pipeline/phases');
    renderPipelinePhases();
  } catch(e) {
    console.warn('Could not load pipeline phases', e);
  }
}

// Per-phase custom prompt overrides (keyed by phase key)
const _phasePromptOverrides = {};

function renderPipelinePhases() {
  const list = document.getElementById('phase-list');
  if (!pipelinePhases.length) {
    list.innerHTML = '<div class="state-card loading">Loading phases...</div>';
    scheduleDiagnosticsRefresh('pipeline');
    return;
  }

  const scienceEnabled = document.getElementById('pipe-science').checked;
  const cuaEnabled = document.getElementById('pipe-cua') ? document.getElementById('pipe-cua').checked : false;
  const deepResearchEnabled = document.getElementById('pipe-deep-research-enabled')
    ? document.getElementById('pipe-deep-research-enabled').checked
    : false;
  const selfImprovementEnabled = document.getElementById('pipe-self-improvement-enabled')
    ? document.getElementById('pipe-self-improvement-enabled').checked
    : false;

  list.innerHTML = pipelinePhases.map(p => {
    const isScience = p.is_science;
    const isDeepResearch = p.is_deep_research;
    const isCUA = p.is_cua;
    const isSelfImprovement = p.is_self_improvement;
    const hidden = (isScience && !scienceEnabled)
      || (isDeepResearch && !deepResearchEnabled)
      || (isCUA && !cuaEnabled)
      || (isSelfImprovement && !selfImprovementEnabled);
    if (hidden) return '';
    const icon = PHASE_ICONS[p.key] || '\u2699\uFE0F';
    const desc = p.description || '';
    const prompt = _phasePromptOverrides[p.key] || p.prompt || '';
    const isCustom = !!_phasePromptOverrides[p.key];
    const defaultTestPolicy = (p.default_test_policy || 'skip');

    return '<div class="phase-item" data-phase="' + p.key + '">'
      // Header row (clickable to expand)
      + '<div class="phase-header" role="button" tabindex="0" aria-expanded="false"'
      + ' onclick="togglePhaseExpand(this.parentElement)"'
      + ' onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();togglePhaseExpand(this.parentElement)}">'
      +   '<span class="phase-expand-arrow">\u25B6</span>'
      +   '<input type="checkbox" checked data-phase-enabled="' + p.key + '" style="accent-color:var(--accent)" onclick="event.stopPropagation()" onchange="scheduleDiagnosticsRefresh(\'pipeline\')">'
      +   '<span class="phase-icon">' + icon + '</span>'
      +   '<span class="phase-name">' + esc(p.name) + '</span>'
      +   '<input type="number" class="phase-iter" value="' + p.default_iterations + '" min="1" max="50" data-phase-iter="' + p.key + '" title="Iterations" onclick="event.stopPropagation()">'
      +   '<span style="font-size:10px;color:var(--text2);width:60px;text-align:right">' + (p.log_file || '') + '</span>'
      + '</div>'
      // Expandable details
      + '<div class="phase-details">'
      +   (desc ? '<p class="phase-desc">' + esc(desc) + '</p>' : '')
      // Prompt section
      +   '<div class="phase-prompt-wrap">'
      +     '<label>Prompt '
      +       '<span style="font-size:10px;font-weight:400;color:var(--text2);margin-left:4px">'
      +         (isCustom ? '(customized)' : '(from catalog - editable)')
      +       '</span>'
      +     '</label>'
      +     '<textarea class="phase-prompt" data-phase-prompt="' + p.key + '" '
      +       'oninput="onPhasePromptEdit(\'' + p.key + '\', this.value)" '
      +       'placeholder="Prompt for ' + esc(p.name) + '..."'
      +     '>' + esc(prompt) + '</textarea>'
      +     (isCustom
        ? '<button onclick="resetPhasePrompt(\'' + p.key + '\')" style="margin-top:4px;font-size:11px;padding:3px 10px;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--text2);cursor:pointer" title="Revert to catalog default">Reset to default</button>'
        : '')
      +   '</div>'
      // Meta row: agent, on-failure, test policy, log file
      +   '<div class="phase-meta-row">'
      +     '<div class="form-row">'
      +       '<label>Agent</label>'
      +       '<select data-phase-agent="' + p.key + '" onchange="scheduleDiagnosticsRefresh(\'pipeline\')">'
      +         '<option value="codex">Codex</option>'
      +         '<option value="claude_code">Claude Code</option>'
      +       '</select>'
      +     '</div>'
      +     '<div class="form-row">'
      +       '<label>On Failure</label>'
      +       '<select data-phase-on-failure="' + p.key + '">'
      +         '<option value="skip">Skip</option>'
      +         '<option value="retry">Retry</option>'
      +         '<option value="abort">Abort</option>'
      +       '</select>'
      +     '</div>'
      +     '<div class="form-row">'
      +       '<label>Tests</label>'
      +       '<select data-phase-test-policy="' + p.key + '">'
      +         '<option value="skip"' + (defaultTestPolicy === 'skip' ? ' selected' : '') + '>Skip</option>'
      +         '<option value="smoke"' + (defaultTestPolicy === 'smoke' ? ' selected' : '') + '>Smoke</option>'
      +         '<option value="full"' + (defaultTestPolicy === 'full' ? ' selected' : '') + '>Full</option>'
      +       '</select>'
      +     '</div>'
      +     '<div class="form-row">'
      +       '<label>Log File</label>'
      +       '<span style="font-size:12px;color:var(--text2);padding-top:6px;display:inline-block">' + esc(p.log_file || 'none') + '</span>'
      +     '</div>'
      +   '</div>'
      + '</div>'
    + '</div>';
  }).join('');
  scheduleDiagnosticsRefresh('pipeline');
}

function togglePhaseExpand(el) {
  const expanded = el.classList.toggle('expanded');
  const header = el.querySelector('.phase-header');
  if (header) header.setAttribute('aria-expanded', expanded ? 'true' : 'false');
}

function onPhasePromptEdit(key, value) {
  const phase = pipelinePhases.find(p => p.key === key);
  if (!phase) return;
  // Track custom override only if it differs from the catalog default
  if (value.trim() !== (phase.prompt || '').trim()) {
    _phasePromptOverrides[key] = value;
  } else {
    delete _phasePromptOverrides[key];
  }
}

function resetPhasePrompt(key) {
  delete _phasePromptOverrides[key];
  renderPipelinePhases();
}

function togglePipeScience() {
  pipeConfig.science_enabled = document.getElementById('pipe-science').checked;
  renderPipelinePhases();
}

// -- CUA Visual Testing ------------------------------------------
function togglePipeCUA() {
  const checked = document.getElementById('pipe-cua').checked;
  pipeConfig.cua_enabled = checked;
  document.getElementById('pipe-cua-options').style.display = checked ? 'block' : 'none';
  renderPipelinePhases();
}

function runStandaloneCUA() {
  const provider = document.getElementById('pipe-cua-provider').value;
  const target_url = document.getElementById('pipe-cua-url').value;
  const task = document.getElementById('pipe-cua-task').value;
  const statusEl = document.getElementById('pipe-cua-status');
  statusEl.textContent = 'Starting CUA session...';
  statusEl.style.color = 'var(--accent2)';

  fetch('/api/cua/start', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ provider, target_url, task })
  })
  .then(r => r.json())
  .then(data => {
    if (data.error) {
      statusEl.textContent = 'Error: ' + data.error;
      statusEl.style.color = 'var(--danger)';
    } else {
      statusEl.textContent = 'CUA running (' + data.provider + ')...';
      statusEl.style.color = 'var(--accent2)';
      pollCUAStatus();
    }
  })
  .catch(err => {
    statusEl.textContent = 'Failed: ' + err;
    statusEl.style.color = 'var(--danger)';
  });
}

function pollCUAStatus() {
  const statusEl = document.getElementById('pipe-cua-status');
  const interval = setInterval(() => {
    fetch('/api/cua/status')
      .then(r => r.json())
      .then(data => {
        if (!data.running && data.result) {
          clearInterval(interval);
          const r = data.result;
          statusEl.textContent = '';
          if (r.success) {
            statusEl.textContent = '\u2713 Done: ' + r.total_steps + ' steps, ' + r.duration_seconds + 's';
            statusEl.style.color = 'var(--success)';
          } else {
            statusEl.textContent = '\u2717 Failed: ' + (r.error || 'unknown error');
            statusEl.style.color = 'var(--danger)';
          }
          if (r.summary) {
            const summaryEl = document.createElement('div');
            summaryEl.style.fontSize = '10px';
            summaryEl.style.color = 'var(--text2)';
            summaryEl.textContent = r.summary.substring(0, 200);
            statusEl.appendChild(summaryEl);
          }
        } else if (data.result) {
          statusEl.textContent = 'CUA running... ' + (data.result.total_steps || 0) + ' steps so far';
          statusEl.style.color = 'var(--accent2)';
        }
      })
      .catch(() => {
        clearInterval(interval);
        statusEl.textContent = 'Lost connection to CUA status';
        statusEl.style.color = 'var(--warning)';
      });
  }, 3000);
}

function togglePipeBrain() {
  const on = document.getElementById('pipe-brain').checked;
  pipeConfig.brain_enabled = on;
  document.getElementById('pipe-brain-options').style.display = on ? '' : 'none';
  if (on) {
    pipeConfig.brain_model = document.getElementById('pipe-brain-model').value;
    // Re-apply local-only filter if active
    if (pipeConfig.local_only) togglePipeLocalOnly();
  }
}

function togglePipeUnlimited() {
  const on = document.getElementById('pipe-unlimited').checked;
  pipeConfig.unlimited = on;
  document.getElementById('pipe-threshold-group').style.display = on ? '' : 'none';

  // Max Cycles - ignored in unlimited
  const cyclesInput = document.getElementById('pipe-cycles');
  const cyclesNote = document.getElementById('pipe-cycles-note');
  cyclesInput.disabled = on;
  cyclesInput.style.opacity = on ? '0.4' : '1';
  cyclesNote.textContent = on ? '(ignored - unlimited)' : '';

  // Max Time - still enforced as a safety cap
  const timeNote = document.getElementById('pipe-time-note');
  timeNote.textContent = on ? '(safety cap - still enforced)' : '';

  // Token Budget - still enforced as a safety cap
  const tokensNote = document.getElementById('pipe-tokens-note');
  tokensNote.textContent = on ? '(safety cap - still enforced)' : '';

  // Convergence - forced on in unlimited mode
  const convCheck = document.getElementById('pipe-stop-convergence');
  const convNote = document.getElementById('pipe-convergence-note');
  if (on) {
    convCheck.checked = true;
    convCheck.disabled = true;
    convCheck.style.opacity = '0.6';
    convNote.textContent = '(always on in unlimited)';
    pipeConfig.stop_on_convergence = true;
  } else {
    convCheck.disabled = false;
    convCheck.style.opacity = '1';
    convNote.textContent = '';
  }
}

function setPipeMode(mode) {
  pipeConfig.mode = mode;
  document.querySelectorAll('#pipe-mode-toggle button').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
  togglePipePrAware();
}

function syncPipeGitPreflightOptions() {
  const enabledEl = document.getElementById('pipe-git-preflight-enabled');
  const stashEl = document.getElementById('pipe-git-preflight-auto-stash');
  const pullEl = document.getElementById('pipe-git-preflight-auto-pull');
  const enabled = !!(enabledEl && enabledEl.checked);
  pipeConfig.git_preflight_enabled = enabled;
  pipeConfig.git_preflight_auto_stash = !!(enabled && stashEl && stashEl.checked);
  pipeConfig.git_preflight_auto_pull = !!(enabled && pullEl && pullEl.checked);
}

function togglePipeGitPreflight() {
  const enabledEl = document.getElementById('pipe-git-preflight-enabled');
  const optionsEl = document.getElementById('pipe-git-preflight-options');
  const stashEl = document.getElementById('pipe-git-preflight-auto-stash');
  const pullEl = document.getElementById('pipe-git-preflight-auto-pull');
  const enabled = !!(enabledEl && enabledEl.checked);
  if (optionsEl) optionsEl.classList.toggle('hidden', !enabled);
  if (!enabled) {
    if (stashEl) stashEl.checked = false;
    if (pullEl) pullEl.checked = false;
  }
  syncPipeGitPreflightOptions();
}

function syncPipePrAwareOptions() {
  const enabledEl = document.getElementById('pipe-pr-aware-enabled');
  const branchEl = document.getElementById('pipe-pr-feature-branch');
  const remoteEl = document.getElementById('pipe-pr-remote');
  const baseEl = document.getElementById('pipe-pr-base-branch');
  const autoPushEl = document.getElementById('pipe-pr-auto-push');
  const syncDescEl = document.getElementById('pipe-pr-sync-description');
  const mode = String(pipeConfig.mode || 'dry-run').toLowerCase();
  const applyMode = mode === 'apply';
  const enabled = !!(enabledEl && enabledEl.checked && applyMode);

  pipeConfig.pr_aware_enabled = enabled;
  pipeConfig.pr_feature_branch = branchEl ? branchEl.value.trim() : '';
  pipeConfig.pr_remote = remoteEl ? remoteEl.value.trim() : '';
  pipeConfig.pr_base_branch = baseEl ? baseEl.value.trim() : '';
  pipeConfig.pr_auto_push = !!(enabled && autoPushEl && autoPushEl.checked);
  pipeConfig.pr_sync_description = !!(enabled && syncDescEl && syncDescEl.checked);
}

function togglePipePrAware() {
  const enabledEl = document.getElementById('pipe-pr-aware-enabled');
  const optionsEl = document.getElementById('pipe-pr-aware-options');
  const mode = String(pipeConfig.mode || 'dry-run').toLowerCase();
  const applyMode = mode === 'apply';
  const requested = !!(enabledEl && enabledEl.checked);
  const enabled = requested && applyMode;

  if (enabledEl) {
    enabledEl.disabled = !applyMode;
    enabledEl.title = applyMode
      ? ''
      : 'PR-aware mode requires Apply mode.';
    if (!applyMode && requested) enabledEl.checked = false;
  }
  if (optionsEl) optionsEl.classList.toggle('hidden', !enabled);
  syncPipePrAwareOptions();
}

let pipeRepoTimeout;
function validatePipeRepo() {
  clearTimeout(pipeRepoTimeout);
  const path = document.getElementById('pipe-repo-path').value.trim();
  pipeConfig.repo_path = path;
  scheduleDiagnosticsRefresh('pipeline');
  scheduleGitSyncRefresh({ delayMs: 300, silent: true });
  if (!path) {
    document.getElementById('pipe-repo-status').textContent = '';
    pipelineResumeState = null;
    renderPipelineResumeCard();
    refreshPipelineRunComparison({ repoPath: '', silent: true });
    scheduleGitSyncRefresh({ delayMs: 0, silent: true, force: true });
    return;
  }
  pipeRepoTimeout = setTimeout(async () => {
    try {
      const r = await postJson('/api/validate-repo', {path});
      if (path !== document.getElementById('pipe-repo-path').value.trim()) return;
      const el = document.getElementById('pipe-repo-status');
      if (r.is_git)      { el.textContent = '\u2705'; el.title = 'Valid git repo'; }
      else if (r.exists)  { el.textContent = '\u26a0\ufe0f'; el.title = 'Not a git repo'; }
      else                { el.textContent = '\u274c'; el.title = 'Path not found'; }
      maybeAutoEnableVectorMemory('pipeline', r);
      schedulePipelineResumeRefresh(path, { delayMs: 0, silent: true });
      refreshPipelineRunComparison({ repoPath: path, silent: true });
      scheduleGitSyncRefresh({ delayMs: 0, silent: true });
    } catch(e) {}
  }, 400);
}

/* -- Pipeline Execution ---------------------------------------- */

function schedulePipelineResumeRefresh(repoPath, opts = {}) {
  if (pipelineResumeRefreshTimer) {
    clearTimeout(pipelineResumeRefreshTimer);
    pipelineResumeRefreshTimer = null;
  }
  const normalizedRepoPath = String(repoPath || pipeConfig.repo_path || '').trim();
  if (!normalizedRepoPath) {
    pipelineResumeState = null;
    renderPipelineResumeCard();
    return;
  }
  const delayRaw = Number(opts.delayMs);
  const delayMs = Number.isFinite(delayRaw) ? Math.max(0, Math.floor(delayRaw)) : 300;
  pipelineResumeRefreshTimer = setTimeout(() => {
    pipelineResumeRefreshTimer = null;
    refreshPipelineResumeState({
      repoPath: normalizedRepoPath,
      silent: opts.silent !== false,
    });
  }, delayMs);
}

async function refreshPipelineResumeState(opts = {}) {
  const repoPath = String(
    opts.repoPath || pipeConfig.repo_path || document.getElementById('pipe-repo-path').value || ''
  ).trim();
  if (!repoPath) {
    pipelineResumeState = null;
    renderPipelineResumeCard();
    return;
  }
  const resp = await api('/api/pipeline/resume-state?repo_path=' + encodeURIComponent(repoPath));
  const currentRepoPath = String(document.getElementById('pipe-repo-path').value || '').trim();
  if (currentRepoPath && currentRepoPath !== repoPath) return;
  if (resp && resp.error) {
    if (!opts.silent) toast(resp.error, 'error');
    pipelineResumeState = null;
    renderPipelineResumeCard();
    return;
  }
  pipelineResumeState = resp && typeof resp === 'object' ? resp : null;
  renderPipelineResumeCard();
}

function renderPipelineResumeCard() {
  const card = document.getElementById('pipe-resume-card');
  if (!card) return;
  const summaryEl = document.getElementById('pipe-resume-summary');
  const metaEl = document.getElementById('pipe-resume-meta');
  const resumeBtn = document.getElementById('pipe-resume-btn');
  const freshBtn = document.getElementById('pipe-start-fresh-btn');
  const repoPath = String(pipeConfig.repo_path || '').trim();
  const state = (pipelineResumeState && typeof pipelineResumeState === 'object')
    ? pipelineResumeState
    : null;
  const hasCheckpoint = !!(state && state.exists);
  if (!repoPath || !hasCheckpoint || pipeRunning || pipePaused) {
    card.classList.add('hidden');
    return;
  }

  const ready = !!state.resume_ready;
  const cycle = Number(state.resume_cycle || 0);
  const phaseIndex = Number(state.resume_phase_index || 0);
  const savedAtEpochMs = Number(state.saved_at_epoch_ms || 0);
  const errorText = String(state.error || '').trim();
  const details = [];
  if (cycle > 0) details.push('Cycle ' + cycle);
  if (phaseIndex >= 0) details.push('Phase index ' + phaseIndex);
  if (savedAtEpochMs > 0) details.push('Saved ' + new Date(savedAtEpochMs).toLocaleString());
  if (errorText) details.push(errorText);

  if (summaryEl) {
    summaryEl.textContent = ready
      ? 'A resumable pipeline checkpoint is available for this repository.'
      : 'A checkpoint was found, but it cannot be resumed safely.';
  }
  if (metaEl) metaEl.textContent = details.join(' | ');
  if (resumeBtn) {
    resumeBtn.disabled = !ready;
    resumeBtn.title = ready
      ? 'Restart and continue from the saved checkpoint.'
      : (errorText || 'Checkpoint is not resumable.');
  }
  if (freshBtn) {
    freshBtn.disabled = false;
  }
  card.classList.remove('hidden');
}

async function resumePipelineFromCheckpoint() {
  const state = (pipelineResumeState && typeof pipelineResumeState === 'object')
    ? pipelineResumeState
    : {};
  const checkpointPath = String(state.checkpoint_path || '').trim();
  if (!checkpointPath) {
    toast('No resume checkpoint found for this repository.', 'error');
    return;
  }
  if (!state.resume_ready) {
    toast(String(state.error || 'Checkpoint is not resumable.'), 'error');
    return;
  }
  await requestServerRestart(checkpointPath, {
    auto: false,
    reason: 'manual_resume',
    source: 'pipeline_resume_card',
  });
}

async function clearPipelineResumeCheckpoint(opts = {}) {
  const repoPath = String(
    opts.repoPath || pipeConfig.repo_path || document.getElementById('pipe-repo-path').value || ''
  ).trim();
  if (!repoPath) return false;
  const resp = await postJson('/api/pipeline/resume-state/clear', { repo_path: repoPath });
  if (resp.error) {
    if (!opts.silent) toast(resp.error, 'error');
    return false;
  }
  if (!opts.silent && resp.removed) {
    toast('Cleared pipeline resume checkpoint.', 'info');
  }
  pipelineResumeState = null;
  await refreshPipelineResumeState({ repoPath, silent: true });
  return true;
}

async function startFreshPipelineRun() {
  if (pipeRunning || pipePaused) {
    toast('Pipeline is already running.', 'info');
    return;
  }
  const repoPath = String(document.getElementById('pipe-repo-path').value || '').trim();
  if (!repoPath) {
    toast('Set a repository path first', 'error');
    return;
  }
  const hasCheckpoint = !!(pipelineResumeState && pipelineResumeState.exists);
  if (hasCheckpoint) {
    const cleared = await clearPipelineResumeCheckpoint({ repoPath, silent: true });
    if (!cleared) return;
    toast('Starting a fresh run (resume checkpoint cleared).', 'info');
  }
  await startPipeline();
}

async function startPipeline() {
  // Sync all config from UI inputs (consistent with chain builder's startChain)
  pipeConfig.repo_path              = document.getElementById('pipe-repo-path').value.trim();
  pipeConfig.unlimited              = document.getElementById('pipe-unlimited').checked;
  pipeConfig.improvement_threshold  = parseFloat(document.getElementById('pipe-threshold-slider').value) || 1.0;
  pipeConfig.max_cycles             = parseInt(document.getElementById('pipe-cycles').value) || 3;
  pipeConfig.max_time_minutes       = parseInt(document.getElementById('pipe-max-time').value) || 240;
  pipeConfig.max_total_tokens       = parseInt(document.getElementById('pipe-max-tokens').value) || 5000000;
  pipeConfig.strict_token_budget    = document.getElementById('pipe-strict-token-budget').checked;
  pipeConfig.stop_on_convergence    = document.getElementById('pipe-stop-convergence').checked;
  pipeConfig.agent                  = document.getElementById('pipe-agent').value;
  pipeConfig.science_enabled        = document.getElementById('pipe-science').checked;
  pipeConfig.brain_enabled          = document.getElementById('pipe-brain').checked;
  pipeConfig.brain_model            = document.getElementById('pipe-brain-model').value;
  pipeConfig.local_only             = document.getElementById('pipe-local-only').checked;
  pipeConfig.cua_enabled            = document.getElementById('pipe-cua').checked;
  pipeConfig.cua_provider           = document.getElementById('pipe-cua-provider').value;
  pipeConfig.cua_target_url         = document.getElementById('pipe-cua-url').value.trim();
  pipeConfig.cua_task               = document.getElementById('pipe-cua-task').value.trim();
  pipeConfig.auto_commit            = document.getElementById('pipe-auto-commit').checked;
  pipeConfig.commit_frequency       = document.getElementById('pipe-commit-freq').value;
  pipeConfig.smoke_test_cmd         = document.getElementById('pipe-smoke-test-cmd').value.trim();
  pipeConfig.test_cmd               = document.getElementById('pipe-test-cmd').value.trim();
  pipeConfig.codex_binary           = document.getElementById('pipe-codex-bin').value.trim();
  pipeConfig.codex_reasoning_effort = document.getElementById('pipe-codex-reasoning-effort').value;
  pipeConfig.codex_sandbox_mode     = document.getElementById('pipe-codex-sandbox-mode').value;
  pipeConfig.codex_approval_policy  = document.getElementById('pipe-codex-approval-policy').value;
  pipeConfig.codex_bypass_approvals_and_sandbox = document.getElementById('pipe-codex-bypass-approvals').checked;
  pipeConfig.claude_binary          = document.getElementById('pipe-claude-bin').value.trim();
  pipeConfig.timeout_per_phase      = readPipeTimeoutFromUi();
  pipeConfig.allow_path_creation    = document.getElementById('pipe-allow-path-creation').checked;
  pipeConfig.dependency_install_policy = document.getElementById('pipe-dependency-install-policy').value;
  pipeConfig.image_generation_enabled = document.getElementById('pipe-image-generation-enabled').checked;
  pipeConfig.image_provider         = document.getElementById('pipe-image-provider').value;
  pipeConfig.image_model            = document.getElementById('pipe-image-model').value.trim();
  pipeConfig.vector_memory_enabled  = document.getElementById('pipe-vector-memory-enabled').checked;
  pipeConfig.vector_memory_backend  = document.getElementById('pipe-vector-memory-backend').value;
  pipeConfig.vector_memory_collection = document.getElementById('pipe-vector-memory-collection').value.trim();
  pipeConfig.vector_memory_top_k    = parseInt(document.getElementById('pipe-vector-memory-top-k').value, 10) || 8;
  pipeConfig.deep_research_enabled  = document.getElementById('pipe-deep-research-enabled').checked;
  pipeConfig.deep_research_providers = document.getElementById('pipe-deep-research-providers').value;
  pipeConfig.deep_research_max_age_hours = parseInt(document.getElementById('pipe-deep-research-max-age-hours').value, 10) || 168;
  pipeConfig.deep_research_dedupe   = document.getElementById('pipe-deep-research-dedupe').checked;
  pipeConfig.deep_research_native_enabled = document.getElementById('pipe-deep-research-native-enabled').checked;
  pipeConfig.deep_research_retry_attempts = parseInt(document.getElementById('pipe-deep-research-retry-attempts').value, 10) || 2;
  pipeConfig.deep_research_daily_quota = parseInt(document.getElementById('pipe-deep-research-daily-quota').value, 10) || 8;
  pipeConfig.deep_research_max_provider_tokens = parseInt(document.getElementById('pipe-deep-research-max-provider-tokens').value, 10) || 12000;
  pipeConfig.deep_research_budget_usd = parseFloat(document.getElementById('pipe-deep-research-budget-usd').value) || 5.0;
  pipeConfig.deep_research_openai_model = document.getElementById('pipe-deep-research-openai-model').value.trim();
  pipeConfig.deep_research_google_model = document.getElementById('pipe-deep-research-google-model').value.trim();
  pipeConfig.self_improvement_enabled = document.getElementById('pipe-self-improvement-enabled').checked;
  pipeConfig.self_improvement_auto_restart = document.getElementById('pipe-self-improvement-auto-restart').checked;
  pipeConfig.git_preflight_enabled = document.getElementById('pipe-git-preflight-enabled').checked;
  pipeConfig.git_preflight_auto_stash = document.getElementById('pipe-git-preflight-auto-stash').checked;
  pipeConfig.git_preflight_auto_pull = document.getElementById('pipe-git-preflight-auto-pull').checked;
  pipeConfig.pr_aware_enabled = document.getElementById('pipe-pr-aware-enabled').checked;
  pipeConfig.pr_feature_branch = document.getElementById('pipe-pr-feature-branch').value.trim();
  pipeConfig.pr_remote = document.getElementById('pipe-pr-remote').value.trim();
  pipeConfig.pr_base_branch = document.getElementById('pipe-pr-base-branch').value.trim();
  pipeConfig.pr_auto_push = document.getElementById('pipe-pr-auto-push').checked;
  pipeConfig.pr_sync_description = document.getElementById('pipe-pr-sync-description').checked;
  if (!pipeConfig.self_improvement_enabled) {
    pipeConfig.self_improvement_auto_restart = false;
  }
  if (!pipeConfig.git_preflight_enabled) {
    pipeConfig.git_preflight_auto_stash = false;
    pipeConfig.git_preflight_auto_pull = false;
  }
  if (!pipeConfig.pr_aware_enabled || (pipeConfig.mode || 'dry-run') !== 'apply') {
    pipeConfig.pr_aware_enabled = false;
    pipeConfig.pr_auto_push = false;
    pipeConfig.pr_sync_description = false;
  }
  togglePipeGitPreflight();
  togglePipePrAware();
  normalizeCodexPermissions(pipeConfig);
  normalizeCapabilitySettings(pipeConfig);
  syncPipelinePermissionControlsFromConfig();
  syncPipelineCapabilityControlsFromConfig();
  togglePipeVectorMemory(false);
  togglePipeDeepResearch(false);
  togglePipeSelfImprovement();
  syncPipeTimeoutControlsFromConfig();

  if (!pipeConfig.repo_path) { toast('Set a repository path first', 'error'); return; }
  const phaseEls = Array.from(document.querySelectorAll('#phase-list .phase-item'));
  const pipelineUsesCodex = phaseEls.length
    ? phaseEls.some(el => {
      const enabledEl = el.querySelector('[data-phase-enabled]');
      if (!enabledEl || !enabledEl.checked) return false;
      const agentSel = el.querySelector('[data-phase-agent]');
      const agent = agentSel ? agentSel.value : pipeConfig.agent;
      return agent !== 'claude_code';
    })
    : pipeConfig.agent !== 'claude_code';
  const runPlan = await openRunPlanModal('pipeline');
  if (!applyRunPlanChoice(runPlan)) return;
  if ((runPlan.profile || 'safe') === 'readonly' && pipelineUsesCodex) {
    toast('Read-Only Inspect selected: Codex can analyze but cannot write files in this run.', 'info');
  }
  if (!requestDangerConfirmationIfNeeded(pipeConfig)) return;

  // Collect phase configs (including per-phase agent, on-failure, and custom prompts)
  const phases = [];
  document.querySelectorAll('#phase-list .phase-item').forEach(el => {
    const key = el.dataset.phase;
    const enabled = el.querySelector('[data-phase-enabled]').checked;
    const iter = parseInt(el.querySelector('.phase-iter').value) || 1;
    const agentSel = el.querySelector('[data-phase-agent]');
    const failSel = el.querySelector('[data-phase-on-failure]');
    const testPolicySel = el.querySelector('[data-phase-test-policy]');
    const agent = agentSel ? agentSel.value : pipeConfig.agent;
    const on_failure = failSel ? failSel.value : 'skip';
    const test_policy = testPolicySel ? testPolicySel.value : 'skip';
    const custom_prompt = _phasePromptOverrides[key] || '';
    phases.push({ phase: key, enabled, iterations: iter, agent, on_failure, test_policy, custom_prompt });
  });
  pipeConfig.phases = phases;

  pipeLogEntries = [];
  pipeResultsCache = [];
  pipeResultsCount = 0;
  _pipeResultsRenderSignature = '';
  pipeLastActivityMs = 0;
  pipeRunning = true;
  pipePaused = false;
  renderActivityHeartbeats();
  renderPipelineResumeCard();
  document.getElementById('pipe-progress-last-log').textContent = 'Last log: waiting for first message...';
  renderStopGuidance('pipe-stop-guidance', null, false);
  document.getElementById('pipe-log-viewer').innerHTML = '<div class="log-empty state-card loading">Connecting to live log stream...</div>';
  document.getElementById('pipe-results-body').innerHTML = '<tr><td colspan="8"><div class="state-card loading">Waiting for phase results...</div></td></tr>';

  const resp = await postJson('/api/pipeline/start', pipeConfig);
  if (resp.error) {
    pipeRunning = false;
    pipePaused = false;
    renderActivityHeartbeats();
    renderPipelineResumeCard();
    document.getElementById('pipe-log-viewer').innerHTML = '<div class="log-empty state-card error">Could not start pipeline. Check diagnostics and configuration.</div>';
    document.getElementById('pipe-results-body').innerHTML = '<tr><td colspan="8"><div class="state-card">No pipeline results yet. Start a pipeline run to populate this table.</div></td></tr>';
    toast(resp.error, 'error');
    return;
  }

  setPipeControlsRunning(true);
  connectPipeSSE();
  startPipePolling();
  if ((pipeConfig.mode || 'dry-run') === 'dry-run') {
    toast('SAFE MODE ACTIVE: Dry Run is enabled. Changes are evaluated and then reverted.', 'info');
  }
  const gitPreflight = (resp && typeof resp.git_preflight === 'object') ? resp.git_preflight : null;
  if (gitPreflight) {
    const actions = Array.isArray(gitPreflight.actions) ? gitPreflight.actions : [];
    const warnings = Array.isArray(gitPreflight.warnings) ? gitPreflight.warnings : [];
    if (actions.length) {
      toast('Git pre-flight: ' + actions.join(' | '), 'info');
    }
    if (warnings.length) {
      toast('Git pre-flight warnings: ' + warnings.join(' | '), 'warn');
    }
  }
  toast('Pipeline started', 'success');
}

async function stopPipeline() {
  const r = await postJson('/api/pipeline/stop');
  if (r.error) {
    toast(r.error, 'error');
    return;
  }
  toast('Stop requested', 'info');
}

async function pausePipeline() {
  const r = await postJson('/api/pipeline/pause');
  if (r.error) {
    toast(r.error, 'error');
    return;
  }
  document.getElementById('pipe-btn-pause').innerHTML = r.status === 'paused' ? '&#9654; Resume' : '&#9208; Pause';
}

function setPipeControlsRunning(running) {
  document.getElementById('pipe-btn-start').disabled = running;
  document.getElementById('pipe-btn-pause').disabled = !running;
  document.getElementById('pipe-btn-stop').disabled  = !running;
  renderPipelineResumeCard();
}

function connectPipeSSE() {
  if (pipelineSSE) pipelineSSE.close();
  pipelineSSE = new EventSource('/api/pipeline/stream');
  pipelineSSE.onmessage = (e) => {
    let data;
    try { data = JSON.parse(e.data); } catch { return; }
    if (data.type === 'heartbeat') return;
    addPipeLogEntry(data);
  };
}

function renderPipeLogViewer() {
  const viewer = document.getElementById('pipe-log-viewer');
  viewer.innerHTML = '';
  const filtered = pipeLogEntries.filter(e => shouldShowLogEntry(e, true));
  if (!filtered.length) {
    viewer.innerHTML = '<div class="log-empty state-card">No log entries to show.</div>';
    return;
  }
  filtered.forEach(e => appendLogEntry('pipe-log-viewer', e));
}

function togglePipeDebugLogs() {
  renderPipeLogViewer();
}

function addPipeLogEntry(entry) {
  markPipeActivity();
  pipeLogEntries.push(entry);
  if (pipeLogEntries.length > 4000) pipeLogEntries.shift();
  if (!shouldShowLogEntry(entry, true)) return;
  appendLogEntry('pipe-log-viewer', entry);
}

function startPipePolling() {
  if (pipelinePollTimer) clearInterval(pipelinePollTimer);
  pipelinePollTimer = setInterval(pollPipeStatus, 2000);
}

async function pollPipeStatus() {
  try {
    const s = await api('/api/pipeline/status?since_results=' + encodeURIComponent(pipeResultsCount));
    if (s && s.error) {
      setBackendOnlineState(false, s.error);
      return;
    }
    updatePipeProgress(s);
    const next = _consumeResultsPayload(s, pipeResultsCache, pipeResultsCount);
    pipeResultsCache = next.results;
    pipeResultsCount = next.total;
    updatePipeResults(pipeResultsCache);

    if (!s.running) {
      setPipeControlsRunning(false);
      clearInterval(pipelinePollTimer);
      pipelinePollTimer = null;
      if (pipelineSSE) { pipelineSSE.close(); pipelineSSE = null; }
      const completedRepoPath = String(pipeConfig.repo_path || s.repo_path || '').trim();
      schedulePipelineResumeRefresh(completedRepoPath, { delayMs: 0, silent: true });
      refreshPipelineRunComparison({ repoPath: completedRepoPath, silent: true });
    }
  } catch(e) {}
}

async function maybeHandlePipelineSelfRestart(statusPayload) {
  if (!statusPayload) return;
  if (statusPayload.stop_reason !== 'self_restart_requested' || !statusPayload.restart_required) {
    return;
  }
  const checkpointPath = String(statusPayload.restart_checkpoint_path || '').trim();
  if (!checkpointPath) return;

  if (pipeConfig.self_improvement_auto_restart) {
    await requestServerRestart(checkpointPath, {
      auto: true,
      reason: 'self_improvement_auto_restart',
      source: 'pipeline_status',
    });
    return;
  }

  pipelineResumeState = {
    exists: true,
    resume_ready: true,
    checkpoint_path: checkpointPath,
    resume_cycle: Number(statusPayload.resume_cycle || 1),
    resume_phase_index: Number(statusPayload.resume_phase_index || 0),
    repo_path: String(pipeConfig.repo_path || ''),
    saved_at_epoch_ms: Date.now(),
  };
  renderPipelineResumeCard();

  if (selfRestartNoticeCheckpoint !== checkpointPath) {
    selfRestartNoticeCheckpoint = checkpointPath;
    toast(
      'Self-improvement checkpoint created. Restart server to continue from: ' + checkpointPath,
      'info'
    );
  }
}

function updatePipeProgress(s) {
  pipeRunning = !!s.running;
  pipePaused = !!s.paused;
  const statusRepoPath = String(s.repo_path || '').trim();
  if (statusRepoPath && !pipeConfig.repo_path) {
    pipeConfig.repo_path = statusRepoPath;
    const repoInput = document.getElementById('pipe-repo-path');
    if (repoInput) repoInput.value = statusRepoPath;
    validatePipeRepo();
  }
  const runUnlimited = typeof s.run_unlimited === 'boolean' ? !!s.run_unlimited : !!pipeConfig.unlimited;
  const runMaxCycles = Number.isFinite(Number(s.run_max_cycles)) && Number(s.run_max_cycles) > 0
    ? Number(s.run_max_cycles)
    : Math.max(1, Number(pipeConfig.max_cycles) || 1);
  const stopGuidance = s.stop_guidance || null;
  if (s.last_log_epoch_ms) pipeLastActivityMs = s.last_log_epoch_ms;
  renderActivityHeartbeats();
  _renderLastLogHint('pipe-progress-last-log', s);
  let pct;
  if (runUnlimited) {
    // In unlimited mode the bar shows improvement remaining (approaching 0% = converging)
    pct = Math.min(100, Math.max(0, Math.round(s.improvement_pct || 100)));
  } else {
    pct = Math.min(100, Math.max(0, Math.round(
      (s.total_cycles || 0) / Math.max(1, runMaxCycles) * 100
    )));
  }
  const pipeProgressFill = document.getElementById('pipe-progress-fill');
  pipeProgressFill.style.width = pct + '%';
  pipeProgressFill.classList.toggle('running', !!s.running && !s.paused);

  // Token count + improvement badge (consistent with chain builder)
  let tokenText = (s.total_tokens || 0).toLocaleString() + ' tokens';
  if (s.improvement_pct !== undefined && s.improvement_pct < 200 && (s.total_phases || 0) > 0) {
    tokenText += '  |  improvement: ' + (s.improvement_pct || 0).toFixed(1) + '%';
  }
  document.getElementById('pipe-progress-tokens').textContent = tokenText;

  let text = 'Ready';
  if (s.running && s.paused) {
    text = 'Paused';
  } else if (s.running) {
    const runningFor = s.current_phase_started_at_epoch_ms
      ? Math.max(0, Math.floor((Date.now() - s.current_phase_started_at_epoch_ms) / 1000))
      : 0;
    const iter = s.current_iteration || 0;
    const cycleLabel = runUnlimited
      ? 'Cycle ' + (s.current_cycle || 1) + ' / \u221e'
      : 'Cycle ' + (s.current_cycle || 1) + '/' + runMaxCycles;
    text = '[' + _spinnerFrame() + '] ' + cycleLabel
         + ' \u2022 Phase: ' + (s.current_phase || '...')
         + (iter > 0 ? (' (iter ' + iter + ')') : '')
         + ' \u2022 ' + (s.total_phases || 0) + ' phases completed';
    if (runningFor > 0) text += ' \u2022 running ' + _formatElapsedSeconds(runningFor);
    if (!runUnlimited) text += ' \u2022 ' + pct + '%';
  } else if (s.stop_reason) {
    const label = stopGuidance && stopGuidance.label ? stopGuidance.label : s.stop_reason;
    text = 'Finished: ' + label + ' (' + (s.total_cycles || 0) + ' cycles)';
  }
  document.getElementById('pipe-progress-text').textContent = text;
  renderStopGuidance('pipe-stop-guidance', stopGuidance, s.running);
  if (!s.running) {
    maybeHandlePipelineSelfRestart(s);
  }
}

function updatePipeResults(results) {
  const signature = _resultsSignature(results);
  if (signature === _pipeResultsRenderSignature) return;
  _pipeResultsRenderSignature = signature;

  const tbody = document.getElementById('pipe-results-body');
  const openKeys = _captureOpenChangedFileRows('pipe-results-body');
  if (!results.length) {
    tbody.innerHTML = '<tr><td colspan="8"><div class="state-card">No pipeline results yet. Start a pipeline run to populate this table.</div></td></tr>';
    return;
  }
  tbody.innerHTML = results.map((r, idx) => {
    const statusBadge = r.success ? 'badge-pass' : 'badge-fail';
    const statusText = r.success ? 'ok' : 'failed';
    const testBadge = r.test_outcome === 'passed' ? 'badge-pass'
      : r.test_outcome === 'failed' ? 'badge-fail'
      : r.test_outcome === 'skipped' ? 'badge-skip' : 'badge-error';
    const rowKey = 'pipe:' + idx + ':' + (r.cycle || 0) + ':' + String(r.phase || '') + ':' + (r.iteration || 0);
    return '<tr data-change-key="' + esc(rowKey) + '">'
      + '<td>' + esc(r.phase || '') + '</td>'
      + '<td>' + (r.iteration || 0) + '</td>'
      + '<td><span class="badge ' + statusBadge + '">' + statusText + '</span></td>'
      + '<td><span class="badge ' + testBadge + '">' + esc(r.test_outcome || 'unknown') + '</span></td>'
      + '<td>' + (r.files_changed || 0) + '</td>'
      + '<td class="file-changes-cell">' + renderChangedFilesCell(r.changed_files, r.files_changed) + '</td>'
      + '<td>' + (((r.net_lines_changed || 0) >= 0 ? '+' : '') + (r.net_lines_changed || 0)) + '</td>'
      + '<td>' + ((r.duration_seconds || 0) + 's') + '</td>'
    + '</tr>';
  }).join('');
  _restoreOpenChangedFileRows('pipe-results-body', openKeys);
}

/* -- Log File Viewer ------------------------------------------- */

function _formatRunCompareTimestamp(value) {
  const raw = String(value || '').trim();
  if (!raw) return 'n/a';
  const ts = Date.parse(raw);
  if (!Number.isFinite(ts)) return raw;
  return new Date(ts).toLocaleString();
}

function _formatRunCompareDuration(value) {
  const seconds = Number(value || 0);
  if (!Number.isFinite(seconds) || seconds <= 0) return 'n/a';
  return _formatElapsedSeconds(Math.round(seconds));
}

function _runCompareBadgeLabel(value) {
  const key = String(value || '').trim().toLowerCase();
  if (key === 'best_overall') return 'Best Overall';
  if (key === 'fastest') return 'Fastest';
  if (key === 'lowest_tokens') return 'Lowest Tokens';
  if (key === 'lowest_cost') return 'Lowest Cost';
  if (key === 'best_cost_efficiency') return 'Best Cost Efficiency';
  if (key === 'strongest_tests') return 'Strongest Tests';
  if (key === 'budget_outlier') return 'Budget Outlier';
  return key || 'signal';
}

function _runCompareBadgeClass(value) {
  const key = String(value || '').trim().toLowerCase();
  return key === 'best_overall' ? 'run-compare-badge best-overall' : 'run-compare-badge';
}

function _renderRunCompareBadges(badges) {
  const items = Array.isArray(badges) ? badges : [];
  if (!items.length) return '';
  return '<div class="run-compare-badges">' + items.map(item => {
    return '<span class="' + _runCompareBadgeClass(item) + '">' + esc(_runCompareBadgeLabel(item)) + '</span>';
  }).join('') + '</div>';
}

function _runCompareTestsBadgeClass(run) {
  const tests = (run && typeof run === 'object' && run.tests && typeof run.tests === 'object')
    ? run.tests
    : {};
  const failed = Number(tests.failed || 0) + Number(tests.error || 0);
  const passed = Number(tests.passed || 0);
  const skipped = Number(tests.skipped || 0);
  if (failed > 0) return 'badge-fail';
  if (passed > 0) return 'badge-pass';
  if (skipped > 0) return 'badge-skip';
  return 'badge-error';
}

function renderPipelineRunComparison(payload) {
  const body = document.getElementById('pipe-run-compare-body');
  const summaryEl = document.getElementById('pipe-run-compare-summary');
  if (!body || !summaryEl) return;

  const data = payload && typeof payload === 'object' ? payload : {};
  const runs = Array.isArray(data.runs) ? data.runs : [];
  if (!runs.length) {
    const msg = data.message || 'No completed runs were found in history yet.';
    body.innerHTML = '<tr><td colspan="10"><div class="state-card">' + esc(msg) + '</div></td></tr>';
    summaryEl.textContent = msg;
    return;
  }

  const bestBy = data.best_by && typeof data.best_by === 'object' ? data.best_by : {};
  const bestOverallId = String(bestBy.overall_run_id || '').trim();
  const bestOverall = runs.find(run => String(run.run_id || '') === bestOverallId) || null;
  summaryEl.textContent = bestOverall
    ? ('Best overall so far: ' + String(bestOverall.configuration || 'n/a'))
    : 'Compare recent finished runs to identify the most effective configuration.';

  body.innerHTML = runs.map(run => {
    const scope = String(run.scope || '').trim().toLowerCase();
    const scopeLabel = scope === 'pipeline' ? 'Pipeline' : 'Chain';
    const runId = String(run.run_id || '').trim();
    const mode = String(run.mode || 'unknown');
    const testsSummary = String(run.tests_summary || 'n/a');
    const stopReason = String(run.stop_reason || 'unknown');
    const tokens = Number(run.token_usage || 0);
    const tokenText = Number.isFinite(tokens) && tokens > 0 ? tokens.toLocaleString() : '0';
    const costUsd = Number(run.estimated_cost_usd || 0);
    const costText = Number.isFinite(costUsd) && costUsd > 0 ? ('$' + costUsd.toFixed(4)) : 'n/a';
    const commitCount = Number(run.commit_count || 0);
    const runLabel = '<div class="run-compare-run-label">'
      + '<span>' + esc(scopeLabel + ' / ' + mode) + '</span>'
      + _renderRunCompareBadges(run.badges)
      + '</div>';
    const runIdArg = encodeURIComponent(runId);
    const exportButton = runId
      ? '<button class="btn" type="button" onclick="exportRunArtifactBundle(decodeURIComponent(\'' + escAttr(runIdArg) + '\'))">Export Bundle</button>'
      : '<span class="file-changes-empty">n/a</span>';
    return '<tr>'
      + '<td>' + esc(_formatRunCompareTimestamp(run.finished_at)) + '</td>'
      + '<td>' + runLabel + '</td>'
      + '<td>' + esc(String(run.configuration || 'n/a')) + '</td>'
      + '<td>' + esc(_formatRunCompareDuration(run.duration_seconds)) + '</td>'
      + '<td>' + esc(tokenText) + '</td>'
      + '<td>' + esc(costText) + '</td>'
      + '<td><span class="badge ' + _runCompareTestsBadgeClass(run) + '">' + esc(testsSummary) + '</span></td>'
      + '<td>' + esc(stopReason) + '</td>'
      + '<td>' + esc(String(Number.isFinite(commitCount) ? commitCount : 0)) + '</td>'
      + '<td>' + exportButton + '</td>'
      + '</tr>';
  }).join('');
}

async function refreshPipelineRunComparison(opts = {}) {
  const body = document.getElementById('pipe-run-compare-body');
  const summaryEl = document.getElementById('pipe-run-compare-summary');
  const repoPath = String(
    opts.repoPath || pipeConfig.repo_path || document.getElementById('pipe-repo-path').value || ''
  ).trim();
  if (!repoPath) {
    if (body) {
      body.innerHTML = '<tr><td colspan="10"><div class="state-card">Set Repository Path to load recent run comparisons.</div></td></tr>';
    }
    if (summaryEl) {
      summaryEl.textContent = 'Compare recent finished runs to identify the most effective configuration.';
    }
    return;
  }

  if (body && opts.silent !== true) {
    body.innerHTML = '<tr><td colspan="10"><div class="state-card loading">Loading recent runs...</div></td></tr>';
  }

  try {
    const url = '/api/pipeline/run-comparison?repo_path='
      + encodeURIComponent(repoPath)
      + '&limit=12'
      + '&scope=all';
    const resp = await api(url);
    const currentRepoPath = String(document.getElementById('pipe-repo-path').value || '').trim();
    if (currentRepoPath && currentRepoPath !== repoPath) return;
    if (resp && resp.error) {
      renderPipelineRunComparison({
        runs: [],
        message: resp.error,
      });
      return;
    }
    renderPipelineRunComparison(resp || {});
  } catch (_err) {
    renderPipelineRunComparison({
      runs: [],
      message: 'Could not load run comparison metrics.',
    });
  }
}

function _formatBundleSize(bytes) {
  const size = Number(bytes || 0);
  if (!Number.isFinite(size) || size <= 0) return '0 bytes';
  if (size < 1024) return Math.round(size).toLocaleString() + ' bytes';
  const kb = size / 1024;
  if (kb < 1024) return kb.toFixed(kb >= 100 ? 0 : 1) + ' KB';
  const mb = kb / 1024;
  if (mb < 1024) return mb.toFixed(mb >= 100 ? 0 : 1) + ' MB';
  const gb = mb / 1024;
  return gb.toFixed(gb >= 100 ? 0 : 1) + ' GB';
}

async function exportRunArtifactBundle(runId) {
  const runIdClean = String(runId || '').trim();
  if (!runIdClean) {
    toast('Run ID is missing for artifact export.', 'error');
    return;
  }
  const repoPath = String(pipeConfig.repo_path || document.getElementById('pipe-repo-path').value || '').trim();
  if (!repoPath) {
    toast('Set a repository path first.', 'error');
    return;
  }

  let resp;
  try {
    resp = await postJson('/api/pipeline/run-comparison/export', {
      repo_path: repoPath,
      run_id: runIdClean,
      include_outputs: true,
      include_logs: true,
      include_config: true,
      include_history: true,
    });
  } catch (_err) {
    toast('Could not create run artifact bundle.', 'error');
    return;
  }
  if (resp && resp.error) {
    toast(String(resp.error || 'Could not create run artifact bundle.'), 'error');
    return;
  }

  const bundleName = String((resp && resp.bundle_name) || 'run-artifacts.zip');
  const bundleSize = _formatBundleSize(resp && resp.bundle_size_bytes);
  const summaryEl = document.getElementById('pipe-run-compare-summary');
  if (summaryEl) {
    summaryEl.textContent = 'Exported run ' + runIdClean + ' bundle: ' + bundleName + ' (' + bundleSize + ').';
  }
  toast('Artifact bundle created: ' + bundleName + ' (' + bundleSize + ').', 'success');

  const downloadUrl = String((resp && resp.download_url) || '').trim();
  if (downloadUrl) {
    window.open(downloadUrl, '_blank', 'noopener,noreferrer');
  }
}

function _formatPromoteDiffSummary(run) {
  const diff = (run && typeof run === 'object' && run.diff_summary && typeof run.diff_summary === 'object')
    ? run.diff_summary
    : {};
  const files = Number(diff.files_changed_total || 0);
  const net = Number(diff.net_lines_changed_total || 0);
  const touched = Number(diff.changed_paths_count || 0);
  const filesText = Number.isFinite(files) ? Math.max(0, Math.round(files)).toLocaleString() : '0';
  const touchedText = Number.isFinite(touched) ? Math.max(0, Math.round(touched)).toLocaleString() : '0';
  const netValue = Number.isFinite(net) ? Math.round(net) : 0;
  const netText = (netValue >= 0 ? '+' : '') + netValue.toLocaleString();
  return filesText + ' files changed, ' + netText + ' net lines, ' + touchedText + ' touched paths';
}

async function promoteLastDryRunToApply() {
  if (pipeRunning || pipePaused) {
    toast('Pipeline is already running.', 'info');
    return;
  }
  const repoPath = String(pipeConfig.repo_path || document.getElementById('pipe-repo-path').value || '').trim();
  if (!repoPath) {
    toast('Set a repository path first', 'error');
    return;
  }

  let preview;
  try {
    preview = await api('/api/pipeline/promote-last-dry-run?repo_path=' + encodeURIComponent(repoPath));
  } catch (_err) {
    toast('Could not load dry-run promotion details.', 'error');
    return;
  }
  if (preview && preview.error) {
    toast(preview.error, 'error');
    return;
  }
  if (!preview || !preview.available) {
    toast((preview && preview.message) || 'No completed dry-run pipeline runs were found in history yet.', 'info');
    return;
  }

  const run = (preview.run && typeof preview.run === 'object') ? preview.run : {};
  const runId = String(run.run_id || 'n/a');
  const stopReason = String(run.stop_reason || 'unknown');
  const testsSummary = String(run.tests_summary || 'n/a');
  const diffSummary = _formatPromoteDiffSummary(run);
  const confirmText = [
    'Promote the latest dry-run pipeline run to apply mode and start now?',
    '',
    'Run ID: ' + runId,
    'Finished: ' + _formatRunCompareTimestamp(run.finished_at),
    'Stop reason: ' + stopReason,
    'Tests: ' + testsSummary,
    'Diff: ' + diffSummary,
  ].join('\n');
  if (!window.confirm(confirmText)) {
    return;
  }

  pipeLogEntries = [];
  pipeResultsCache = [];
  pipeResultsCount = 0;
  _pipeResultsRenderSignature = '';
  pipeLastActivityMs = 0;
  pipeRunning = true;
  pipePaused = false;
  renderActivityHeartbeats();
  renderPipelineResumeCard();
  document.getElementById('pipe-progress-last-log').textContent = 'Last log: waiting for first message...';
  renderStopGuidance('pipe-stop-guidance', null, false);
  document.getElementById('pipe-log-viewer').innerHTML = '<div class="log-empty state-card loading">Connecting to live log stream...</div>';
  document.getElementById('pipe-results-body').innerHTML = '<tr><td colspan="8"><div class="state-card loading">Waiting for phase results...</div></td></tr>';

  const startResp = await postJson('/api/pipeline/promote-last-dry-run/start', { repo_path: repoPath });
  if (startResp.error) {
    pipeRunning = false;
    pipePaused = false;
    renderActivityHeartbeats();
    renderPipelineResumeCard();
    document.getElementById('pipe-log-viewer').innerHTML = '<div class="log-empty state-card error">Could not start pipeline. Check diagnostics and configuration.</div>';
    document.getElementById('pipe-results-body').innerHTML = '<tr><td colspan="8"><div class="state-card">No pipeline results yet. Start a pipeline run to populate this table.</div></td></tr>';
    toast(startResp.error, 'error');
    return;
  }

  const promotedConfig = (startResp.promoted_config && typeof startResp.promoted_config === 'object')
    ? startResp.promoted_config
    : ((preview.promoted_config && typeof preview.promoted_config === 'object') ? preview.promoted_config : null);
  if (promotedConfig) {
    Object.assign(pipeConfig, cloneState(promotedConfig));
    applyPipeConfigToUi();
  }
  setPipeMode('apply');
  setPipeControlsRunning(true);
  connectPipeSSE();
  startPipePolling();

  const gitPreflight = (startResp && typeof startResp.git_preflight === 'object') ? startResp.git_preflight : null;
  if (gitPreflight) {
    const actions = Array.isArray(gitPreflight.actions) ? gitPreflight.actions : [];
    const warnings = Array.isArray(gitPreflight.warnings) ? gitPreflight.warnings : [];
    if (actions.length) {
      toast('Git pre-flight: ' + actions.join(' | '), 'info');
    }
    if (warnings.length) {
      toast('Git pre-flight warnings: ' + warnings.join(' | '), 'warn');
    }
  }

  const summaryEl = document.getElementById('pipe-run-compare-summary');
  if (summaryEl) {
    summaryEl.textContent = 'Promoted dry-run ' + runId + ' to apply mode and started pipeline. Last dry-run: ' + testsSummary + ' | ' + diffSummary + '.';
  }
  toast('Promoted last dry-run to apply mode and started pipeline.', 'success');
}

async function viewLogFile(filename) {
  document.querySelectorAll('#log-file-tabs button').forEach(b => {
    b.classList.toggle('active', b.dataset.file === filename);
  });
  const label = document.getElementById('log-file-label');
  if (label) label.textContent = filename;
  const el = document.getElementById('log-file-content');
  setLogContentState(el, 'Loading file...', 'loading');
  const repoPath = (pipeConfig.repo_path || config.repo_path || '').trim();
  if (!repoPath) {
    setLogContentState(el, 'Set Repository Path in the Pipeline panel to read log files.');
    return;
  }
  try {
    const url = '/api/pipeline/logs/' + encodeURIComponent(filename)
      + '?repo_path=' + encodeURIComponent(repoPath);
    const r = await api(url);
    if (r.error) {
      setLogContentState(el, r.error);
      return;
    }
    setLogContentState(el, r.content || '(empty - this phase may not have written to this file yet)');
  } catch(e) {
    setLogContentState(el, 'Could not load file.');
  }
}

function closeScienceDashboardModal() {
  _closeOverlay('science-dashboard-overlay');
}

function _scienceNumber(value) {
  const num = Number(value || 0);
  if (!Number.isFinite(num)) return '0';
  return num.toLocaleString();
}

function _scienceSignedNumber(value) {
  const num = Number(value || 0);
  if (!Number.isFinite(num)) return '0';
  const abs = Math.abs(num).toLocaleString();
  return (num >= 0 ? '+' : '-') + abs;
}

function _scienceBadgeClass(status) {
  const s = String(status || '').toLowerCase();
  if (s === 'supported' || s === 'ok' || s === 'passed') return 'pass';
  if (s === 'refuted' || s === 'failed') return 'fail';
  return 'warn';
}

function _renderScienceBars(containerId, rows, total) {
  const el = document.getElementById(containerId);
  if (!el) return;
  if (!rows || !rows.length) {
    el.innerHTML = '<div class="science-empty">No data yet.</div>';
    return;
  }
  const denom = Math.max(1, Number(total || 0));
  el.innerHTML = '<div class="science-bars">' + rows.map(row => {
    const label = esc(String(row.label || row.phase || 'n/a'));
    const count = Number(row.count || 0);
    const pct = Math.max(0, Math.min(100, (count / denom) * 100));
    const cls = _scienceBadgeClass(label);
    return '<div class="science-bar-row">'
      + '<div class="science-bar-label">' + label + '</div>'
      + '<div class="science-bar-track"><div class="science-bar-fill ' + cls + '" style="width:' + pct.toFixed(1) + '%"></div></div>'
      + '<div class="science-bar-value">' + _scienceNumber(count) + '</div>'
      + '</div>';
  }).join('') + '</div>';
}

function _renderScienceDashboard(payload) {
  const summary = payload.summary || {};
  const cards = document.getElementById('science-cards');
  const actionEl = document.getElementById('science-actions-list');
  const timelineBody = document.getElementById('science-timeline-body');
  const implBody = document.getElementById('science-implementation-body');
  const filesEl = document.getElementById('science-top-files');
  const analysisEl = document.getElementById('science-analysis');
  const subtitleEl = document.getElementById('science-dashboard-subtitle');

  if (subtitleEl) {
    const msg = payload.available
      ? ('Repository: ' + esc(payload.repo_path || '') + ' | Trials: ' + _scienceNumber(summary.science_trials))
      : (payload.message || 'Scientist artifacts are not available yet.');
    subtitleEl.textContent = msg;
  }

  if (cards) {
    cards.innerHTML = ''
      + '<div class="science-card"><div class="science-card-label">Cycle</div><div class="science-card-value">' + _scienceNumber(summary.current_cycle) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Science Trials</div><div class="science-card-value">' + _scienceNumber(summary.science_trials) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Hypotheses</div><div class="science-card-value">' + _scienceNumber(summary.hypotheses) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Trial Tokens</div><div class="science-card-value">' + _scienceNumber(summary.trial_tokens) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Supported</div><div class="science-card-value pass">' + _scienceNumber(summary.supported) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Refuted</div><div class="science-card-value fail">' + _scienceNumber(summary.refuted) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Inconclusive</div><div class="science-card-value warn">' + _scienceNumber(summary.inconclusive) + '</div></div>'
      + '<div class="science-card"><div class="science-card-label">Rollbacks</div><div class="science-card-value warn">' + _scienceNumber(summary.rollbacks) + '</div></div>';
  }

  const verdictRows = [
    { label: 'supported', count: Number(summary.supported || 0) },
    { label: 'refuted', count: Number(summary.refuted || 0) },
    { label: 'inconclusive', count: Number(summary.inconclusive || 0) },
  ];
  _renderScienceBars('science-verdict-chart', verdictRows, Number(summary.science_trials || 0));
  _renderScienceBars('science-phase-chart', payload.phase_breakdown || [], Number(summary.science_trials || 0));

  const actionItems = Array.isArray(payload.action_items) ? payload.action_items : [];
  if (actionEl) {
    actionEl.innerHTML = actionItems.length
      ? actionItems.map((item, idx) =>
        '<div class="science-list-item"><span class="name">' + esc((idx + 1) + '. ' + item) + '</span></div>'
      ).join('')
      : '<div class="science-empty">No action checklist found yet. Run analyze to generate implementation TODO items.</div>';
  }

  const timeline = Array.isArray(payload.timeline) ? payload.timeline : [];
  if (timelineBody) {
    timelineBody.innerHTML = timeline.length
      ? timeline.map((row) =>
        '<tr>'
          + '<td>' + esc(String(row.cycle || 0)) + '</td>'
          + '<td>' + esc(String(row.phase || '')) + '</td>'
          + '<td>' + esc(String(row.hypothesis_id || 'n/a')) + '</td>'
          + '<td><span class="badge badge-' + (_scienceBadgeClass(row.verdict) === 'pass' ? 'pass' : (_scienceBadgeClass(row.verdict) === 'fail' ? 'fail' : 'skip')) + '">' + esc(String(row.verdict || 'n/a')) + '</span></td>'
          + '<td>' + esc(String(row.confidence || 'n/a')) + '</td>'
          + '<td>' + esc(String(row.baseline_test || 'n/a') + '->' + String(row.post_test || 'n/a')) + '</td>'
          + '<td>' + esc(_scienceNumber(row.files_changed) + '/' + _scienceSignedNumber(row.net_lines_changed)) + '</td>'
          + '<td>' + esc(String(row.rollback_action || 'n/a')) + '</td>'
        + '</tr>'
      ).join('')
      : '<tr><td colspan="8"><div class="science-empty">No science timeline data yet.</div></td></tr>';
  }

  const implementation = Array.isArray(payload.implementation) ? payload.implementation : [];
  if (implBody) {
    implBody.innerHTML = implementation.length
      ? implementation.map((row) =>
        '<tr>'
          + '<td>' + esc(String(row.cycle || 0)) + '</td>'
          + '<td>' + esc(String(row.phase || '')) + '</td>'
          + '<td>' + esc(String(row.iteration || 0)) + '</td>'
          + '<td><span class="badge badge-' + (_scienceBadgeClass(row.status) === 'pass' ? 'pass' : (_scienceBadgeClass(row.status) === 'fail' ? 'fail' : 'skip')) + '">' + esc(String(row.status || 'unknown')) + '</span></td>'
          + '<td>' + esc(String(row.tests || 'unknown')) + '</td>'
          + '<td>' + esc(String(row.files || 0)) + '</td>'
          + '<td>' + esc(String(row.net_delta || '0')) + '</td>'
          + '<td>' + esc(String(row.commit || '-')) + '</td>'
        + '</tr>'
      ).join('')
      : '<tr><td colspan="8"><div class="science-empty">No implementation rows in report yet.</div></td></tr>';
  }

  const topFiles = Array.isArray(payload.top_files) ? payload.top_files : [];
  if (filesEl) {
    filesEl.innerHTML = topFiles.length
      ? topFiles.map(row =>
        '<div class="science-list-item"><span class="name">' + esc(String(row.path || '')) + '</span><span class="count">' + _scienceNumber(row.touches) + '</span></div>'
      ).join('')
      : '<div class="science-empty">No touched-file summary yet.</div>';
  }

  if (analysisEl) {
    const analysisText = String(payload.analysis_excerpt || '').trim();
    analysisEl.textContent = analysisText || 'No analyze excerpt recorded yet.';
  }
}

async function refreshScienceDashboard() {
  const statusEl = document.getElementById('science-dashboard-subtitle');
  const repoPath = (pipeConfig.repo_path || config.repo_path || '').trim();
  if (statusEl) statusEl.textContent = 'Loading Scientist dashboard...';
  if (!repoPath) {
    _renderScienceDashboard({
      available: false,
      summary: {},
      action_items: [],
      timeline: [],
      phase_breakdown: [],
      implementation: [],
      top_files: [],
      analysis_excerpt: '',
      message: 'Set Repository Path in the Pipeline panel to load Scientist dashboard data.',
      repo_path: '',
    });
    return;
  }
  try {
    const url = '/api/pipeline/science-dashboard?repo_path=' + encodeURIComponent(repoPath);
    const payload = await api(url);
    if (payload.error) {
      _renderScienceDashboard({
        available: false,
        summary: {},
        action_items: [],
        timeline: [],
        phase_breakdown: [],
        implementation: [],
        top_files: [],
        analysis_excerpt: '',
        message: payload.error,
        repo_path: repoPath,
      });
      return;
    }
    _renderScienceDashboard(payload || {});
  } catch (e) {
    _renderScienceDashboard({
      available: false,
      summary: {},
      action_items: [],
      timeline: [],
      phase_breakdown: [],
      implementation: [],
      top_files: [],
      analysis_excerpt: '',
      message: 'Could not load dashboard data.',
      repo_path: repoPath,
    });
  }
}

async function openScienceDashboardModal() {
  _openOverlay('science-dashboard-overlay', '#science-dashboard-refresh');
  await refreshScienceDashboard();
}

// -- Browse modal -------------------------------------------------
let _browseTarget = null;   // id of the input to fill
let _browseCurrent = '';    // current directory being shown

function openBrowse(targetInputId) {
  _browseTarget = targetInputId;
  const input = document.getElementById(targetInputId);
  const startPath = input ? input.value.trim() : '';
  _openOverlay('browse-overlay', '.browse-modal-footer .btn-primary');
  browseTo(startPath);
}

async function browseTo(path) {
  const overlay = document.getElementById('browse-overlay');
  const pathBar = document.getElementById('browse-path');
  const listEl  = document.getElementById('browse-list');
  const drivesEl = document.getElementById('browse-drives');

  listEl.innerHTML = '<div class="browse-empty state-card loading">Loading folders...</div>';
  drivesEl.innerHTML = '';
  drivesEl.style.display = 'none';

  try {
    const r = await postJson('/api/browse-dirs', { path });
    _browseCurrent = r.current;
    pathBar.textContent = r.current;

    // Drive buttons (Windows)
    if (r.drives && r.drives.length) {
      drivesEl.style.display = 'flex';
      r.drives.forEach(letter => {
        const btn = document.createElement('button');
        btn.textContent = letter + ':\\';
        btn.onclick = () => browseTo(letter + ':\\');
        drivesEl.appendChild(btn);
      });
    }

    // Build list
    let html = '';

    // Parent directory button
    if (r.parent) {
      html += `<button class="browse-item" onclick="browseTo('${escBrowse(r.parent)}')">` +
              `<span class="browse-item-icon">&#128281;</span>` +
              `<span class="browse-item-name">..</span></button>`;
    }

    if (!r.dirs.length && !r.parent) {
      html += '<div class="browse-empty state-card">No subdirectories found.</div>';
    }

    r.dirs.forEach(d => {
      const sep = r.current.includes('/') ? '/' : '\\';
      const fullPath = r.current.replace(/[\\/]$/, '') + sep + d.name;
      const gitBadge = d.is_git ? '<span class="browse-item-git">git</span>' : '';
      const icon = d.is_git ? '&#128230;' : '&#128193;';
      html += `<button class="browse-item" onclick="browseTo('${escBrowse(fullPath)}')">` +
              `<span class="browse-item-icon">${icon}</span>` +
              `<span class="browse-item-name">${escHtml(d.name)}</span>${gitBadge}</button>`;
    });

    listEl.innerHTML = html;
  } catch (e) {
    listEl.innerHTML = '<div class="browse-empty state-card error">Could not load this directory.</div>';
  }
}

function browseSelect() {
  if (_browseTarget && _browseCurrent) {
    const input = document.getElementById(_browseTarget);
    if (input) {
      input.value = _browseCurrent;
      input.dispatchEvent(new Event('input'));
    }
  }
  browseClose();
}

function browseClose() {
  _closeOverlay('browse-overlay');
  _browseTarget = null;
}

// Escape backslashes for inline onclick
function escBrowse(s) {
  return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

// Minimal HTML escape
function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}
</script>

<!--  -->
<!-- BROWSE MODAL                                                   -->
<!--  -->
<div id="browse-overlay" class="browse-modal-overlay hidden" onclick="if(event.target===this)browseClose()">
  <div class="browse-modal" role="dialog" aria-modal="true" aria-labelledby="browse-title">
    <div class="browse-modal-header">
      <h3 id="browse-title">Browse for Folder</h3>
    </div>
    <div class="browse-path-bar" id="browse-path"></div>
    <div class="browse-drives" id="browse-drives" style="display:none"></div>
    <div class="browse-list" id="browse-list"></div>
    <div class="browse-modal-footer">
      <button class="btn" onclick="browseClose()">Cancel</button>
      <button class="btn btn-primary" onclick="browseSelect()">Select This Folder</button>
    </div>
  </div>
</div>

<div id="about-overlay" class="hidden" onclick="if(event.target===this)hideAboutModal()">
  <div class="about-card" role="dialog" aria-modal="true" aria-labelledby="about-title">
    <div class="about-header">
      <div>
        <h3 id="about-title">About WarpFoundry</h3>
        <div class="about-subtitle" id="about-subtitle">Author: Matthew Felsted</div>
      </div>
      <button class="btn" onclick="hideAboutModal()">Close</button>
    </div>
    <div class="about-body">
      <div class="about-meta" id="about-meta">Loading About details...</div>
      <div class="about-doc-links" id="about-doc-links"></div>
      <pre class="about-readme" id="about-readme">Loading README.md...</pre>
    </div>
  </div>
</div>

<div id="docs-overlay" class="hidden" onclick="if(event.target===this)closeDocsModal()">
  <div class="docs-modal" role="dialog" aria-modal="true" aria-labelledby="docs-title">
    <div class="docs-modal-header">
      <div>
        <h3 id="docs-title">Documentation</h3>
        <div class="docs-subtitle" id="docs-subtitle">Select a guide from the header links.</div>
      </div>
      <button class="btn" onclick="closeDocsModal()">Close</button>
    </div>
    <div class="docs-tab-row" id="docs-tab-row">
      <button class="btn" data-doc="quickstart" onclick="loadDoc('quickstart')">Quickstart</button>
      <button class="btn" data-doc="output_artifacts" onclick="loadDoc('output_artifacts')">Outputs</button>
      <button class="btn" data-doc="troubleshooting" onclick="loadDoc('troubleshooting')">Troubleshooting</button>
      <button class="btn" data-doc="cli_reference" onclick="loadDoc('cli_reference')">CLI Reference</button>
      <button class="btn" data-doc="tutorial" onclick="loadDoc('tutorial')">Tutorial</button>
    </div>
    <pre class="docs-content" id="docs-content">Select a guide from the header links.</pre>
  </div>
</div>

<div id="science-dashboard-overlay" class="hidden" onclick="if(event.target===this)closeScienceDashboardModal()">
  <div class="science-dashboard-modal" role="dialog" aria-modal="true" aria-labelledby="science-dashboard-title">
    <div class="science-dashboard-header">
      <div>
        <h3 id="science-dashboard-title">Scientist Dashboard</h3>
        <div class="science-dashboard-subtitle" id="science-dashboard-subtitle">
          Evidence-first view of experiments, verdicts, action plan, and implementation rollout.
        </div>
      </div>
      <div class="science-dashboard-actions">
        <button class="btn" id="science-dashboard-refresh" onclick="refreshScienceDashboard()">Refresh</button>
        <button class="btn" onclick="closeScienceDashboardModal()">Close</button>
      </div>
    </div>
    <div class="science-dashboard-body">
      <section>
        <div class="science-cards" id="science-cards">
          <div class="science-empty">Loading dashboard...</div>
        </div>
      </section>

      <section class="science-grid">
        <div class="science-panel">
          <h4>Verdict Breakdown</h4>
          <div id="science-verdict-chart"></div>
        </div>
        <div class="science-panel">
          <h4>Phase Breakdown</h4>
          <div id="science-phase-chart"></div>
        </div>
      </section>

      <section class="science-grid">
        <div class="science-panel">
          <h4>Action Plan</h4>
          <div class="science-list" id="science-actions-list"></div>
        </div>
        <div class="science-panel">
          <h4>Most-Touched Files</h4>
          <div class="science-list" id="science-top-files"></div>
        </div>
      </section>

      <section class="science-panel">
        <h4>Science Timeline</h4>
        <div class="science-table-wrap">
          <table class="science-table">
            <thead>
              <tr>
                <th>Cycle</th>
                <th>Phase</th>
                <th>Hypothesis</th>
                <th>Verdict</th>
                <th>Confidence</th>
                <th>Tests</th>
                <th>Delta</th>
                <th>Rollback</th>
              </tr>
            </thead>
            <tbody id="science-timeline-body">
              <tr><td colspan="8"><div class="science-empty">No timeline data yet.</div></td></tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="science-panel">
        <h4>Implementation Rollout</h4>
        <div class="science-table-wrap">
          <table class="science-table">
            <thead>
              <tr>
                <th>Cycle</th>
                <th>Phase</th>
                <th>Iter</th>
                <th>Status</th>
                <th>Tests</th>
                <th>Files</th>
                <th>Net</th>
                <th>Commit</th>
              </tr>
            </thead>
            <tbody id="science-implementation-body">
              <tr><td colspan="8"><div class="science-empty">No implementation rows yet.</div></td></tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="science-panel">
        <h4>Latest Analyze Excerpt</h4>
        <pre class="science-analysis" id="science-analysis">No analyze excerpt recorded yet.</pre>
      </section>
    </div>
  </div>
</div>

<div id="run-plan-overlay" class="hidden" onclick="if(event.target===this)closeRunPlanModal({ action: 'cancel' })">
  <div class="run-plan-modal" role="dialog" aria-modal="true" aria-labelledby="run-plan-title">
    <div class="run-plan-header">
      <div>
        <h3 id="run-plan-title">Run Configuration</h3>
        <div class="run-plan-subtitle" id="run-plan-subtitle">
          Review what this run will do before starting.
        </div>
      </div>
      <div class="run-plan-model-chip" id="run-plan-model-chip">Model: GPT-5.3-Codex</div>
    </div>
    <div class="run-plan-body">
      <div class="run-plan-grid">
        <div class="run-plan-field">
          <label for="run-plan-mode">Execution Behavior</label>
          <select id="run-plan-mode" onchange="updateRunPlanModalPreview()">
            <option value="dry-run">Dry Run (recommended)</option>
            <option value="apply">Apply Changes</option>
          </select>
        </div>
        <div class="run-plan-field">
          <label for="run-plan-profile">Codex Permission Profile</label>
          <select id="run-plan-profile" onchange="updateRunPlanModalPreview()">
            <option value="safe">Recommended: Safe Repo Access</option>
            <option value="full_access">Trusted Repo Full Access</option>
            <option value="readonly">Read-Only Inspect</option>
          </select>
        </div>
      </div>

      <div class="run-plan-summary">
        <div class="run-plan-summary-line" id="run-plan-summary-mode"></div>
        <div class="run-plan-summary-line" id="run-plan-summary-profile"></div>
        <div class="run-plan-callout" id="run-plan-summary-callout"></div>
      </div>

      <label class="run-plan-danger hidden" id="run-plan-danger-wrap">
        <input type="checkbox" id="run-plan-danger-ack">
        <span>I understand trusted full-access mode disables sandbox and approval safeguards for this run.</span>
      </label>
    </div>
    <div class="run-plan-actions">
      <button class="btn" onclick="closeRunPlanModal({ action: 'cancel' })">Cancel</button>
      <button class="btn btn-success" onclick="confirmRunPlanModal()">Start Run</button>
    </div>
  </div>
</div>

<div id="permissions-help-overlay" class="hidden" onclick="if(event.target===this)closePermissionsHelpModal()">
  <div class="permissions-help-modal" role="dialog" aria-modal="true" aria-labelledby="permissions-help-title">
    <div class="permissions-help-header">
      <h3 id="permissions-help-title">Permission Settings Guide</h3>
      <button class="btn" onclick="closePermissionsHelpModal()">Close</button>
    </div>
    <div class="permissions-help-body">
      <div class="permissions-help-card">
        <h4>Recommended: Safe Repo Access</h4>
        <p>Best default. Agent can read/write files in your repository only, with no interactive approval prompts.</p>
      </div>
      <div class="permissions-help-card">
        <h4>Read-Only Inspect</h4>
        <p>Use for analysis and planning. Agent can read files but should not write changes.</p>
      </div>
      <div class="permissions-help-card">
        <h4>Trusted Repo Full Access</h4>
        <p>Use only when you fully trust the repository and environment. Disables sandbox and approval checks.</p>
      </div>
      <div class="permissions-help-card">
        <h4>Manual Controls</h4>
        <p><strong>Sandbox Mode</strong> controls filesystem access scope.</p>
        <p><strong>Approval Policy</strong> controls if/when interactive approvals are required.</p>
        <p><strong>Disable sandbox + approvals</strong> forces maximum autonomy for trusted local work.</p>
      </div>
      <div class="permissions-help-card">
        <h4>When To Change These</h4>
        <p>Most users should keep Recommended. Change profiles only if you need strict read-only checks or trusted full-access automation.</p>
      </div>
    </div>
  </div>
</div>


<div id="readonly-warning-overlay" class="hidden" onclick="if(event.target===this)closeReadOnlyWarningModal('cancel')">
  <div class="readonly-warning-modal" role="dialog" aria-modal="true" aria-labelledby="readonly-warning-title">
    <div class="readonly-warning-header">
      <h3 id="readonly-warning-title">Read-Only Sandbox Active</h3>
    </div>
    <div class="readonly-warning-body">
      <p id="readonly-warning-message">Codex is currently running with read-only filesystem access.</p>
      <div class="readonly-warning-callout" id="readonly-warning-guidance">
        Switch to a write-enabled permission profile if you want Codex to modify files.
      </div>
      <p>For read/write access, switch to <strong>Trusted Repo Full Access</strong> (or <strong>Recommended: Safe Repo Access</strong> for sandboxed writes).</p>
    </div>
    <div class="readonly-warning-actions">
      <button class="btn" id="readonly-warning-cancel" onclick="closeReadOnlyWarningModal('cancel')">Cancel</button>
      <button class="btn" onclick="closeReadOnlyWarningModal('continue_readonly')">Run Read-Only</button>
      <button class="btn" onclick="closeReadOnlyWarningModal('switch_safe')">Use Safe Write Mode</button>
      <button class="btn btn-danger" onclick="closeReadOnlyWarningModal('switch_trusted')">Use Trusted Repo Full Access</button>
    </div>
  </div>
</div>
</body>
</html>

